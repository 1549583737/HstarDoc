<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  
  <title>Archives: 2015/1 | 幻☆精灵的Blog</title>
  <meta name="description" content="幻☆精灵的Blog站点" />
  <meta name="keywords" content="幻精灵" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <link rel="shortcut icon" href="/blog/images/favicon.ico">
  <link rel="alternate" href="/blog/atom.xml" title="幻☆精灵的Blog">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="幻☆精灵的Blog站点">
<meta property="og:type" content="website">
<meta property="og:title" content="幻☆精灵的Blog">
<meta property="og:url" content="http://hstarorg.github.io/blog/archives/2015/01/index.html">
<meta property="og:site_name" content="幻☆精灵的Blog">
<meta property="og:description" content="幻☆精灵的Blog站点">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="幻☆精灵的Blog">
<meta name="twitter:description" content="幻☆精灵的Blog站点">
    
  <link href="https://fonts.googleapis.com/css?family=Inconsolata|Titillium+Web" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css?family=Roboto+Mono" rel="stylesheet">
  <link href='//cdn.bootcss.com/node-waves/0.7.5/waves.min.css' rel='stylesheet'>
  <link rel="stylesheet" href="/blog/style.css">
  
  

  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>
</head>

<body>
  <div id="loading-bar-wrapper">
  <div id="loading-bar"></div>
</div>


  <script>setLoadingBarProgress(20)</script> 
  <header class="l_header">
		<div class="wrapper container">
			<a class="logo flat-box" href='/blog/' >
				幻☆精灵的Blog
			</a>
			<div class='menu'>
				<ul class='h-list'>
					
						<li>
							<a class='flat-box nav-home' href='/blog/'>
								首页
							</a>
						</li>
					
						<li>
							<a class='flat-box nav-archives' href='/blog/archives'>
								归档
							</a>
						</li>
					
						<li>
							<a class='flat-box nav-about' href='/blog/about'>
								关于我
							</a>
						</li>
					
				</ul>
				<div class='underline'></div>
			</div>
			
				<div class="m_search">
					<form name="searchform" class="form u-search-form">
						<input type="text" class="input u-search-input" placeholder="Search" />
						<span class="icon icon-search"></span>
					</form>
				</div>
			
			<ul class='switcher h-list'>
				
					<li class='s-search'><a href='javascript:void(0)'><span class="icon icon-search"></span></a></li>
				
				<li class='s-menu'><a href='javascript:void(0)'><span class="icon icon-menu"></span></a></li>
			</ul>
		</div>
		<aside class="menu-phone">
			<nav>
				
					<a href="/blog/" class="nav-home nav">
						首页
					</a>
				
					<a href="/blog/archives" class="nav-archives nav">
						归档
					</a>
				
					<a href="/blog/about" class="nav-about nav">
						关于我
					</a>
				
			</nav>
		</aside>
</header>

    <script>setLoadingBarProgress(40);</script>
  <div class="l_body">
    <div class='container'>
      <div class='l_main'>
        
	
	<section class="page-header archive banner waves-image">
    <h1>Year : <span>2015.1</span></h1>
  </section>

<section class="post-list">
	
    <div class='post-wrapper'>
      <article class="post reveal">
  <section class="meta">
    
    <h2 class="title">
      <a href="/blog/2015/01/23/编写高质量JS代码的68个有效方法-读书笔记/[20150123]编写高质量JS代码的68个有效方法（十）/">
        编写高质量JS代码的68个有效方法（十）
      </a>
    </h2>
    
    <time>
      Jan 23, 2015
    </time>
		
  </section>
  <section class="article typo">
	  <p>##No.46、使用数组而不要使用字典来存储有序集合<br><strong>Tips:</strong></p>
<ol>
<li>使用for…in 循环来枚举对象属性应当与顺序无关</li>
<li>如果聚集运算字典中的数据，确保聚集操作与顺序无关</li>
<li>使用数组而不是字典来存储有序集合</li>
</ol>
<p>由于标准允许JavaScript引擎自由选择顺序，那么如果用字典存储有序数据，就会导致兼容性问题。</p>
<p>##No.47、绝不要在Object.prototype中增加可枚举的属性<br><strong>Tips：</strong></p>
<ol>
<li>避免在Object.prototype中增加属性</li>
<li>考虑编写一个函数代理Object.prototype方法</li>
<li>如果你是在需要在prototype中增加属性，请使用ES5中的Object.defineProperty方法将它们定义为不可枚举的属性</li>
</ol>
<p><code>for...in</code>循环非常便利，但是容易受到原型污染。如果在Object.prorotype中增加可枚举属性的话，将会导致大多数<code>for...in</code>循环受到污染。</p>
<p>如果是在是要在Object.prototype上定义属性的话，可以使用如下代码：</p>
<pre><code>Object.defineProperty(Object.prototype, &apos;allKeys&apos;, {
  value: function(){
    var arr = [];
    for(var key in this){
      arr.push(key);
    }
    return arr;
  },
  writable: true,
  enumerable: false, //设置属性为不可枚举
  configurable: true
});
</code></pre><p>测试代码：</p>
<pre><code>var obj = {a: 1, b: 2};
console.log(obj.allKeys()); // [&apos;a&apos;, &apos;b&apos;]
</code></pre><p>##No.48、避免在枚举期间修改对象<br><strong>Tips：</strong></p>
<ol>
<li>当使用<code>for...in</code> 循环枚举一个对象的属性时，确保不要修改该对象</li>
<li>当迭代一个对象时，如果该对象的内容可能会在循环期间被改变，应该使用while循环或经典的for循环来代替<code>for...in</code></li>
<li>为了在不断变化的数据结构中能够预测枚举，考虑使用一个有序的数据结构，例如数组，而不要使用字典</li>
</ol>
<p>在大部分编译型语言中，如果在迭代时修改对象属性，是会出现编译错误的。在js中，没有这样的编译机制，但是也尽量保证不要修改迭代对象。</p>
<p>如果在被枚举时添加了新对象，并不一定能保证新添加的对象能被访问到：</p>
<pre><code>var obj = {a: 1, b: 2};
for(var p in obj){
  console.log(p);
  obj[p + &apos;1&apos;] = obj[p] + 1;
}
</code></pre><p>遇到这样的场景，应当使用while和标准的for循环。</p>
<p>##No.49、数组迭代要优先使用for循环而不是<code>for...in</code>循环<br><strong>Tips:</strong></p>
<ol>
<li>迭代数组的索引属性应当总是使用for循环而不是<code>for...in</code>循环</li>
<li>考虑在循环之前将数组的长度存储在一个局部变量中以避免重新计算数组长度</li>
</ol>
<p>猜测下面一段代码的结果？</p>
<pre><code>var arr = [5, 6, 8, 10, 9];
var sum = 0;
for(var a in arr){
  sum += a;
}
console.log(sum);
</code></pre><p>要达到正确的结果，那么应该使用for循环</p>
<pre><code>var arr = [5, 6, 8, 10, 9];
var sum = 0;
for(var i = 0, len = arr.length; i &lt; len; i++){
  sum += arr[i];
}
console.log(sum); //38
</code></pre><p>再看一个比较极端的例子：</p>
<pre><code>var arr = [5, 6, 8, 10, 9];
arr.len = 4;
for(var p in arr){
  console.log(p);
}
</code></pre><p>这个时候用<code>for...in</code>,完全是达不到预期效果的</p>
<p>再来看一个对于数组长度缓存的测试代码：</p>
<pre><code>var count = 0;
console.time(&apos;t1&apos;);
while(count &lt; 10000){
  var arr = [5, 6, 8, 10, 9];
  var sum = 0;
  count++;
  for(var i = 0, len = arr.length; i &lt; len; i++){
    sum += arr[i];
  }
}
console.timeEnd(&apos;t1&apos;);

count = 0;
console.time(&apos;t2&apos;);
while(count &lt; 10000){
  var arr = [5, 6, 8, 10, 9];
  var sum = 0;
  count++;
  for(var i = 0; i &lt; arr.length; i++){
    sum += arr[i];
  }
}
console.timeEnd(&apos;t2&apos;);
</code></pre><p>结果，请自行复制代码执行。。。</p>
<p>##No.50、迭代方法优于循环<br><strong>Tips：</strong></p>
<ol>
<li>使用迭代方法（如Array.prototype.forEach和Array.prototype.map）替换for循环使得代码更可读，并且避免了重复循环控制逻辑</li>
<li>使用自定义的迭代函数来抽象未被标准库支持的常见循环模式</li>
<li>在需要提前终止循环的情况下，仍然推荐使用传统的循环。另外some和every方法也可用于提前退出</li>
</ol>
<p>在使用循环的时候，在确定循环的终止条件时容易引入一些简单的错误：</p>
<pre><code>for(var i = 0; i &lt;= n; i++){}
for(var i = 1; i&lt; n; i++){}
</code></pre><p>比较庆幸的是，闭包是一种为这些模式建立迭代抽象方便的、富有表现力的手法。</p>
<p>我们可以用以下代码来代替：</p>
<pre><code>var arr = [1, 2, 3];
arr.forEach(function(v, i){
  console.log(v);
});
</code></pre><p>如果要创建新数组，那么可以用以下方式：</p>
<pre><code>var arr = [1, 2, 3];
var arrNew = [];
//方式一
arr.forEach(function(v, i){
  arrNew.push(v);
});
//方式二
for(var i = 0, len = arr.length; i &lt; len; i++){
  arrNew.push(arr[i]);
}
</code></pre><p>为了简化这种普遍操作，ES5中引入了Array.prototype.map方法：</p>
<pre><code>var arr = [1, 2, 3];
var arrNew = arr.map(function(v){
  return v;
});
</code></pre><p>同样，如果想提取满足条件的元素，ES5也提供了filter方法：</p>
<pre><code>var arr = [1, 2, 3];
var arrNew = arr.filter(function(v){
  return v &gt; 1;
});
console.log(arrNew);
</code></pre><p>在ES5中，针对数组也提供了some和every ,可以用来终止循环，但是实际意义等同于C#的Linq方法All和Any：</p>
<pre><code>var arr = [1, 2, 3];

//数组元素有一个&gt;1就返回true，并终止循环
var b = arr.some(function(a){
  return a&gt;1;
});
console.log(b); //true

//数组元素每个都&lt;3，则返回true，否则返回false，并提前终止循环
b = arr.every(function(a){
  return a&lt;3;
});
console.log(b); //false
</code></pre>

    
    
    
  </section>
</article>
    </div>
  
    <div class='post-wrapper'>
      <article class="post reveal">
  <section class="meta">
    
    <h2 class="title">
      <a href="/blog/2015/01/10/编写高质量JS代码的68个有效方法-读书笔记/[20150110]编写高质量JS代码的68个有效方法（九）/">
        编写高质量JS代码的68个有效方法（九）
      </a>
    </h2>
    
    <time>
      Jan 10, 2015
    </time>
		
  </section>
  <section class="article typo">
	  <p>##No.41、将原型视为实现细节<br><strong>Tips：</strong></p>
<ol>
<li>对象是接口，原型是实现</li>
<li>避免检查你无法控制的对象的原型结构</li>
<li>避免检查实现在你无法控制的对象内部的属性</li>
</ol>
<p>我们可以获取对象的属性值和调用其方法，这些操作都不是特别在意属性存储在原型继承结构的哪个位置。只要其属性值保存很定，那么这些操作的行为也不变。简言之，原型是一种对象行为的实现细节。</p>
<p>正是由于以上的特性，所以如果修改了实现细节，那么依赖于这些对象的使用者就会被破坏，而且还很难诊断这类bug。所以一般来说，对于使用者，最好不要干涉那些属性。</p>
<p>##No.42、避免使用轻率的猴子补丁<br><strong>Tips：</strong></p>
<ol>
<li>避免使用轻率的猴子补丁</li>
<li>记录程序库所执行的所有猴子补丁</li>
<li>考虑通过将修改设置于一个导出函数中，使猴子补丁成为可选的</li>
<li>使用猴子补丁为缺失的标准API提供polyfills</li>
</ol>
<p><strong>何为猴子补丁？</strong></p>
<p>由于对象共享原型，因为每一个对象都可以增加、删除或修改原型的属性。这个有争议的实践通常被称为猴子补丁。</p>
<p>猴子补丁的吸引力在于它的强大，如果数组缺少一个有用的方法，那么我们可以自己扩展它。但是在多个库同时对数组进行不兼容扩展时，问题就来了，有可能调用方法之后的结果和预期不一致。</p>
<p>危险的猴子补丁有一个特别可靠而且有价值的使用场景：polyfill。补齐标准所支持的方法。</p>
<p>##No.43、使用Object的直接实例构造轻量级的字典<br><strong>Tips:</strong></p>
<ol>
<li>使用对象字面量构建轻量级字典</li>
<li>轻量级字典应该是Object.prototype的直接子类，以使for…in循环免受原型污染</li>
</ol>
<p>JavaScript对象的核心是一个字符串属性名称与属性值的映射表。</p>
<pre><code>var dict = {
  key1: &apos;value1&apos;,
  key2: &apos;value2&apos;
};
for(var key in dict){
  console.log(&apos;key=&apos;+ key + &apos;,value=&apos; + dict[key]);
}
</code></pre><p>在使用for…in时，要小心原型污染。</p>
<pre><code>function Dict(){
  Dict.prototype.count = function(){
    var c = 0;
    for(var p in this){
      c++;
    }
    return c;
  }  
}

var dict = new Dict();
dict.name = &apos;jay&apos;;
console.log(dict.count()); //结果是2，因为for...in会枚举出所有的属性，包括原型上的。
</code></pre><p>所有人都不应当增加属性到Object.prototype上，因为这样做可能会污染for…in循环，那么我们通过使用Object的直接实例，可以将风险仅仅局限于Object.prototype。</p>
<p>##No.44、使用null原型以防止原型污染<br><strong>Tips：</strong></p>
<ol>
<li>在ES5中，使用Object.create(null)创建的自由原型的空对象是不太容易被污染的</li>
<li>在一些较老的环境中，考虑使用{<strong>proto</strong>: null}</li>
<li>要注意<code>__proto__</code>既不标准，也不是完全可移植的，并且可能会在未来的JavaScript环境中去除</li>
<li>绝不要使用<code>__proto__</code>名作为字典的key，因为一些环境将其作为特殊的属性对待</li>
</ol>
<p>对构造函数的原型属性设置null或者是undefined是无效的：</p>
<pre><code>function Dict(){

}
Dict.prototype = null;
var dict = new Dict();
console.log(Object.getPrototypeOf(dict) === null); // false
console.log(Object.getPrototypeOf(dict) === Object.prototype); //true
</code></pre><p>在ES5中，提供了标准方法来创建一个没有原型的对象：</p>
<pre><code>var dict = Object.create(null);
console.log(Object.getPrototypeOf(dict) === null); // true
</code></pre><p>在不支持Object.create函数的旧的JS环境中，可以使用如下方式创建没有原型的对象：</p>
<pre><code>var dict = {__proto__: null}
console.log(Object.getPrototypeOf(dict) === null); // true
</code></pre><p><strong>注意：在支持Object.create函数的环境中，尽可能的坚持使用标准的Object.create函数</strong></p>
<p>##No.45、使用hasOwnProperty方法来避免原型污染<br><strong>Tips：</strong></p>
<ol>
<li>使用hasOwnProperty方法避免原型污染</li>
<li>使用词法作用域和call方法避免覆盖hasOwnProperty方法</li>
<li>考虑在封装hasOwnProperty测试样板代码的类中实现字典操作</li>
<li>使用字典类避免将<code>__proto__</code>作为key来使用</li>
</ol>
<p>即使是一个空的对象字面量也继承了Object.prototype的大量属性：</p>
<pre><code>var dict = {}
console.log(&apos;a&apos; in dict); // false
console.log(&apos;toString&apos; in dict); // true
console.log(&apos;valueOf&apos; in dict); // true
</code></pre><p>不过，Object.prototype提供了方法来测试字典条目：</p>
<pre><code>var dict = {}
console.log(dict.hasOwnProperty(&apos;a&apos;)); // false
console.log(dict.hasOwnProperty(&apos;toString&apos;)); // false
console.log(dict.hasOwnProperty(&apos;valueOf&apos;)); // false
</code></pre><p>但是，如果在字典中存储一个同为“hasOwnProperty”的属性，那么：</p>
<pre><code>var dict = {
  hasOwnProperty: null
}
console.log(dict.hasOwnProperty(&apos;a&apos;)); // TypeError
</code></pre><p>最安全的方法则是使用call：</p>
<pre><code>var dict = {
  hasOwnProperty: null
}
console.log({}.hasOwnProperty.call(dict, &apos;hasOwnProperty&apos;)); // true、
</code></pre><p>最后，我们来看一个复杂的但更安全的字典类：</p>
<pre><code>function Dict(elements){
  this.elements = elements || {};
  this.hasSpecialProto = false;
  this.specialProto = undefined;
}

Dict.prototype.has = function(key){
  if(key === &apos;__proto__&apos;){
    return this.hasSpecialProto;
  }
  return {}.hasOwnProperty.call(this.elements, key);
};

Dict.prototype.get = function(key){
  if(key === &apos;__proto__&apos;){
    return this.specialProto;
  }
  return this.has(key) ? this.elements[key] : undefined;
};

Dict.prototype.set = function(key, value){
  if(key === &apos;__proto__&apos;){
    this.hasSpecialProto = true;
    this.specialProto = value;
  }else{
    this.elements[key] = value;
  }
};

Dict.prototype.remove = function(key){
  if(key === &apos;__proto__&apos;){
    this.hasSpecialProto = false;
    this.specialProto = undefined;
  }else{
    delete this.elements[key];
  }
};

// 测试代码
var dict = new Dict();
console.log(dict.has(&apos;__proto__&apos;)); // false
</code></pre>

    
    
    
  </section>
</article>
    </div>
  
    <div class='post-wrapper'>
      <article class="post reveal">
  <section class="meta">
    
    <h2 class="title">
      <a href="/blog/2015/01/07/前端相关/[20150107]Web离线存储的几种方式/">
        Web离线存储的几种方式
      </a>
    </h2>
    
    <time>
      Jan 7, 2015
    </time>
		
  </section>
  <section class="article typo">
	  <p>随着HTML5的正式定稿，我们也可以大量使用HTML离线网络应用程序的特性。</p>
<h1 id="1、Application-Cache"><a href="#1、Application-Cache" class="headerlink" title="#1、Application Cache"></a>#1、Application Cache</h1><p><a href="http://www.w3schools.com/html/html5_app_cache.asp" target="_blank" rel="external">Application Cache</a> 可以很简单让我们的WebApp具有离线的能力。</p>
<p><strong>支持的浏览器：</strong>IE10+，FireFox，Chrome，Safari，Opera</p>
<p><strong>优点：</strong></p>
<ol>
<li>离线浏览 – 用户可以再离线时使用Application</li>
<li>速度 – 由于缓存了资源，如果加载很快</li>
<li>减少服务端数据加载 – 浏览器只需要从服务器加载更新过的数据</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li>Manifest文件有变化时才更新</li>
<li>一次必须更新Manifest中的所有文件，下次才生效</li>
</ol>
<p><strong>如何使用？</strong></p>
<p>Step1:在html上指定manifest文件 (index.html)</p>
<pre><code>&lt;html manifest=&quot;appCacheList.manifest&quot;&gt;
&lt;/html&gt;
</code></pre><p>Step2:设定manifest文件内容 (appCache.manifest)</p>
<pre><code>CACHE MANIFEST

# 离线缓存的内容
./all.css
./1.jpg
./index.js

# NETWORK:*，表示其他内容从网络获取
NETWORK:
*

# 第一个uri是资源，第二个是fallback
FALLBACK:
/html/ /offline.html
</code></pre><p>手动更新缓存：</p>
<pre><code>if ( window.applicationCache.status == window.applicationCache.UPDATEREADY ){
    window.applicationCache.update();
}
</code></pre><p><strong>注意：</strong></p>
<ol>
<li>不同的浏览器对Application Cache的大小不一致，请注意。</li>
<li>更多细节可参考<a href="http://kayosite.com/web-app-by-jquery-mobile-and-html5-offline-web-applications.html" target="_blank" rel="external">http://kayosite.com/web-app-by-jquery-mobile-and-html5-offline-web-applications.html</a></li>
</ol>
<h1 id="2、Local-Storage"><a href="#2、Local-Storage" class="headerlink" title="#2、Local Storage"></a>#2、Local Storage</h1><p><a href="http://www.w3schools.com/html/html5_webstorage.asp" target="_blank" rel="external">Local Storage</a>使得我们可以在浏览器中保存数据。</p>
<p><strong>支持的浏览器：</strong>IE10+，FireFox，Chrome，Safari，Opera</p>
<p><strong>优点：</strong></p>
<ol>
<li>容量大</li>
<li>易用</li>
<li>强大</li>
<li>原生支持</li>
<li>仅存在本地，不会与服务器发生交互</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li>浏览器兼容性差</li>
<li>安全性差（不要存储敏感数据）</li>
</ol>
<p><strong>如何使用？</strong></p>
<p>首先通过 <code>window.localStorage</code> 来判断浏览器是否支持Local Storage。然后由于该方式具有浏览器兼容性，建议用一个通用的库，来屏蔽兼容性。</p>
<pre><code>// 对基本方法的封装，需要判断浏览器，屏蔽它们的细节差异。
(function(window){
  if(!window.localStorage){
    throw new Error(&apos;Your brower can\&apos;t support local storage!&apos;);
  }
  var ls = window.localStorage;
  var localStorageKit = {
    getLength: function(){
      return ls.length;
    },
    clear: function(){
      ls.clear();
      return true;
    },
    set: function(k, v){
      ls.setItem(k, v);
    },
    get: function(k){
      return ls.getItem(k);
    },
    remove: function(k){
      ls.removeItem(k);
    },
    getKeyByIndex: function(index){
      return ls.key(index);
    }
  };
  window.lsKit = localStorageKit;
})(window);
</code></pre><p>基本操作方式与cookie无太多差异。</p>
<p><strong>Session Storage：</strong><br>Session Storage和Local Storage非常类似，操作方式也一致。由于其中保存的存只是当前会话有效，那么此处就不细说。</p>
<h1 id="3、Web-SQL"><a href="#3、Web-SQL" class="headerlink" title="#3、Web SQL"></a>#3、Web SQL</h1><p><a href="http://en.wikipedia.org/wiki/Web_SQL_Database" target="_blank" rel="external">Web Sql Database</a>，是html5环境下可以用js执行CRUD的web数据库。数据库核心是SQLite。</p>
<p><strong>优点：</strong></p>
<ol>
<li>本地数据库</li>
<li>可以处理复杂的关系型数据</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li>暂时只有chrome才支持，对于Android大行其道的移动端，这应该是可以避免的缺点(貌似最新版本的Opera和Safari也支持了)</li>
</ol>
<p><strong>如何使用？</strong></p>
<p>首先，先介绍Web sql的三个核心方法：</p>
<ol>
<li>openDatabase：这个方法使用现有数据库或创建新数据库创建数据库对象。</li>
<li>transaction：这个方法允许我们根据情况控制事务提交或回滚。</li>
<li><p>executeSql：这个方法用于执行真实的SQL查询。</p>
<p> var db = openDatabase(‘mydb’, ‘1.0’, ‘Test DB’, 2 <em> 1024 </em> 1024);<br> var msg;<br> db.transaction(function (tx) {<br>   tx.executeSql(‘CREATE TABLE IF NOT EXISTS LOGS (id unique, log)’);<br>   tx.executeSql(‘INSERT INTO LOGS (id, log) VALUES (1, “foobar”)’);<br>   tx.executeSql(‘INSERT INTO LOGS (id, log) VALUES (2, “logmsg”)’);<br>   console.log(‘Log message created and row inserted.’);<br> });<br> db.transaction(function (tx) {<br>   tx.executeSql(‘SELECT * FROM LOGS’, [], function (tx, results) {</p>
<pre><code>var len = results.rows.length, i;
console.log(&apos;Found rows: &apos; + len);
for (i = 0; i &lt; len; i++){
  console.log(results.rows.item(i).log)
}
</code></pre><p>   }, null);<br> });</p>
</li>
</ol>
<p>当成数据库用，就行。</p>
<h1 id="4、IndexedDB"><a href="#4、IndexedDB" class="headerlink" title="#4、IndexedDB"></a>#4、IndexedDB</h1><p><a href="http://www.w3.org/TR/IndexedDB/" target="_blank" rel="external">IndexedDB</a>是结构化的本地数据存储。是基于平面文件的数据库，采用了分层的键值存储和基本的索引。</p>
<p><strong>优点：</strong></p>
<ol>
<li>标准化</li>
<li>存储复杂数据</li>
<li>支持索引</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li>不支持SQL</li>
<li>相对来说，操作较复杂</li>
</ol>
<p><strong>如何使用？</strong></p>
<pre><code>// 打开数据库，第一个参数为数据库名，第二个为数据库版本号
var dbRequest = window.indexedDB.open(&apos;testDb&apos;, 2);

dbRequest.onupgradeneeded=function(e){
    // 创建数据仓库
    var db=e.target.result;
    if(!db.objectStoreNames.contains(&apos;users&apos;)){
        var store=db.createObjectStore(&apos;users&apos;,{keyPath: &apos;id&apos;});
        store.createIndex(&apos;nameIndex&apos;,&apos;name&apos;,{unique:true}); 
        store.createIndex(&apos;ageIndex&apos;,&apos;age&apos;,{unique:false}); 
    }
    console.log(&apos;upgrade successfully!&apos;);
};

dbRequest.onsuccess = function(e){
  console.log(&apos;Open database successfully!&apos;);
  // 这里拿到了数据库
  var db = e.target.result;
  var storeName = &apos;users&apos;;
  // 写入数据
  var tran = db.transaction(storeName, &apos;readwrite&apos;);
  var users = tran.objectStore(storeName);
  for(var i = 0; i &lt; 5; i++){
    users.add({
      id: i,
      name: &apos;user&apos; + i,
      age: Math.floor(Math.random() * 10) + 18
    });
  }

  //查询数据
  var userStore = db.transaction(storeName).objectStore(storeName);
  var request = userStore.openCursor();
  request.onsuccess = function(e){
    var cursor = e.target.result;
    if(cursor){
      console.log(cursor.key);
      console.log(cursor.value);
      cursor.continue();
    }
  }
}
</code></pre><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p><a href="http://html5online.com.cn/articles/2012080901.html" target="_blank" rel="external">HTML 5中几种用于在客户端本地存储数据的API之间的比较</a></p>
<p><a href="http://www.cnblogs.com/dolphinX/p/3415761.html" target="_blank" rel="external">HTML5本地存储——IndexedDB（一：基本使用）</a></p>
<p><a href="http://www.cnblogs.com/dolphinX/p/3416889.html" target="_blank" rel="external">HTML5本地存储——IndexedDB（二：索引）</a></p>


    
    
    
  </section>
</article>
    </div>
  
</section>



      </div>
      <aside class='l_side'>
        
  <section class='m_widget about'>

<img class='avatar waves-image' src='https://avatars1.githubusercontent.com/u/4043284?v=3&amp;s=460' />

<div class='header'>Jay.M.Hu</div>
<div class='content'>
<div></div>
</div>
</section>

  <section class='m_widget friendly-links'>
<div class='header'>Links</div>
<div class='content'>
    <ul class="entry">
    
        <li><a class="flat-box" target="_blank" href="http://humin.cnblogs.com/">
            <div class='name'>幻天芒 - 博客园</div>
        </a></li>
    
    </ul>
</div>
</section>

  <section class='m_widget categories'>
<div class='header'>Categories</div>
<div class='content'>
    
</div>
</section>

  


      </aside>
      <script>setLoadingBarProgress(60);</script>
    </div>
  </div>
  <footer id="footer" class="clearfix">

	<div class="social-wrapper">
  	
      
        <a href="https://github.com/hstarorg" class="social github"
          target="_blank" rel="external">
          <span class="icon icon-github"></span>
        </a>
      
        <a href="/atom.xml" class="social rss"
          target="_blank" rel="external">
          <span class="icon icon-rss"></span>
        </a>
      
    
  </div>
  
  <div>Theme <a href='https://github.com/stkevintan/hexo-theme-material-flow' class="codename">MaterialFlow</a> designed by <a href="http://keyin.me/" target="_blank">Kevin Tan</a>.</div>
  
</footer>


  <script>setLoadingBarProgress(80);</script>
  

<script src="//apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
<script src='//cdn.bootcss.com/node-waves/0.7.5/waves.min.js'></script>
<script src="//cdn.bootcss.com/scrollReveal.js/3.3.2/scrollreveal.min.js"></script>
<script src="/blog/js/jquery.fitvids.js"></script>
<script>
	var GOOGLE_CUSTOM_SEARCH_API_KEY = "";
	var GOOGLE_CUSTOM_SEARCH_ENGINE_ID = "";
	var ALGOLIA_API_KEY = "";
	var ALGOLIA_APP_ID = "";
	var ALGOLIA_INDEX_NAME = "";
  var AZURE_SERVICE_NAME = "";
  var AZURE_INDEX_NAME = "";
  var AZURE_QUERY_KEY = "";
  var BAIDU_API_ID = "";
  var SEARCH_SERVICE = "hexo";
  var ROOT = "/blog/"||"/";
  if(!ROOT.endsWith('/'))ROOT += '/';
</script>
<script src="/blog/js/search.js"></script>
<script src="/blog/js/app.js"></script>


  <script>setLoadingBarProgress(100);</script>
</body>
</html>
