<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  
  <title>Archives: 2017 | 幻☆精灵的Blog</title>
  <meta name="description" content="幻☆精灵的Blog站点" />
  <meta name="keywords" content="幻精灵" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <link rel="shortcut icon" href="/blog/images/favicon.ico">
  <link rel="alternate" href="/blog/atom.xml" title="幻☆精灵的Blog">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="幻☆精灵的Blog站点">
<meta property="og:type" content="website">
<meta property="og:title" content="幻☆精灵的Blog">
<meta property="og:url" content="http://hstarorg.github.io/blog/archives/2017/page/7/index.html">
<meta property="og:site_name" content="幻☆精灵的Blog">
<meta property="og:description" content="幻☆精灵的Blog站点">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="幻☆精灵的Blog">
<meta name="twitter:description" content="幻☆精灵的Blog站点">
    
  <link href="https://fonts.googleapis.com/css?family=Inconsolata|Titillium+Web" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css?family=Roboto+Mono" rel="stylesheet">
  <link href='//cdn.bootcss.com/node-waves/0.7.5/waves.min.css' rel='stylesheet'>
  <link rel="stylesheet" href="/blog/style.css">
  
  

  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>
</head>

<body>
  <div id="loading-bar-wrapper">
  <div id="loading-bar"></div>
</div>


  <script>setLoadingBarProgress(20)</script> 
  <header class="l_header">
		<div class="wrapper container">
			<a class="logo flat-box" href='/blog/' >
				幻☆精灵的Blog
			</a>
			<div class='menu'>
				<ul class='h-list'>
					
						<li>
							<a class='flat-box nav-home' href='/blog/'>
								首页
							</a>
						</li>
					
						<li>
							<a class='flat-box nav-archives' href='/blog/archives'>
								归档
							</a>
						</li>
					
						<li>
							<a class='flat-box nav-about' href='/blog/about'>
								关于我
							</a>
						</li>
					
				</ul>
				<div class='underline'></div>
			</div>
			
				<div class="m_search">
					<form name="searchform" class="form u-search-form">
						<input type="text" class="input u-search-input" placeholder="Search" />
						<span class="icon icon-search"></span>
					</form>
				</div>
			
			<ul class='switcher h-list'>
				
					<li class='s-search'><a href='javascript:void(0)'><span class="icon icon-search"></span></a></li>
				
				<li class='s-menu'><a href='javascript:void(0)'><span class="icon icon-menu"></span></a></li>
			</ul>
		</div>
		<aside class="menu-phone">
			<nav>
				
					<a href="/blog/" class="nav-home nav">
						首页
					</a>
				
					<a href="/blog/archives" class="nav-archives nav">
						归档
					</a>
				
					<a href="/blog/about" class="nav-about nav">
						关于我
					</a>
				
			</nav>
		</aside>
</header>

    <script>setLoadingBarProgress(40);</script>
  <div class="l_body">
    <div class='container'>
      <div class='l_main'>
        
	
	<section class="page-header archive banner waves-image">
    <h1>Year : <span>2017</span></h1>
  </section>

<section class="post-list">
	
    <div class='post-wrapper'>
      <article class="post reveal">
  <section class="meta">
    
    <h2 class="title">
      <a href="/blog/2017/02/21/Sass学习之路/02_Sass学习之路：注释、变量以及导入/">
        02_Sass学习之路：注释、变量以及导入
      </a>
    </h2>
    
    <time>
      Feb 21, 2017
    </time>
		
  </section>
  <section class="article typo">
	  <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于.sass不兼容CSS代码，所以以下内容完全使用.scss的语法。</p>
<h2 id="Sass注释"><a href="#Sass注释" class="headerlink" title="Sass注释"></a>Sass注释</h2><p>Sass中除了提供CSS中的标准注释之外，还提供了一种静默注释：</p>
<pre><code>/* 我是标准注释 */
// 我是静默注释
</code></pre><p>标准注释大多数情况下（<strong>一种例外：设置输出风格为compressed</strong>）是会生成到最终的CSS中的，而静默注释的话，只是Sass的注释，是不会被生成到CSS文件中的。</p>
<p>如果想，就算设置输出风格为compressed也要加入特定注释呢？那么可以采用<strong>重要注释</strong>写法，如下：</p>
<pre><code>/*! 我的重要注释 */
</code></pre><p>也就是在标准注释的基础上，将注释的第一个字符设置为感叹号。</p>
<h2 id="Sass变量"><a href="#Sass变量" class="headerlink" title="Sass变量"></a>Sass变量</h2><p>Sass作为一个CSS预处理器，那么最基本的编程语言特性<strong>变量</strong>自然也是必不可少的。Sass中变量系统相对比较丰富，包含局部变量，全局变量，默认变量，特殊变量（变量作用在属性上），多值变量。</p>
<p><strong>Sass变量以$开头，用:分割变量名与变量值，以;结尾。如： $color: red;</strong></p>
<p><strong>Sass变量，不区分中横线和下划线，比如定义变量为$bg-color，那么使用$bg_color也能访问到哦！</strong></p>
<h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>同大多数编程语言一样，变量的作用域是它本身的这个块，以及所有的子集。如:</p>
<pre><code>body{
  $color: blue;
  color: $color;
  .container{
    background-color: $color;    
  }
}
</code></pre><p>将被编译为：</p>
<pre><code>body {
  color: blue;
}

body .container {
  background-color: blue;
}
</code></pre><p>同时，需要注意：针对以上代码，如果内部修改了$color的值，也会同时影响到外部的变量值。</p>
<h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>如果定义在局部的变量，与它同级的选择器中是无法使用的：</p>
<pre><code>body{
  $color: blue;
  color: $color;
  .container{
    background-color: $color;    
  }
}

// 会出现错误，未定义的变量
footer{
  color: $color;
}
</code></pre><p>这个时候，就需要提升$color为全局变量，<strong>在变量值之后，加上!global</strong>,示例如下：</p>
<pre><code>body{
  $color: blue !global;
  color: $color;
  .container{
    background-color: $color;    
  }
}

// 会出现错误，未定义的变量
footer{
  color: $color;
}
</code></pre><p>这个的话，就能够正常编译了，因为$color被提升为全局变量了。</p>
<h3 id="默认变量"><a href="#默认变量" class="headerlink" title="默认变量"></a>默认变量</h3><p>在Sass中，可以通过在<strong>变量值之后加入!default</strong>来让变量称为默认变量，如果有对该变量的赋值，不管前后，那么变量的默认值都会被替换掉，示例如下：</p>
<pre><code>$color: red;
body{
  $color: blue !default;
  color: $color;
  .container{
    background-color: $color;    
  }
}
footer{
  color: $color;
}
</code></pre><p>可以通过注释掉!default来查看生成的CSS的异同。</p>
<h3 id="特殊变量"><a href="#特殊变量" class="headerlink" title="特殊变量"></a>特殊变量</h3><p>Sass的变量，还可以用在属性中，此时需要使用#{变量名}来引用，示例如下：</p>
<pre><code>$containerId: c1;

##{$containerId}{
  color: red;
}
</code></pre><p>此时，生成的CSS为：</p>
<pre><code>#c1 {
  color: red;
}
</code></pre><h3 id="多值变量"><a href="#多值变量" class="headerlink" title="多值变量"></a>多值变量</h3><p>强大的Sass，还提供了一种特殊的变量，即为多值变量，在一个变量中，可以定义多个值，然后通过制定的函数访问，示例如下：</p>
<pre><code>// List类型的多值变量 
$px: 5px 10px 15px 20px;

// Map类型的多值变量 
$map: (id1: test, id2: testGrid, color: red);

body{
  // 此处需要注意，索引是从1开始，不是从0哦。
  margin-left: nth($px, 1);

  // 使用map-get访问，当心key的使用，指定了不存在的key会导致生成的css异常 
  #{map-get($map, id2)}{
    color: red;
  }

  #id{
    color: map-get($map, color);
  }
}
</code></pre><p>生成的CSS如下：</p>
<pre><code>body {
  margin-left: 5px;
}

body testGrid {
  color: red;
}

body #id {
  color: red;
}
</code></pre><h2 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h2><p>体现可维护性的重要指标就是文件似乎可以单一职责，那么在Sass中，主要体现在导入上。由于Sass中的导入指令和CSS的导入指令是同样的关键字，那么就需要按照一定的规则来判别了，满足以下任意一条规则的导入，使用CSS的原生导入：</p>
<ol>
<li>被导入的文件名以.css结尾</li>
<li>被导入的文件是一个在线的url地址</li>
<li>以@import url(…)方式去导入文件</li>
</ol>
<p>同时，编写局部的sass文件，建议使用下划线开头,如： _a.scss，这样就不会生成多余的_a.css了。</p>
<pre><code>//_a.scss
#id2{
  color: red;
}

//1.scss
@import &quot;a.scss&quot;;
#id1{
  color: blue;
}

body{
    @import &quot;a.scss&quot;;
}
</code></pre><p>最终生成的结果为:</p>
<pre><code>#id2 {
  color: red;
}

#id1 {
  color: blue;
}

body #id2 {
  color: red;
}
</code></pre><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>欲知后事如何，请听下回分解！</p>


    
    
    
  </section>
</article>
    </div>
  
    <div class='post-wrapper'>
      <article class="post reveal">
  <section class="meta">
    
    <h2 class="title">
      <a href="/blog/2017/02/21/TypeScript札记/TypeScript札记：初体验/">
        TypeScript札记：初体验
      </a>
    </h2>
    
    <time>
      Feb 21, 2017
    </time>
		
  </section>
  <section class="article typo">
	  <h2 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h2><p>TypeScript 是一种由微软开发的自由和开源的编程语言。它是JavaScript的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程。</p>
<p>TypeScript是一种Compile-to-JavaScript的语言</p>
<p>TypeScript扩展了JavaScript的句法，所以现有的JavaScript程序可以不加修改，直接在TypeScript下工作。同时，TypeScript编译产生JavaScript以确保兼容性。</p>
<h2 id="2、特点-amp-优势"><a href="#2、特点-amp-优势" class="headerlink" title="2、特点&amp;优势"></a>2、特点&amp;优势</h2><p>2.1、兼容现有JS代码</p>
<p>2.2、类型系统，面向对象设计，保证程序的健壮性（编译检查）</p>
<p>2.3、良好的语法，良好的工具支持</p>
<p>2.4、良好的社区支持</p>
<h2 id="3、快速开始"><a href="#3、快速开始" class="headerlink" title="3、快速开始"></a>3、快速开始</h2><p>3.1、 <strong>工具</strong></p>
<p>如果是VS开发，安装 <a href="https://portal.qiniu.com/signup?code=3lo24xqrim8gi" target="_blank" rel="external">TypeScript 1.4 for Visual Studio 2013</a>，版本随时变化，建议下载最新版本。</p>
<p>如果是NPM用户，那么直接 <code>npm install -g typescript</code></p>
<p>3.2、 <strong>Hello Jay</strong></p>
<p>使用VS的用户，直接新建项（TypeScript File即可）；使用其他IDE的用户，如果IDE支持TypeScript，那么直接新建TypeScript；其他则新建文本文件，后缀名为ts。如果是不能在IDE中编译，那么可以直接通过npm安装typescript之后，使用tsc fileName.ts，进行编译。</p>
<p>打开1.ts文件，输入：</p>
<pre><code>function hello(name: string){
  return &apos;Hello,&apos; + name;
}

var res = hello(&apos;Jay&apos;);
console.log(res);
</code></pre><p>执行<code>tsc 1.ts</code>之后，生成一个1.js文件（具有可读性的标准js文件）：</p>
<pre><code>function hello(name) {
    return &apos;Hello,&apos; + name;
}
var res = hello(&apos;Jay&apos;);
console.log(res);
</code></pre><h2 id="4、参考资料"><a href="#4、参考资料" class="headerlink" title="4、参考资料"></a>4、参考资料</h2><p>1、 <a href="http://www.typescriptlang.org/" target="_blank" rel="external">官网：http://www.typescriptlang.org/</a></p>
<p>2、 <a href="https://github.com/vilic/typescript-guide" target="_blank" rel="external">入门指南： https://github.com/vilic/typescript-guide</a></p>


    
    
    
  </section>
</article>
    </div>
  
    <div class='post-wrapper'>
      <article class="post reveal">
  <section class="meta">
    
    <h2 class="title">
      <a href="/blog/2017/02/21/Vue实践之路/02_Vue组件（上）/">
        02_Vue组件（上）
      </a>
    </h2>
    
    <time>
      Feb 21, 2017
    </time>
		
  </section>
  <section class="article typo">
	  <h1 id="0、关于Vue组件"><a href="#0、关于Vue组件" class="headerlink" title="0、关于Vue组件"></a>0、关于Vue组件</h1><p>组件是 <code>Vue</code> 中最强大的功能之一，Vue组件也和angular的组件比较类似，可以扩展HTML元素。在较高层面上，也是自定义元素。</p>
<p>在原生HTML元素上附加功能，<code>Vue</code> 的做法是通过 <code>is</code> 特性扩展， <code>ng2</code> 中则称之为属性指令。</p>
<h1 id="1、定义组件"><a href="#1、定义组件" class="headerlink" title="1、定义组件"></a>1、定义组件</h1><p>在 <code>Vue</code> 中定义组件是一个很轻松的方式，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 定义组件构造器</span></div><div class="line"><span class="keyword">var</span> Component1 = Vue.extend(&#123;</div><div class="line"></div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 全局注册组件</span></div><div class="line">Vue.component(<span class="string">'component-1'</span>, Component1);</div><div class="line"></div><div class="line"><span class="comment">// 也可局部注册组件</span></div><div class="line"><span class="comment">// 局部注册意味着该组件仅能在包含它的组件中运行，如示例的Parent组件</span></div><div class="line"><span class="keyword">var</span> Parent = Vue.extend(&#123;</div><div class="line">  <span class="attr">template</span>: <span class="string">''</span>,</div><div class="line">  <span class="attr">components</span>: &#123;</div><div class="line">    <span class="string">'component-1'</span>: Component1</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>为了足够简单，<code>Vue</code> 还提供了一个语法糖写法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 直接注册组件（不在需要组件构造器）</span></div><div class="line">Vue.component(<span class="string">'component1'</span>, &#123;</div><div class="line"></div><div class="line">&#125;);</div><div class="line"><span class="comment">// 局部注册同理</span></div><div class="line"><span class="keyword">var</span> Parent = Vue.extend(&#123;</div><div class="line">  <span class="attr">template</span>: <span class="string">''</span>,</div><div class="line">  <span class="attr">components</span>: &#123;</div><div class="line">    <span class="string">'component-1'</span>: &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>该语法实际上是 <code>Vue</code> 在背后自动调用 <code>Vue.extend()</code>。</p>
<p>除此之外，如果使用 <code>.vue</code> 格式的组件，我们定义组件的方式如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">  <span class="comment">// 定义一个组件</span></div><div class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line"></div><div class="line">  &#125;;</div><div class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure>
<h2 id="组件选项"><a href="#组件选项" class="headerlink" title="组件选项"></a>组件选项</h2><p>所谓组件选项，就是在定义组件时，传递给 <code>Vue.extend()</code> 的参数。</p>
<p>定义组件是相当简单的事情，我们更多的需要去关注组件选项！</p>
<p>先来一个完整的组件选项压压惊：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Component1 = Vue.extend(&#123;</div><div class="line">  <span class="attr">data</span>: &#123;&#125; or fn <span class="comment">// 数据对象</span></div><div class="line">  props: [] or &#123;&#125; <span class="comment">// 组件可配置的属性</span></div><div class="line">  propsData: &#123;&#125; <span class="comment">// 在创建实例时，给属性赋值（用于测试）</span></div><div class="line">  computed: &#123;&#125; <span class="comment">// 实例计算属性</span></div><div class="line">  methods: &#123;&#125; <span class="comment">// 实例方法</span></div><div class="line">  watch: &#123;&#125; <span class="comment">// 监控属性</span></div><div class="line"></div><div class="line">  el: string or HtmlElement or fn <span class="comment">//挂载元素，将组件实例挂载到那儿</span></div><div class="line">  template: string <span class="comment">// 组件模板</span></div><div class="line">  replace: boolean <span class="comment">// 是否替换挂载元素，和template一起使用，默认true</span></div><div class="line"></div><div class="line">  init: fn <span class="comment">// 生命周期钩子，初始化时调用，此时数据观察、事件和watcher都没初始化</span></div><div class="line">  created: fn <span class="comment">// 组件参数已经解析完毕，但还未开始DOM编译</span></div><div class="line">  beforeCompile: fn <span class="comment">//开始编译DOM</span></div><div class="line">  compiled: fn <span class="comment">// DOM编译完成，数据辩护已经可以触发DOM更新了，但不保证$el已经插入文档</span></div><div class="line">  ready: fn <span class="comment">// 编译结束和 $el 第一次插入文档之后调用</span></div><div class="line">  attached: fn <span class="comment">// 在$el插入DOM时调用 </span></div><div class="line">  detached: fn <span class="comment">// 在$el从DOM元素中删除时调用</span></div><div class="line">  beforeDestroy: fn <span class="comment">// 在开始销毁实例时调用</span></div><div class="line">  destroyed: fn <span class="comment">// 实例销毁后调用，如果有离开过渡，将会在过渡完成之后调用</span></div><div class="line"></div><div class="line">  directives: &#123;&#125; <span class="comment">// 组件局部注册的指令</span></div><div class="line">  elementDirectives: &#123;&#125; <span class="comment">// 组件局部注册的元素指令</span></div><div class="line">  filters: &#123;&#125; <span class="comment">// 组件局部注册的过滤器</span></div><div class="line">  components: &#123;&#125; <span class="comment">// 组件局部注册的子组件</span></div><div class="line">  transitions: &#123;&#125; <span class="comment">// 组件局部注册的动画</span></div><div class="line">  partials: &#123;&#125; <span class="comment">// 组件局部注册的分部元素</span></div><div class="line"></div><div class="line">  parent: Vue实例 <span class="comment">// 指定实例的父实例</span></div><div class="line">  events: &#123;&#125; <span class="comment">// 事件监听列表对象</span></div><div class="line">  mixins: [] <span class="comment">// 组件的混合器</span></div><div class="line">  name: string <span class="comment">//组件的名称，允许在自己的模板中调用自己（递归组件非常有效）</span></div><div class="line">  extends: &#123;&#125; or fn <span class="comment">// 声明式的扩展组件</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>虽然全量的属性比较多，但实际上常用的并不很太多，下面我列一下我比较常用的属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Component1 = Vue.extend(&#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">'component-1'</span>,</div><div class="line">  <span class="attr">data</span>: &#123;</div><div class="line">    <span class="attr">firstName</span>: <span class="string">'Hu'</span>,</div><div class="line">    <span class="attr">lastName</span>: <span class="string">'Jay'</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">props</span>: [<span class="string">'height'</span>, <span class="string">'width'</span>],</div><div class="line">  <span class="attr">template</span>: <span class="string">'&lt;h1&gt;&#123;&#123;fullName&#125;&#125;&lt;/h1&gt;'</span>,</div><div class="line">  <span class="attr">replace</span>: <span class="literal">true</span>,</div><div class="line">  </div><div class="line">  <span class="attr">filters</span>: &#123;&#125;,</div><div class="line">  <span class="attr">components</span>: &#123;&#125;,</div><div class="line">  <span class="attr">transitions</span>: &#123;&#125;,</div><div class="line"></div><div class="line">  <span class="attr">methods</span>: &#123;</div><div class="line">    <span class="attr">doSomething</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      alert(<span class="keyword">this</span>.fullName);</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">events</span>: &#123;</div><div class="line">    <span class="string">'do'</span>: <span class="string">'doSomething'</span>, <span class="comment">//方法名字</span></div><div class="line">    <span class="string">'do1'</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      <span class="comment">//当捕获 do1 事件时执行</span></div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">watch</span>:&#123;&#125;,</div><div class="line">  <span class="attr">computed</span>: &#123;</div><div class="line">    <span class="attr">fullName</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="keyword">this</span>.lastName;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  created: funciton()&#123;</div><div class="line">    <span class="comment">// 初始化操作</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">ready</span>: funciton()&#123;</div><div class="line">    <span class="comment">// 如果有DOM操作，那么放在这里</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">beforeDestroy</span>: funciton()&#123;</div><div class="line">    <span class="comment">// 如果某些东西需要手动释放，那么放在这里</span></div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>如果是在 <code>.vue</code> 格式中，我们的用法稍微有点变化，主要是使用ES6的新特性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">&lt;style&gt;</div><div class="line">  <span class="xml"><span class="comment">&lt;!-- 放置样式 --&gt;</span></span></div><div class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line">&lt;template&gt;</div><div class="line">  <span class="xml"><span class="comment">&lt;!-- 此处放置模板，建议都用一个根元素包裹起来 --&gt;</span></span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"app-component-1"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>我是模板内容<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></div><div class="line">&lt;script&gt;</div><div class="line">  <span class="comment">//放置组件代码</span></div><div class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">    <span class="attr">props</span>: [],</div><div class="line">    data() &#123; </div><div class="line">      <span class="keyword">return</span> &#123;&#125;;</div><div class="line">    &#125;,</div><div class="line">    created() &#123;</div><div class="line"></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">methods</span>: &#123;</div><div class="line">      fun1() &#123;</div><div class="line"></div><div class="line">      &#125;,</div><div class="line">      fun2() &#123;</div><div class="line"></div><div class="line">      &#125;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">events</span>: &#123;</div><div class="line">      <span class="string">'do'</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"></div><div class="line">      &#125;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">watch</span>: &#123;</div><div class="line">      firstName(newVal, oldVal)&#123;</div><div class="line"></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure>
<p><strong>注意：为什么data在.vue中data是一个方法呢？因为.vue下是使用的ES6的特性，如果是属性的话，就是原型属性，当多个组件时，就会共享同一份原型，导致数据错乱，所以通过function返回一个对象，保证每个组件实例隔离。</strong></p>


    
    
    
  </section>
</article>
    </div>
  
    <div class='post-wrapper'>
      <article class="post reveal">
  <section class="meta">
    
    <h2 class="title">
      <a href="/blog/2017/02/21/jQuery拆解/02-模块化加载&防冲突处理/">
        02-模块化加载&amp;防冲突处理
      </a>
    </h2>
    
    <time>
      Feb 21, 2017
    </time>
		
  </section>
  <section class="article typo">
	  <h2 id="0、模块化加载"><a href="#0、模块化加载" class="headerlink" title="0、模块化加载"></a>0、模块化加载</h2><p><code>jQuery</code> 在之前的版本（具体不记得是哪个版本以前了）中，是不支持模块化加载的。</p>
<p>当前，模块化作为一个趋势，<code>jQuery</code> 也增加了对模块化的支持，当今最流行的的模块规范是 <code>UMD</code>，简单点说就是判断各种环境，然后选择合适的方式加载。</p>
<p>来看下具体的实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//首先是一个IIFE，避免污染全局变量</span></div><div class="line">( <span class="function"><span class="keyword">function</span>(<span class="params"> global, factory </span>) </span>&#123;</div><div class="line"><span class="meta">  "use strict"</span>;</div><div class="line">  <span class="comment">// 判断是否是模块化加载</span></div><div class="line">  <span class="comment">// 如果是CMD加载器，那么会有 module 和 module.exports 属性</span></div><div class="line">  <span class="keyword">if</span> ( <span class="keyword">typeof</span> <span class="built_in">module</span> === <span class="string">"object"</span> &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">module</span>.exports === <span class="string">"object"</span> ) &#123;</div><div class="line">    <span class="comment">// 如果有document，那就算是浏览器环境，那么直接导出jQuery</span></div><div class="line">    <span class="built_in">module</span>.exports = global.document ?</div><div class="line">    <span class="comment">// 注意， factory第二个参数是true，也就是说不会挂载到全局变量上（模块化加载不需要挂载到window上）</span></div><div class="line">      factory( global, <span class="literal">true</span> ) :</div><div class="line">      <span class="comment">// 虽然看起来是模块化加载，但是没有找到window对象，这个时候就导出一个factory,需要手动传入window对象。</span></div><div class="line">      <span class="function"><span class="keyword">function</span>(<span class="params"> w </span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> ( !w.document ) &#123;</div><div class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>( <span class="string">"jQuery requires a window with a document"</span> );</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> factory( w );</div><div class="line">      &#125;;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// 如果不是加载器加载，那么就直接把window或者this传递给 jQuery factory</span></div><div class="line">    factory( global );</div><div class="line">  &#125;</div><div class="line"></div><div class="line"><span class="comment">// Pass this if window is not defined yet</span></div><div class="line">&#125; )( <span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">"undefined"</span> ? <span class="built_in">window</span> : <span class="keyword">this</span>, <span class="function"><span class="keyword">function</span>(<span class="params"> window, noGlobal </span>) </span>&#123;</div><div class="line">  <span class="comment">// jQuery本身的逻辑代码</span></div><div class="line"></div><div class="line">  <span class="comment">// 注意，jQuery也支持了AMD方式加载。</span></div><div class="line">  <span class="keyword">if</span> ( <span class="keyword">typeof</span> define === <span class="string">"function"</span> &amp;&amp; define.amd ) &#123;</div><div class="line">    define( <span class="string">"jquery"</span>, [], <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> jQuery;</div><div class="line">    &#125; );</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>通过以上代码实现，<code>jQuery</code> 就实现了模块化加载。</p>
<h2 id="1、防冲突处理"><a href="#1、防冲突处理" class="headerlink" title="1、防冲突处理"></a>1、防冲突处理</h2><p>当一个库可能会挂载属性到全局变量的时候，那么就要考虑全局变量覆盖这个问题。</p>
<p>比如说 <code>jQuery</code> 会挂载到 <code>window.jQuery</code> 和 <code>window.$</code> 上，那万一这两个属性已经被其他库使用了，那我们引入 <code>jQuery</code> 不就把别人的库覆盖了么。</p>
<p>作为一个完备的库，<code>jQuery</code> 也处理了这种场景。那就是防冲突方法。</p>
<p>看一下具体的实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 在实现防冲突时，要注意代码的顺序</span></div><div class="line"></div><div class="line"><span class="comment">// 首先先用局部变量，把要挂载的属性备份一次。</span></div><div class="line"><span class="keyword">var</span></div><div class="line"><span class="comment">// Map over jQuery in case of overwrite</span></div><div class="line">  _jQuery = <span class="built_in">window</span>.jQuery,</div><div class="line"></div><div class="line">  <span class="comment">// Map over the $ in case of overwrite</span></div><div class="line">  _$ = <span class="built_in">window</span>.$;</div><div class="line"></div><div class="line"><span class="comment">// 实现一个冲突方法，当调用该方法时，就会把之前保存的全局变量进行还原。</span></div><div class="line"><span class="comment">// deep的意思就是是否要还原jQuery这个属性，因为jQuery并不是一个常用的属性，所以一般不会被其他库占用。</span></div><div class="line">jQuery.noConflict = <span class="function"><span class="keyword">function</span>(<span class="params">deep</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (<span class="built_in">window</span>.$ === jQuery) &#123;</div><div class="line">    <span class="built_in">window</span>.$ = _$;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (deep &amp;&amp; <span class="built_in">window</span>.jQuery === jQuery) &#123;</div><div class="line">    <span class="built_in">window</span>.jQuery = _jQuery;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 冲突之后，总要挂载吧，通过return jQuery，就能返回jQuery，这个时候可以任意挂载到你想要的属性。</span></div><div class="line">	<span class="comment">// 实例代码： window.abcde = jQuery.noConflict();</span></div><div class="line">  <span class="keyword">return</span> jQuery;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// Expose jQuery and $ identifiers, even in AMD</span></div><div class="line"><span class="comment">// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)</span></div><div class="line"><span class="comment">// and CommonJS for browser emulators (#13566)</span></div><div class="line"><span class="comment">// 如果不是非全局（如果是双重否定，实际就是如果是全局）</span></div><div class="line"><span class="keyword">if</span> (!noGlobal) &#123;</div><div class="line">	<span class="comment">// 那么就设置到全局变量，这个时候已经把全局属性覆盖了。</span></div><div class="line">  <span class="built_in">window</span>.jQuery = <span class="built_in">window</span>.$ = jQuery;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">return</span> jQuery;</div></pre></td></tr></table></figure>

    
    
    
  </section>
</article>
    </div>
  
    <div class='post-wrapper'>
      <article class="post reveal">
  <section class="meta">
    
    <h2 class="title">
      <a href="/blog/2017/02/21/Sass学习之路/01_Sass学习之路：Sass、Compass安装与命令行/">
        01_Sass学习之路：Sass、Compass安装与命令行
      </a>
    </h2>
    
    <time>
      Feb 21, 2017
    </time>
		
  </section>
  <section class="article typo">
	  <h2 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h2><p>CSS不是一门真正意义上的编程语言，很多编程语言理所当然的特性（比如变量），都不被支持。同时再开发模块化的web项目的时候，也要避免相互干扰。为了弥补CSS的这些不足，就产生了<strong><a href="">CSS预处理器</a></strong>，Sass则是其中的佼佼者。</p>
<h2 id="什么是Sass"><a href="#什么是Sass" class="headerlink" title="什么是Sass"></a>什么是Sass</h2><p><strong><a href="http://sass-lang.com/" target="_blank" rel="external">Sass</a></strong>是最成熟、稳定、强大、专业的CSS扩展语言（官方解释）。直白点，Sass就是一个非常好用的CSS预处理器，为css引入部分编程语言的特性。</p>
<p>Sass在现阶段，有两种编码的语法，一个是兼容CSS语法的Scss格式文件，一个是Haml、Ruby类似语法的Sass格式文件。一般情况下，我们选用第一种兼容Css语法的Scss文件格式</p>
<h2 id="什么是Compass"><a href="#什么是Compass" class="headerlink" title="什么是Compass"></a>什么是Compass</h2><p><strong><a href="http://compass-style.org/" target="_blank" rel="external">Compass</a></strong>是基于Sass的一个css创作框架，其实就是基于Sass提供了很多非常实用的函数，有点类库的概念。</p>
<h2 id="如何安装"><a href="#如何安装" class="headerlink" title="如何安装"></a>如何安装</h2><p>Sass是基于Ruby写的，安装Sass需要先安装Ruby：<a href="https://www.ruby-lang.org/zh_cn/downloads/" target="_blank" rel="external">https://www.ruby-lang.org/zh_cn/downloads/</a>。</p>
<p>在Windows上安装Ruby，需要借助RubyInstall工具：<a href="http://rubyinstaller.org/" target="_blank" rel="external">http://rubyinstaller.org/</a></p>
<p>安装好Ruby只有，可以使用cmd：ruby -v 查看ruby的版本，如果有输出，表示ruby安装成功。这个时候，则可以使用<code>ruby gem sass</code>来安装Sass，<code>ruby gem compass</code>来安装Compass。</p>
<p><strong>*注意事项</strong>：由于gem仓库被墙了，如果想使用的话，需要切换镜像地址，国内可以采用淘宝的ruby镜像：<code>http://ruby.taobao.org</code>。可以通过如下命令实现：*</p>
<pre><code>//移除官方gems
gem sources --remove https://rubygems.org/
//添加淘宝的gems   
gem sources -a https://ruby.taobao.org/
//查看现有的gems
gem sources -l
</code></pre><h2 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h2><pre><code>//编译Sass
sass &lt;sass file&gt; &lt;css file&gt;

//Sass与Scss相互转换
sass-convert &lt;.sass file&gt; &lt;.scss file&gt;
sass-convert &lt;.scss file&gt; &lt;.sass file&gt;

//监视Sass文件变更，自动编译(可选输出css的风格，参数为style)
sass --watch &lt;sass file&gt;:&lt;css file&gt; [--style [nested|expanded|compact|compressed]]

//监视文件夹中Sass文件变更，自动编译
sass --watch &lt;sass folder&gt;:&lt;ouput css folder&gt;

//----------------------Compass--------------

//创建Sass工程
compass create

//编译sass文件
compass compile

//监视Sass工程下sass文件变更(可选输出css的风格，参数为output-style)
compass --watch [--output-style [nested|expaned|compact|compressed]]
</code></pre><h2 id="更简单的使用方式"><a href="#更简单的使用方式" class="headerlink" title="更简单的使用方式"></a>更简单的使用方式</h2><p>看了以上这么多的步骤，是不是感觉头疼？</p>
<p><strong>老夫看你天资聪慧，将来必成大器，特为你带来一本秘籍，祝你早日功成！</strong></p>
<p>在真正的开发环境中，我们一般这么用，结果node+gulp等构建工具。</p>
<p>首先，需要安装node,然后使用npm安装gulp和gulp-sass。</p>
<p>接着，编写一个基于gulp的构建脚本，如果是其他构建工具，那么编写对应的脚本即可，gulpfile.js代码如下：</p>
<pre><code>var gulp = require(&apos;gulp&apos;),
  sass = require(&apos;gulp-sass&apos;);

gulp.task(&apos;default&apos;, [&apos;sass&apos;, &apos;watch&apos;], function () {
  console.log(&apos;Begin watching...&apos;);
});

gulp.task(&apos;sass&apos;, function () {
  return gulp.src(&apos;./*.scss&apos;)
    .pipe(sass({
      outputStyle: &apos;expanded&apos;
    }).on(&apos;error&apos;, sass.logError))
    .pipe(gulp.dest(&apos;./css/&apos;));
});

gulp.task(&apos;watch&apos;, function () {
  return gulp.watch(&apos;./*.scss&apos;, [&apos;sass&apos;]);
});
</code></pre><p>最后，使用控制台，启动gulp，然后畅快的编写sass代码吧。</p>


    
    
    
  </section>
</article>
    </div>
  
    <div class='post-wrapper'>
      <article class="post reveal">
  <section class="meta">
    
    <h2 class="title">
      <a href="/blog/2017/02/21/从0开始Stylus/01_Stylus简介&基本使用/">
        01_Stylus简介&amp;基本使用
      </a>
    </h2>
    
    <time>
      Feb 21, 2017
    </time>
		
  </section>
  <section class="article typo">
	  <h2 id="0、导言"><a href="#0、导言" class="headerlink" title="0、导言"></a>0、导言</h2><p><strong>关于Stylus</strong></p>
<p>Stylus是一个CSS预处理器，也就是利用编程的方式编写css代码，然后stylus会自动帮我们编译为标准的css，并能附加更多的功能。</p>
<p>Stylus开始于2010年，来自于Node.js社区。</p>
<p>Stylus的文件后缀是<code>.styl</code></p>
<p><strong>常用预处理器之间的简单比较</strong></p>
<p>常用的CSS预处理还有Sass和LESS。Sass提供了非常多的特性，也非常成熟。Less使用起来更为简单。<br>Stylus在功能上更为健壮，和JS的联系更加紧密。</p>
<p><strong>此文产生的缘由</strong></p>
<ol>
<li>由于亲近Node.js，所以想系统的学习下和js更紧密的Stylus预处理器</li>
<li>最近在实现nk-style的时候，采用了Stylus来编写CSS，用文章的方式来加深理解</li>
</ol>
<h2 id="1、配套工具"><a href="#1、配套工具" class="headerlink" title="1、配套工具"></a>1、配套工具</h2><p><strong>如何安装Stylus</strong></p>
<p>既然是Node.js社区的产出，那么很明显，安装方式也带有浓浓的Node风格。使用<code>npm install stylus -g</code>就可以在系统中安装Stylus了，当然，前提是你得先安装node和npm。</p>
<p><strong>如何使用</strong></p>
<p>安装好Stylus之后，我们就可以在控制台输入特定命令，来转换Stylus文件。</p>
<p><code>stylus css</code> –编译css目录的.styl文件，并输出同名的.css文件</p>
<p><code>stylus index.styl abc.styl</code> –编译index.styl、abc.styl文件</p>
<p>更多命令请参考 <a href="http://stylus-lang.com/docs/executable.html" target="_blank" rel="external">http://stylus-lang.com/docs/executable.html</a></p>
<p><strong>更常规的用法</strong></p>
<p>一般使用stylus的话，是会结合构建工具来一起使用的。比如结合gulp来使用的方式如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> stylus = <span class="built_in">require</span>(<span class="string">'gulp-stylus'</span>);</div><div class="line"></div><div class="line">gulp.task(<span class="string">'css'</span>, _ =&gt;</div><div class="line">  gulp.src(<span class="string">'./src/index.styl'</span>)</div><div class="line">    .pipe(stylus())</div><div class="line">    .pipe(gulp.dest(<span class="string">'./dist/'</span>))</div><div class="line">);</div></pre></td></tr></table></figure>
<h2 id="2、Stylus语法"><a href="#2、Stylus语法" class="headerlink" title="2、Stylus语法"></a>2、Stylus语法</h2><p>Stylus在语法支持上是比较强大的。既支持标准CSS，也支持缩进格式，最厉害的还能在同一个styl文件中混用。</p>
<figure class="highlight styl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">body&#123;</div><div class="line">  <span class="attribute">background</span>: white;</div><div class="line">&#125;</div><div class="line"></div><div class="line">body&#123;</div><div class="line">  <span class="attribute">background</span> blue</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">body</span></div><div class="line">  <span class="attribute">background</span> green</div></pre></td></tr></table></figure>
<p>编译生成的CSS如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">body &#123;</div><div class="line">  background: #fff;</div><div class="line">&#125;</div><div class="line">body &#123;</div><div class="line">  background: #00f;</div><div class="line">&#125;</div><div class="line">body &#123;</div><div class="line">  background: #008000;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-1、注释"><a href="#2-1、注释" class="headerlink" title="2.1、注释"></a>2.1、注释</h3><p>在学习一门编程语言（或者类编程语言时），我都胡优先去了解它的注释用法。因为刚学，意味着陌生，意味着需要些一些备注，那么这个时候注释就是个好东西。</p>
<p>在Stylus中，注释有三种方式：</p>
<ol>
<li>单行注释 –仅在styl文件中可见</li>
<li>多行注释 –常规模式下，输出到css文件中</li>
<li>重点注释 –在compress模式下，也会输出到css文件中</li>
</ol>
<p>test.styl文件内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// 单行注释</div><div class="line">body&#123;</div><div class="line">  background: white;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* 多行注释 */</div><div class="line">body&#123;</div><div class="line">  background blue</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*! 多行注释 */</div><div class="line">body</div><div class="line">  background green</div></pre></td></tr></table></figure>
<p>常规模式下输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">body &#123;</div><div class="line">  background: #fff;</div><div class="line">&#125;</div><div class="line">/* 多行注释 */</div><div class="line">body &#123;</div><div class="line">  background: #00f;</div><div class="line">&#125;</div><div class="line">/* 多行注释 */</div><div class="line">body &#123;</div><div class="line">  background: #008000;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>压缩模式下输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">body&#123;background:#fff&#125;body&#123;background:#00f&#125;/* 多行注释 */</div><div class="line">body&#123;background:#008000&#125;</div></pre></td></tr></table></figure>
<h3 id="2-2、变量"><a href="#2-2、变量" class="headerlink" title="2.2、变量"></a>2.2、变量</h3><p>变量在任何一个编程语言中，都是必不可少的。Stylus中也不例外。</p>
<p>Stylus的变量比较灵活，支持较多的变量名命名方式，如$abc、abc、_abc、-abc等等，但是从易读性上来说，<br>建议大家使用abc或者是$abc（推荐）其一来作为变量名规则。</p>
<p>test.styl内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">/*! 变量 */</div><div class="line">/* 常规的表达式做变量名，用等号连接变量值 */</div><div class="line">//在Stylus中，可以使用$，_等前缀，但建议使用特定字符开头，来标识变量</div><div class="line">font-size = 14px;</div><div class="line">$font-size = 20px </div><div class="line"></div><div class="line">// 单行注释</div><div class="line">body&#123;</div><div class="line">  background: white;</div><div class="line">  font-size font-size</div><div class="line">  font-size: $font-size</div><div class="line">  </div><div class="line">  width w = 100px</div><div class="line">  height h = 100px</div><div class="line">  //注意，此处表达式的括号不能少</div><div class="line">  margin-left -(w/2)</div><div class="line">  margin-top -(h/2)</div><div class="line">  //使用@符号引用同级的属性</div><div class="line">  margin-left -(@width/2)</div><div class="line">  margin-top -(@height/2)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>生成的CSS内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">/* 变量 */</div><div class="line">/* 常规的表达式做变量名，用等号连接变量值 */</div><div class="line">body &#123;</div><div class="line">  background: #fff;</div><div class="line">  font-size: 14px;</div><div class="line">  font-size: 20px;</div><div class="line">  width: 100px;</div><div class="line">  height: 100px;</div><div class="line">  margin-left: -50px;</div><div class="line">  margin-top: -50px;</div><div class="line">  margin-left: -50px;</div><div class="line">  margin-top: -50px;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>更多变量使用，请查阅<a href="http://stylus-lang.com/docs/variables.html" target="_blank" rel="external">http://stylus-lang.com/docs/variables.html</a></p>
<h3 id="2-3、选择器"><a href="#2-3、选择器" class="headerlink" title="2.3、选择器"></a>2.3、选择器</h3><p>在编写CSS的过程中，我们用得最多的无非就是选择器了。我们来看看Stylus对选择器做了哪些扩展。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">/*! 选择器 */</div><div class="line">/* 1、选择器嵌套 */</div><div class="line">body</div><div class="line">  background white</div><div class="line">  .container</div><div class="line">    background blue</div><div class="line">/* 2、引用直接父级别节点 */</div><div class="line">li</div><div class="line">  &amp;:hover</div><div class="line">    color blue</div><div class="line">/* 3、引用指定级别上层节点,个人觉得稍显复杂，不易懂，尽量少使用 */</div><div class="line">body</div><div class="line">  color white</div><div class="line">  li</div><div class="line">    a</div><div class="line">      color green</div><div class="line">    ^[1]:hover</div><div class="line">        color yellow</div><div class="line">/* 4、根节点引用，使用/将当前样式提升到第一层级 */</div><div class="line">body</div><div class="line">  li</div><div class="line">    / .test</div><div class="line">      color white</div><div class="line">/* 5、使用../来回到上一层级 */</div><div class="line">body</div><div class="line">  li</div><div class="line">    ../ .test</div><div class="line">      color yellow</div><div class="line">/* 6、使用selector()来构造选择器 */</div><div class="line">&#123;selector(&apos;.a&apos;, &apos;.b, .c&apos;)&#125;</div><div class="line">  color white</div><div class="line">/* 7、选择器为变量，那么用&#123;&#125;包裹，属性也是 */</div><div class="line">$selector = &quot;.text-danger&quot;</div><div class="line">$font = font-family</div><div class="line"></div><div class="line">&#123;$selector&#125;</div><div class="line">  &#123;$font&#125; &quot;微软雅黑&quot;</div><div class="line"></div><div class="line">/* 8、使用表达式 */</div><div class="line">exp_margin_pad(n)</div><div class="line">  margin (- n)px</div><div class="line">  </div><div class="line">body</div><div class="line">  exp_margin_pad(10)</div></pre></td></tr></table></figure>
<p>编译为CSS如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">/* 选择器 */</div><div class="line">/* 1、选择器嵌套 */</div><div class="line">body &#123;</div><div class="line">  background: #fff;</div><div class="line">&#125;</div><div class="line">body .container &#123;</div><div class="line">  background: #00f;</div><div class="line">&#125;</div><div class="line">/* 2、引用直接父级别节点 */</div><div class="line">li:hover &#123;</div><div class="line">  color: #00f;</div><div class="line">&#125;</div><div class="line">/* 3、引用指定级别上层节点,个人觉得稍显复杂，不易懂，尽量少使用 */</div><div class="line">body &#123;</div><div class="line">  color: #fff;</div><div class="line">&#125;</div><div class="line">body li a &#123;</div><div class="line">  color: #008000;</div><div class="line">&#125;</div><div class="line">body li:hover &#123;</div><div class="line">  color: #ff0;</div><div class="line">&#125;</div><div class="line">/* 4、根节点引用，使用/将当前样式提升到第一层级 */</div><div class="line">.test &#123;</div><div class="line">  color: #fff;</div><div class="line">&#125;</div><div class="line">/* 5、使用../来回到上一层级 */</div><div class="line">body .test &#123;</div><div class="line">  color: #ff0;</div><div class="line">&#125;</div><div class="line">/* 6、使用selector()来构造选择器 */</div><div class="line">.a .b,</div><div class="line">.a .c &#123;</div><div class="line">  color: #fff;</div><div class="line">&#125;</div><div class="line">/* 7、选择器为变量，那么用&#123;&#125;包裹，属性也是 */</div><div class="line">.text-danger &#123;</div><div class="line">  font-family: &quot;微软雅黑&quot;;</div><div class="line">&#125;</div><div class="line">/* 8、使用表达式 */</div><div class="line">body &#123;</div><div class="line">  margin: -10px;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>花样太多，就不一一例举了。不过，常用的没几个。个人最常用的仅仅是嵌套。</p>
<p>想了解更多，请参考： <a href="http://stylus-lang.com/docs/selectors.html" target="_blank" rel="external">http://stylus-lang.com/docs/selectors.html</a></p>
<h3 id="2-5、样式块"><a href="#2-5、样式块" class="headerlink" title="2.5、样式块"></a>2.5、样式块</h3><p>Stylus的变量没有集合的概念，那么如果有一组样式要复用的时候，变量就有点捉襟见肘了。这个时候，我们可以采用block来实现一组样式的复用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">/*! 样式块，两种定义方式，推荐第二种，为了易读性 */</div><div class="line">font = </div><div class="line">  font-family &quot;微软雅黑&quot;</div><div class="line">  font-size 1rem</div><div class="line"></div><div class="line">font1 = @block&#123;</div><div class="line">  font-family &quot;宋体&quot;</div><div class="line">  font-size 14px;</div><div class="line">&#125;</div><div class="line">  </div><div class="line">body</div><div class="line">  &#123;font&#125;</div><div class="line">  &#123;font1&#125;</div></pre></td></tr></table></figure>
<p>编译结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/* 样式块，两种定义方式，推荐第二种，为了易读性 */</div><div class="line">body &#123;</div><div class="line">  font-family: &quot;微软雅黑&quot;;</div><div class="line">  font-size: 1rem;</div><div class="line">  font-family: &quot;宋体&quot;;</div><div class="line">  font-size: 14px;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-6-样式继承"><a href="#2-6-样式继承" class="headerlink" title="2.6 样式继承"></a>2.6 样式继承</h3><p>在编写CSS的过程中，我们往往会发现新加的样式和之前已有的样式类有重复的部分，如果是原生CSS，那么我们又得拷贝一份样式出来。在Stylus中，大可不必如此麻烦。使用@extend很方便的就能解决这个问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">/*! 样式继承 */</div><div class="line"></div><div class="line">.btn</div><div class="line">  border 1px solid red;</div><div class="line">  border-radius 5px</div><div class="line"></div><div class="line">.btn-danger</div><div class="line">  @extend .btn //继承.btn的样式</div><div class="line">  color red</div><div class="line"></div><div class="line">//如果不嫌输出.btn，我们只需要将btn做成占位选择器，如下</div><div class="line">$btn</div><div class="line">  border 1px solid red;</div><div class="line">  border-radius 5px</div><div class="line">  </div><div class="line">.btn-info</div><div class="line">  @extend $btn</div><div class="line">  color purple</div></pre></td></tr></table></figure>
<p>编译后为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/* 样式继承 */</div><div class="line">.btn,</div><div class="line">.btn-danger &#123;</div><div class="line">  border: 1px solid #f00;</div><div class="line">  border-radius: 5px;</div><div class="line">&#125;</div><div class="line">.btn-danger &#123;</div><div class="line">  color: #f00;</div><div class="line">&#125;</div><div class="line">.btn-info &#123;</div><div class="line">  border: 1px solid #f00;</div><div class="line">  border-radius: 5px;</div><div class="line">&#125;</div><div class="line">.btn-info &#123;</div><div class="line">  color: #800080;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>注意1：@extend和@extends完全相等，两者可以混用</strong></p>
<p><strong>注意2：@extend与Sass不同的地方，在于Stylus的@extend支持继承嵌套选择器</strong></p>
<h3 id="2-7、方法"><a href="#2-7、方法" class="headerlink" title="2.7、方法"></a>2.7、方法</h3><p>编程语言重要的一个特征就是函数，在Stylus中，也有函数的概念，函数的概念和Mixins比较类似，但是，函数还可以有返回值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">/*! 函数 */</div><div class="line">// 个人建议在定义函数时，以f_为前缀，方便识别</div><div class="line">f_plus(a, b) //简单函数</div><div class="line">  a + b</div><div class="line">  </div><div class="line">f_plus2(a, b = a) //带默认值的函数</div><div class="line">  a + b + 0px</div><div class="line"></div><div class="line">f_multireturn() //多返回值函数</div><div class="line">  5px 10px 15px 20px</div><div class="line">  </div><div class="line">f_margin() //想要作为整体返回,为了消除歧义，建议使用rerurn和括号包裹返回值</div><div class="line">  return (5px 10px 5px 10px)</div><div class="line"></div><div class="line">f_test = f_margin //函数可以指定别名</div><div class="line"></div><div class="line">//和js雷同，函数可以作为参数传递</div><div class="line">f_fun1(a, b)</div><div class="line">  a + b + 0px</div><div class="line">f_fun2(a, b)</div><div class="line">  a - b + 0px</div><div class="line">f_invork(a, b, fn)</div><div class="line">  fn(a, b)  </div><div class="line"></div><div class="line">body</div><div class="line">  margin-top f_plus(5, 10)</div><div class="line">  margin-top f_plus(5px, 10)</div><div class="line">  margin-top f_plus2(5)</div><div class="line">  margin-top f_plus2(b: 10, a: 5) //命名参数传递</div><div class="line">  margin-bottom f_multireturn()[3] //取第四个值，下标从0开始</div><div class="line">  margin f_margin()</div><div class="line">  width f_invork(100, 50, f_fun1)</div><div class="line">  height f_invork(100, 50, f_fun2)</div></pre></td></tr></table></figure>
<p>编译之后为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">/* 函数 */</div><div class="line">body &#123;</div><div class="line">  margin-top: 15;</div><div class="line">  margin-top: 15px;</div><div class="line">  margin-top: 10px;</div><div class="line">  margin-top: 15px;</div><div class="line">  margin-bottom: 20px;</div><div class="line">  margin: 5px 10px 5px 10px;</div><div class="line">  width: 150px;</div><div class="line">  height: 50px;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="3、未完，待续"><a href="#3、未完，待续" class="headerlink" title="3、未完，待续"></a>3、未完，待续</h2>

    
    
    
  </section>
</article>
    </div>
  
    <div class='post-wrapper'>
      <article class="post reveal">
  <section class="meta">
    
    <h2 class="title">
      <a href="/blog/2017/02/21/Vue实践之路/01_认识Vue/">
        01_认识Vue
      </a>
    </h2>
    
    <time>
      Feb 21, 2017
    </time>
		
  </section>
  <section class="article typo">
	  <h1 id="0、关于Vue"><a href="#0、关于Vue" class="headerlink" title="0、关于Vue"></a>0、关于Vue</h1><p><a href="https://vuejs.org.cn/" target="_blank" rel="external">Vue</a> 是当前非常流行的一款前端 MV<em> 库（国人开发），结合 vue-router, vue-resource, vuex 等等，就形成了一套比较完善的前端 MV</em> 开发框架。</p>
<p>与它非常相似的框架是 <a href="http://avalonjs.coding.me/" target="_blank" rel="external">Avalon</a> ，都借鉴了当前流行的前端 MV* 库、框架，都是基于 ES5 getter setter 实现双向绑定。</p>
<p>与 <code>Avalon</code> 相比， <code>Vue</code> 在稳定性和文档方面更胜一筹。</p>
<p>但 <code>Avalon</code> 利用 <code>VBScript</code> 在IE6+上实现了双向绑定，不过文档和稳定性稍微有些欠缺。</p>
<p>那么如果没有IE9-的兼容性要求，有需要产线环境，那么Vue就是非常合适的一个东西了。</p>
<h1 id="1、配套工具"><a href="#1、配套工具" class="headerlink" title="1、配套工具"></a>1、配套工具</h1><p><code>Vue</code> 本身仅仅是一个双向绑定，组件化的库，要实现一个完整的应用，那么还需要其他的一些配套工具。</p>
<p>实际上，在 <code>Vue</code> 发布到流行的这几年间，它的配套工具已经相当完善了。特别是 <a href="https://github.com/vuejs/vue-cli" target="_blank" rel="external">vue-cli</a>，更是极大的减少了环境搭建的成本。</p>
<p>其他的路由，Ajax，数据流， <a href="https://github.com/vuejs" target="_blank" rel="external">vuejs组织</a> 也都提供了相应的package来支撑。</p>
<ol>
<li>路由  vue-router</li>
<li>Ajax/HTTP vue-resource</li>
<li>数据流 vuex</li>
</ol>
<h1 id="2、开始一个项目"><a href="#2、开始一个项目" class="headerlink" title="2、开始一个项目"></a>2、开始一个项目</h1><p>如果有Angular等前端框架使用经验，那么可以很轻松的切入vue的使用，因为有太多的似曾相识。</p>
<p>另外，通过vue-cli，我们可以不用自己去搭建开发环境，几条命令就足以让我们能够看到一个能跑起来的完整项目。特别是还自带热更新，自动编译，自动刷新等强大的构建功能。</p>
<p>来领略一下vue的魅力吧：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">// 全局安装vue-cli命令行工具</div><div class="line">$ npm install -g vue-cli  </div><div class="line"></div><div class="line">// 在当前目录中创建一个demo1目录，并创建一个基于webpack的开发环境。</div><div class="line">//（该命令是向导式方式，可以设置一些属性）</div><div class="line">$ vue init webpack demo1 // vue-init &lt;template-name&gt; [project-name]</div><div class="line"></div><div class="line">// 进入真正的项目目录</div><div class="line">$ cd demo1 </div><div class="line"></div><div class="line">// 安装依赖，你懂的~</div><div class="line">$ npm install </div><div class="line"></div><div class="line">// 运行开发环境（注意：默认端口是8080，执行该命令后不会自动打开页面，</div><div class="line">// 需要打开浏览器手动输入 http://localhost:8080 ）</div><div class="line">$ npm run dev</div></pre></td></tr></table></figure>
<p>仅仅有开发环境，你满足了么？反正我是不满足的，<code>vue-cli</code> 还提供了完善的命令，能够直接打包产线所需要的资源。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm run build // 生产环境打包</div></pre></td></tr></table></figure>
<h1 id="3、认识-vue"><a href="#3、认识-vue" class="headerlink" title="3、认识.vue"></a>3、认识.vue</h1><p><code>.vue</code> 是vue特有的一种文件格式，一个 <code>.vue</code> 文件也是一个独立的组件。</p>
<p>它把内部内容分为三块，样式，模板和逻辑（JS），逻辑部分原生支持 <code>ES2015</code>，简单的示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;style&gt;</div><div class="line">  &lt;!-- 用于放置组件样式 --&gt;</div><div class="line">&lt;/style&gt;</div><div class="line">&lt;template&gt;</div><div class="line">  &lt;!-- 用于放置组件模板 --&gt;</div><div class="line">&lt;/template&gt;</div><div class="line">&lt;script&gt;</div><div class="line">  // 用于放置组件逻辑代码</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>其中的 style 标记，还可以使用 <code>scoped</code> 标记来生成模块化CSS，也可以使用 <code>lang=&quot;&lt;lang&gt;&quot;</code> 来选择使用一个CSS预处理器。</p>
<p>我喜欢的方式如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span> <span class="attr">lang</span>=<span class="string">"stylus"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div></pre></td></tr></table></figure>
<p><strong>注意：如果选择了使用预处理器，那么需要安装特定的预处理器loader，如使用 <code>npm install stylus-loader</code> 来增加对 <code>stylus</code> 的支持。 </strong></p>
<h1 id="4、其他"><a href="#4、其他" class="headerlink" title="4、其他"></a>4、其他</h1><p>主流MVVM框架性能比较</p>
<p><img src="http://avalonjs.coding.me/styles/performance.jpg" alt="主流MVVM框架性能比较"></p>


    
    
    
  </section>
</article>
    </div>
  
    <div class='post-wrapper'>
      <article class="post reveal">
  <section class="meta">
    
    <h2 class="title">
      <a href="/blog/2017/02/21/Angular相关/Angular再回首(2)-那些容易忽略的Component细节/">
        Angular再回首(2)-那些容易忽略的Component细节
      </a>
    </h2>
    
    <time>
      Feb 21, 2017
    </time>
		
  </section>
  <section class="article typo">
	  <h2 id="0、前言"><a href="#0、前言" class="headerlink" title="0、前言"></a>0、前言</h2><p>在 <code>Angular 1.5.x</code> 中，增加的组件方法，相当实用和易用。但也有许多小细节问题值得注意，<br>以下为本人在组件实践过程中遇到的问题，或者是需要注意的小细节。</p>
<h2 id="1、问题-小细节（需要注意的点）"><a href="#1、问题-小细节（需要注意的点）" class="headerlink" title="1、问题/小细节（需要注意的点）"></a>1、问题/小细节（需要注意的点）</h2><h3 id="1-1、如何判断是否添加了可选的-transclude-元素？"><a href="#1-1、如何判断是否添加了可选的-transclude-元素？" class="headerlink" title="1.1、如何判断是否添加了可选的 transclude 元素？"></a>1.1、如何判断是否添加了可选的 <code>transclude</code> 元素？</h3><p>在很多时候，我们会给一个组件设定多个 <code>transclude</code>，可能其中有一部分是可选的，那如何判断可选的 <code>transclude</code> 被用户设置了值呢？</p>
<p>此时，我们可以依靠 <code>$transclude</code> 来进行判断：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">XXXComponent</span></span>&#123;</div><div class="line">  <span class="keyword">constructor</span>($transclude)&#123;</div><div class="line">    <span class="keyword">this</span>.$transclude = $transclude;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  $onInit()&#123;</div><div class="line">    <span class="comment">// 判断transclude是否存在</span></div><div class="line">    <span class="keyword">let</span> transcludeName = <span class="string">'xxx'</span>;</div><div class="line">    <span class="keyword">let</span> hasXXX = <span class="keyword">this</span>.$transclude.isSlotFilled(transcludeName);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">XXXComponent.$inject = [<span class="string">'$transclude'</span>];</div></pre></td></tr></table></figure>
<h3 id="1-2、如何监控绑定属性的变更？"><a href="#1-2、如何监控绑定属性的变更？" class="headerlink" title="1.2、如何监控绑定属性的变更？"></a>1.2、如何监控绑定属性的变更？</h3><p>属性绑定，分为一次性绑定(@)（也算是单向绑定），单向绑定(&lt;)，双向绑定(=)。</p>
<p><strong># 监控单向绑定属性</strong></p>
<p>对于单向绑定的属性，可以通过生命周期钩子 <code>$onChanges(changesObj)</code> 来进行监控。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">XXXController</span></span>&#123;</div><div class="line">  $onChanges(changesObj)&#123;</div><div class="line">    <span class="built_in">console</span>.log(changesObj);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中参数 <code>changesObj</code> 是所有变更属性的一个汇总，数据结构如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">changesObj = &#123;</div><div class="line">  key1: &#123; // 有变更的绑定属性</div><div class="line">    currentValue: any // 当前值 （变化后的值）</div><div class="line">    previousValue: any // 上一次的值 （变化前的值）</div><div class="line">    isFirstChange(): fn // 方法，用于判断是否是第一次变更。 </div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>注意：<code>$onChanges</code> 无法监控双向绑定属性，切记！</strong></p>
<p><strong># 监控双向绑定</strong></p>
<p>由于 <code>$onChanges</code> 无法监控双向绑定属性，那么我们就必须另外想办法来进行监控，可以有以下几种方案：</p>
<p><em>方案一：利用 <code>$interval</code></em></p>
<p>既然是双向绑定，那么肯定变化是直接生效的，关键就在于我们无法监视到，这个时候我们可以利用 <code>$interval</code> 来实现定时监控。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">XXXController</span></span>&#123;</div><div class="line">  <span class="keyword">constructor</span>($interval)&#123;</div><div class="line">    <span class="keyword">this</span>.$interval = $interval;</div><div class="line">    <span class="keyword">this</span>.init();</div><div class="line">  &#125;</div><div class="line">  init()&#123;</div><div class="line">    <span class="keyword">let</span> previousValue = <span class="literal">null</span>;</div><div class="line">    <span class="keyword">this</span>.$interval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">      <span class="keyword">if</span>(previousValue !== <span class="keyword">this</span>.value)&#123;</div><div class="line">        previousValue = <span class="keyword">this</span>.value;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'value changed'</span>);</div><div class="line">      &#125;</div><div class="line">    &#125;, <span class="number">200</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">XXXController.$inject = [<span class="string">'$interval'</span>];</div><div class="line"></div><div class="line">angular.module(<span class="string">'xxx'</span>).component(<span class="string">'xxx'</span>, &#123;</div><div class="line">  <span class="attr">bindings</span>: &#123;</div><div class="line">    <span class="attr">value</span>: <span class="string">'='</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">controller</span>: XXXController,</div><div class="line">  <span class="attr">controllerAs</span>: <span class="string">'vm'</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>优点：</p>
<ol>
<li>易于理解</li>
</ol>
<p>缺点：</p>
<ol>
<li>浪费资源</li>
<li>需要自己书写逻辑</li>
</ol>
<p>推荐指数： ☆</p>
<p><em>方案二：利用 <code>$scope.$watch(keyString)</code></em></p>
<p>组件也有独立的 <code>$scope</code>，那么借助 <code>$scope.$watch</code> 也可以实现监听属性变化，代码如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">class XXXController&#123;</div><div class="line">  constructor($scope)&#123;</div><div class="line">    this.$scope = $scope;</div><div class="line">    this.init();</div><div class="line">  &#125;</div><div class="line">  init()&#123;</div><div class="line">    this.$scope.$watch('vm.value', (newVal, oldVal) =&gt; &#123;</div><div class="line">      console.log('value changed);</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">XXXController.$inject = ['$scope'];</div><div class="line"></div><div class="line">angular.module('xxx').component('xxx', &#123;</div><div class="line">  bindings: &#123;</div><div class="line">    value: '=' // 双向绑定属性</div><div class="line">  &#125;,</div><div class="line">  controller: XXXController,</div><div class="line">  controllerAs: 'vm'</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>优点：</p>
<ol>
<li>使用简单</li>
</ol>
<p>缺点：</p>
<ol>
<li>字符串形式的 <code>$watch</code>,依赖 <code>controllerAs</code>,不易理解 </li>
<li>实质仍然是定时器，只不过是使用的 <code>angular</code> 自身的 <code>$diget</code> 循环</li>
</ol>
<p>推荐指数： ☆☆</p>
<p><em>方案三：利用 <code>$scope.$watch(fn)</code></em></p>
<p><code>$scope.$watch</code> 也接受函数类型的参数，相对于字符串形式，没有 <code>controllerAs</code> 的相关性，而且更灵活，代码如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">class XXXController&#123;</div><div class="line">  constructor($scope)&#123;</div><div class="line">    this.$scope = $scope;</div><div class="line">    this.init();</div><div class="line">  &#125;</div><div class="line">  init()&#123;</div><div class="line">    this.$scope.$watch(() =&gt; this.value, (newVal, oldVal) =&gt; &#123;</div><div class="line">      console.log('value changed);</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">XXXController.$inject = ['$scope'];</div><div class="line"></div><div class="line">angular.module('xxx').component('xxx', &#123;</div><div class="line">  bindings: &#123;</div><div class="line">    value: '=' // 双向绑定属性</div><div class="line">  &#125;,</div><div class="line">  controller: XXXController,</div><div class="line">  controllerAs: 'vm'</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>优点：</p>
<ol>
<li>使用简单</li>
</ol>
<p>缺点：</p>
<ol>
<li>实质仍然是定时器，只不过是使用的 <code>angular</code> 自身的 <code>$diget</code> 循环</li>
</ol>
<p>推荐指数： ☆☆☆☆</p>
<p><em>方案四：利用 <code>getter &amp; setter</code></em></p>
<p>因为我们使用了 <code>ES6 Class</code>，那么 <code>ES6</code> 的 <code>getter setter</code> 特性，我们也是能够使用的，方式如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">XXXController</span></span>&#123;</div><div class="line"></div><div class="line">  set value(val)&#123;</div><div class="line">    <span class="keyword">this</span>._value = val;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'value changed'</span>);</div><div class="line">  &#125;</div><div class="line">  get value()&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._value;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">XXXController.$inject = [];</div><div class="line"></div><div class="line">angular.module(<span class="string">'xxx'</span>).component(<span class="string">'xxx'</span>, &#123;</div><div class="line">  <span class="attr">bindings</span>: &#123;</div><div class="line">    <span class="attr">value</span>: <span class="string">'='</span> <span class="comment">// 双向绑定属性</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">controller</span>: XXXController,</div><div class="line">  <span class="attr">controllerAs</span>: <span class="string">'vm'</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>优点：</p>
<ol>
<li>没有额外的开销，性能高</li>
</ol>
<p>缺点：</p>
<ol>
<li>使用相对较为复杂</li>
</ol>
<p>推荐指数： ☆☆☆☆</p>


    
    
    
  </section>
</article>
    </div>
  
    <div class='post-wrapper'>
      <article class="post reveal">
  <section class="meta">
    
    <h2 class="title">
      <a href="/blog/2017/02/21/Angular相关/Angular开发Tips/">
        Angular开发Tips
      </a>
    </h2>
    
    <time>
      Feb 21, 2017
    </time>
		
  </section>
  <section class="article typo">
	  <p>1、在使用$routeProvider的时候，需要让模块依赖ngRoute，否则会提示找不到服务，示例：</p>
<pre><code>angular.module(&apos;module1&apos;, [&apos;ngRoute&apos;])
.config([&apos;$routeProvider&apos;, function($routeProvider){
  //do something...
}]);
</code></pre><p>2、在页面中需要绑定有风险的html的时候，可以使用 <code>ng-bind-html=&quot;html&quot;（version&gt;=1.3）</code>,如果遇到错误，控制器中可以使用<code>html = $sce.trustHtml(unsafeHtml)</code>。</p>
<p>3、 如何动态的向页面添加带指令的HTML？通入如下代码：</p>
<pre><code>$compile(html)($scope);
</code></pre><p>4、如果阻止事件冒泡？示例如下：</p>
<pre><code>//方式一，利用一个自定义指令实现
.directive(&apos;stopEventPropagation&apos;, function(){
  return {
    restrict: &apos;A&apos;,
    link: function(scope, iElement, iAttrs){
      //通过获取事件对象，来阻止调用
      iElement.bind(&apos;click&apos;, function(e){
        e.stopPropagation();
      });
    }
  }
});

&lt;a stop-event-propagation ng-click=&quot;doSomething();&quot;&gt;Click me&lt;/a&gt;

//方式二，直接引用$event对象

&lt;a ng-click=&quot;doSomething(); $event.stopPropagation();&quot;&gt;Click me&lt;/a&gt;
</code></pre><p>5、关于$route和$location的事件顺序，如下：</p>
<pre><code>$routeChangeStart -&gt; $locationChangeStart -&gt; $locationChangeSuccess -&gt; $routeChangeSuccess
</code></pre><p>6、有关select标签的使用，当options的来源是ajax时，那么如果指定选中项呢？如下：</p>
<pre><code>&lt;select ng-options=&quot;sysOptions&quot; ng-model=&quot;selectSystem&quot;&gt;&lt;/select&gt;
//如上HTML代码，如果sysOptions来自ajax请求，而selectSystem又不是的话，往往会选中一个空值。
//可以使用如下方式避免：
</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">.controller(<span class="string">'TestCtrl'</span>, [<span class="string">'$scope'</span>, <span class="string">'$http'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">$scope, $http</span>)</span>&#123;</div><div class="line">  $http.get(url).success(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</div><div class="line">    $scope.sysOptions = data;</div><div class="line">    <span class="comment">//在异步回调函数中，对ng-model赋值。</span></div><div class="line">    $scope.selectSystem = <span class="string">'Test'</span>;</div><div class="line">  &#125;);</div><div class="line">&#125;]);</div></pre></td></tr></table></figure>
<p>7、在编写指令时，属性的匹配大小写需要注意：如果在html中使用 <code>showName=&quot;xx&quot;</code>,那么在指令的iAttrs中，应该使用 <code>showname</code> 获取。如果要在指令中使用showName获取的话，那么必须在html中使用 <code>show-name=&quot;xx&quot;</code>。</p>
<p>8、要生成安全链接时，需要修改配置，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">需要将如下代码： ng-href=<span class="string">"&#123;&#123;true: 'javascript:void(0);' : 'url'&#125;&#125;"</span> </div><div class="line">生成为： href=<span class="string">"javascript:void(0);"</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.config([<span class="string">'$compileProvider'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">$compileProvider</span>)</span>&#123;</div><div class="line">    $compileProvider.aHrefSanitizationWhitelist(<span class="regexp">/^\s*(https?|ftp|mailto|file|javascript):/</span>)</div><div class="line">&#125;]);</div></pre></td></tr></table></figure>
<p>9、在ng-click等ng事件中，如果拿到事件源对象？如下：</p>
<pre><code class="javascript">&lt;a ng-click=<span class="string">"click($event);"</span> /&gt;

$scope.click = <span class="function"><span class="keyword">function</span>(<span class="params">$event</span>)</span>{
  <span class="keyword">var</span> target = $event.target;
};
<span class="comment">//注意，如果使用ng-click="click($event.target)"，将会导致angular解析错误。</span>
</code></pre>
<p>10、判断angular的模块是否存在，可以使用如下代码：</p>
<pre><code>var isAngularModuleExists = function(moduleName){
  try{
    angular.module(moduleName)
  }catch{
    return false
  }
  return true;
};
</code></pre><p>11、在使用coffee编写使用provider方式编写服务时，当心写在最后的this.$get，coffee会将最后一句编译为return this.$get，而这刚好不符合provider的要求，所以应该在末尾手动加上return或者放置一个undefined在最后，放置编译出return this.$get这样的代码。</p>
<p>12、如果要动态控制是否启用非空验证，可以使用ng-required=”true|false”指令。</p>
<p>13、当心ng-if指令，在使用ng-if指令时，会创建独立的作用域，如果要在$scope监视ng-if包含的变量，那么是无法成功的。如果一定要监视，可以考虑使用ng-show。</p>
<p>14、注意.value()与.constant的区别，前者只能注入和用于服务或者控制器中，后则可以被注入到配置(.config([‘xx’]))中。</p>


    
    
    
  </section>
</article>
    </div>
  
    <div class='post-wrapper'>
      <article class="post reveal">
  <section class="meta">
    
    <h2 class="title">
      <a href="/blog/2017/02/21/Angular相关/Angular再回首(3)-我们来实现一个组件/">
        Angular再回首(3)-我们来实现一个组件
      </a>
    </h2>
    
    <time>
      Feb 21, 2017
    </time>
		
  </section>
  <section class="article typo">
	  <h2 id="0、前言"><a href="#0、前言" class="headerlink" title="0、前言"></a>0、前言</h2><p>前两文写了 <code>Component</code> 的一些方面，但没有一个比较线性的串联关系，本文，就来从一个实例出发，来尝试概括一个组件的方方面面。</p>
<h2 id="1、"><a href="#1、" class="headerlink" title="1、"></a>1、</h2><h2 id="2、组件实现"><a href="#2、组件实现" class="headerlink" title="2、组件实现"></a>2、组件实现</h2><h3 id="2-1、先整一个组件"><a href="#2-1、先整一个组件" class="headerlink" title="2.1、先整一个组件"></a>2.1、先整一个组件</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">angular.module(<span class="string">'app'</span>, [])</div><div class="line">  .component(<span class="string">'finalComponent'</span>, &#123;&#125;);</div></pre></td></tr></table></figure>
<p>这个组件啥都不干，就提供了一个新的标签，显得毫无意义，但是我们可以从这里看到如何定义一个组件。</p>
<p><strong>注意：组件名称，请使用小驼峰命名法，在HTML中，请使用连字符+小写字母，这种实现是为了处理js和html大小写敏感的差异(js区分大小写，html不区分)</strong></p>
<p><strong>注意2：如果在组件标签中，嵌入有效的标签，是会显示出来的，如下：</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">final-component</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">final-component</span>&gt;</span></div></pre></td></tr></table></figure>
<p>会显示出大号的 “Hello”。</p>
<h3 id="2-2、带模板的组件"><a href="#2-2、带模板的组件" class="headerlink" title="2.2、带模板的组件"></a>2.2、带模板的组件</h3><p>接着，来实现一个有意义的组件，比如我要渲染一个特定的字符串，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">angular.module(<span class="string">'app'</span>, [])</div><div class="line">  .component(<span class="string">'finalComponent'</span>, &#123;</div><div class="line">    <span class="attr">template</span>: <span class="string">'&lt;h1&gt;Hello World.&lt;/h1&gt;'</span></div><div class="line">  &#125;);</div></pre></td></tr></table></figure>
<p>现在我们再使用：<code>&lt;final-component&gt;ABC&lt;/final-component&gt;</code>，则会显示 “Hello World” 内容了。</p>
<p><strong>注意：当组件指定了模板属性后，其内部的标签，将不会生效（transclude除外，）</strong></p>
<h3 id="2-3、复杂模板的组件"><a href="#2-3、复杂模板的组件" class="headerlink" title="2.3、复杂模板的组件"></a>2.3、复杂模板的组件</h3><p>以上，我们已经实现了带模板的组件，可是我们的模板可能会比较复杂，这个时候直接写 <code>template</code> 就不太好用了,此时，我们会考虑把模板拆分到一个独立的 <code>.html</code> 文件中，代码如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 组件模板内容(文件名为:template.html) --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello World.<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div></pre></td></tr></table></figure>
<p>然后，使用 <code>templateUrl</code> 属性进行关联</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">angular.module(<span class="string">'app'</span>, [])</div><div class="line">  .component(<span class="string">'finalComponent'</span>, &#123;</div><div class="line">    <span class="attr">templateUrl</span>: <span class="string">'/app/template.html'</span></div><div class="line">  &#125;);</div></pre></td></tr></table></figure>
<p>该代码可以达到 2.2 同样的效果，只是把模板内容拆分到独立文件中了。</p>
<p><strong>注意：模板路径可以是相对路径，也可以是绝对路径，需要注意路径的写法，否则会出现找不到模板</strong></p>
<p><strong>注意2：如果使用 <code>gulp</code> 构建，可以考虑使用 <code>gulp-angular-embed-templates</code> 将独立的模板文件，打包到组件中。</strong></p>
<h3 id="2-4、组件属性绑定"><a href="#2-4、组件属性绑定" class="headerlink" title="2.4、组件属性绑定"></a>2.4、组件属性绑定</h3><p>之前实现的组件，感觉太死板了，我想改下文字，都不好实现（你非要用js强制操作dom，我拿你也没办法，不过后果自负），这个时候，我们迫切的需要能给组件传递参数。</p>
<p><code>Angular</code> 组件中，有多个参数传递方式，如下：</p>
<ul>
<li>@ 单向绑定字符串（原值绑定） - 传什么就是什么，不做任何处理</li>
<li>&lt; 单向绑定变量（取scope的值绑定） - 传的值会先用 <code>$scope</code> 转换，把结果传递给组件</li>
<li>= 双向绑定 - 组件内外变化都会通知另一方</li>
</ul>
<h4 id="2-4-1-直接传递字符串参数"><a href="#2-4-1-直接传递字符串参数" class="headerlink" title="2.4.1 直接传递字符串参数"></a>2.4.1 直接传递字符串参数</h4><p>使用 <code>@</code> 进行单向字符串绑定</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">angular.module(<span class="string">'app'</span>, [])</div><div class="line">  .component(<span class="string">'finalComponent'</span>, &#123;</div><div class="line">    <span class="attr">templateUrl</span>: <span class="string">'/app/template.html'</span></div><div class="line">    bindings: &#123;</div><div class="line">      <span class="attr">name</span>: <span class="string">'@'</span></div><div class="line">    &#125;</div><div class="line">  &#125;);</div></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 模板内容 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello &#123;&#123;$ctrl.name&#125;&#125;.<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 使用组件 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">final-component</span> <span class="attr">name</span>=<span class="string">"Jay"</span>&gt;</span><span class="tag">&lt;/<span class="name">final-component</span>&gt;</span></div></pre></td></tr></table></figure>
<p>此时，将会显示“Hello Jay”，可以看到，设定的参数值会原样显示了。</p>
<p><strong>注意：在模板中，要使用变量，需要加$ctrl前缀，先这样用着，后面会提到</strong></p>
<h4 id="2-4-2-使用单向绑定变量"><a href="#2-4-2-使用单向绑定变量" class="headerlink" title="2.4.2 使用单向绑定变量"></a>2.4.2 使用单向绑定变量</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestController</span></span>&#123;</div><div class="line">  <span class="keyword">constructor</span>()&#123;</div><div class="line">    <span class="keyword">this</span>.name = <span class="string">'Jay'</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">TestController.$inject = []; <span class="comment">// 依赖</span></div><div class="line">angular.module(<span class="string">'app'</span>, [])</div><div class="line">  .component(<span class="string">'finalComponent'</span>, &#123;</div><div class="line">    <span class="attr">templateUrl</span>: <span class="string">'/app/template.html'</span></div><div class="line">    bindings: &#123;</div><div class="line">      <span class="attr">name</span>: <span class="string">'&lt;'</span></div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line">  .controller(<span class="string">'TestController'</span>, TestController);</div></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 模板内容 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello &#123;&#123;$ctrl.name&#125;&#125;.<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 使用组件 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ng-controller</span>=<span class="string">"TestController as t"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">final-component</span> <span class="attr">name</span>=<span class="string">"t.name"</span>&gt;</span><span class="tag">&lt;/<span class="name">final-component</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>此时，也将会显示“Hello Jay”，可以看到，此时 <code>t.name</code> 会拿到 <code>$scope</code> 中进行解析。</p>
<p><strong>注意：推荐使用 <code>controller as</code> 写法</strong></p>
<h4 id="2-4-3-双向绑定"><a href="#2-4-3-双向绑定" class="headerlink" title="2.4.3 双向绑定"></a>2.4.3 双向绑定</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestController</span></span>&#123;</div><div class="line">  <span class="keyword">constructor</span>()&#123;</div><div class="line">    <span class="keyword">this</span>.name = <span class="string">'Jay'</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">TestController.$inject = []; <span class="comment">// 依赖</span></div><div class="line">angular.module(<span class="string">'app'</span>, [])</div><div class="line">  .component(<span class="string">'finalComponent'</span>, &#123;</div><div class="line">    <span class="attr">templateUrl</span>: <span class="string">'/app/template.html'</span></div><div class="line">    bindings: &#123;</div><div class="line">      <span class="attr">name</span>: <span class="string">'='</span></div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line">  .controller(<span class="string">'TestController'</span>, TestController);</div></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 模板内容 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello &#123;&#123;$ctrl.name&#125;&#125;.<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">ng-model</span>=<span class="string">"$ctrl.name"</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 使用组件 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ng-controller</span>=<span class="string">"TestController as t"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">final-component</span> <span class="attr">name</span>=<span class="string">"t.name"</span>&gt;</span><span class="tag">&lt;/<span class="name">final-component</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">h3</span>&gt;</span>&#123;&#123;t.name&#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>此时，在文本框输入值之后，可以看到组件内外都会及时变更。</p>


    
    
    
  </section>
</article>
    </div>
  
</section>


  <nav id="page-nav">
    
    <a class="prev" rel="prev" href="/blog/archives/2017/page/6/">
      <span class="icon icon-chevron-left"></span>
      <span class="text">Previous</span>
    </a>
    
    
    <a class="next" rel="next" href="/blog/archives/2017/page/8/">
      <span class="text">Next</span>
      <span class="icon icon-chevron-right"></span>
    </a>
    
  </nav>
  


      </div>
      <aside class='l_side'>
        
  <section class='m_widget about'>

<img class='avatar waves-image' src='https://avatars1.githubusercontent.com/u/4043284?v=3&amp;s=460' />

<div class='header'>Jay.M.Hu</div>
<div class='content'>
<div></div>
</div>
</section>

  <section class='m_widget friendly-links'>
<div class='header'>Links</div>
<div class='content'>
    <ul class="entry">
    
        <li><a class="flat-box" target="_blank" href="http://humin.cnblogs.com/">
            <div class='name'>幻天芒 - 博客园</div>
        </a></li>
    
    </ul>
</div>
</section>

  <section class='m_widget categories'>
<div class='header'>Categories</div>
<div class='content'>
    
</div>
</section>

  


      </aside>
      <script>setLoadingBarProgress(60);</script>
    </div>
  </div>
  <footer id="footer" class="clearfix">

	<div class="social-wrapper">
  	
      
        <a href="https://github.com/hstarorg" class="social github"
          target="_blank" rel="external">
          <span class="icon icon-github"></span>
        </a>
      
        <a href="/atom.xml" class="social rss"
          target="_blank" rel="external">
          <span class="icon icon-rss"></span>
        </a>
      
    
  </div>
  
  <div>Theme <a href='https://github.com/stkevintan/hexo-theme-material-flow' class="codename">MaterialFlow</a> designed by <a href="http://keyin.me/" target="_blank">Kevin Tan</a>.</div>
  
</footer>


  <script>setLoadingBarProgress(80);</script>
  

<script src="//apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
<script src='//cdn.bootcss.com/node-waves/0.7.5/waves.min.js'></script>
<script src="//cdn.bootcss.com/scrollReveal.js/3.3.2/scrollreveal.min.js"></script>
<script src="/blog/js/jquery.fitvids.js"></script>
<script>
	var GOOGLE_CUSTOM_SEARCH_API_KEY = "";
	var GOOGLE_CUSTOM_SEARCH_ENGINE_ID = "";
	var ALGOLIA_API_KEY = "";
	var ALGOLIA_APP_ID = "";
	var ALGOLIA_INDEX_NAME = "";
  var AZURE_SERVICE_NAME = "";
  var AZURE_INDEX_NAME = "";
  var AZURE_QUERY_KEY = "";
  var BAIDU_API_ID = "";
  var SEARCH_SERVICE = "hexo";
  var ROOT = "/blog/"||"/";
  if(!ROOT.endsWith('/'))ROOT += '/';
</script>
<script src="/blog/js/search.js"></script>
<script src="/blog/js/app.js"></script>


  <script>setLoadingBarProgress(100);</script>
</body>
</html>
