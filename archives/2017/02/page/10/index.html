<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  
  <title>Archives: 2017/2 | 幻☆精灵的Blog</title>
  <meta name="description" content="幻☆精灵的Blog站点" />
  <meta name="keywords" content="幻精灵" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <link rel="shortcut icon" href="/blog/images/favicon.ico">
  <link rel="alternate" href="/blog/atom.xml" title="幻☆精灵的Blog">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="幻☆精灵的Blog站点">
<meta property="og:type" content="website">
<meta property="og:title" content="幻☆精灵的Blog">
<meta property="og:url" content="http://hstarorg.github.io/blog/archives/2017/02/page/10/index.html">
<meta property="og:site_name" content="幻☆精灵的Blog">
<meta property="og:description" content="幻☆精灵的Blog站点">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="幻☆精灵的Blog">
<meta name="twitter:description" content="幻☆精灵的Blog站点">
    
  <link href="https://fonts.googleapis.com/css?family=Inconsolata|Titillium+Web" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css?family=Roboto+Mono" rel="stylesheet">
  <link href='//cdn.bootcss.com/node-waves/0.7.5/waves.min.css' rel='stylesheet'>
  <link rel="stylesheet" href="/blog/style.css">
  
  

  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>
</head>

<body>
  <div id="loading-bar-wrapper">
  <div id="loading-bar"></div>
</div>


  <script>setLoadingBarProgress(20)</script> 
  <header class="l_header">
		<div class="wrapper container">
			<a class="logo flat-box" href='/blog/' >
				幻☆精灵的Blog
			</a>
			<div class='menu'>
				<ul class='h-list'>
					
						<li>
							<a class='flat-box nav-home' href='/blog/'>
								首页
							</a>
						</li>
					
						<li>
							<a class='flat-box nav-archives' href='/blog/archives'>
								归档
							</a>
						</li>
					
						<li>
							<a class='flat-box nav-about' href='/blog/about'>
								关于我
							</a>
						</li>
					
				</ul>
				<div class='underline'></div>
			</div>
			
				<div class="m_search">
					<form name="searchform" class="form u-search-form">
						<input type="text" class="input u-search-input" placeholder="Search" />
						<span class="icon icon-search"></span>
					</form>
				</div>
			
			<ul class='switcher h-list'>
				
					<li class='s-search'><a href='javascript:void(0)'><span class="icon icon-search"></span></a></li>
				
				<li class='s-menu'><a href='javascript:void(0)'><span class="icon icon-menu"></span></a></li>
			</ul>
		</div>
		<aside class="menu-phone">
			<nav>
				
					<a href="/blog/" class="nav-home nav">
						首页
					</a>
				
					<a href="/blog/archives" class="nav-archives nav">
						归档
					</a>
				
					<a href="/blog/about" class="nav-about nav">
						关于我
					</a>
				
			</nav>
		</aside>
</header>

    <script>setLoadingBarProgress(40);</script>
  <div class="l_body">
    <div class='container'>
      <div class='l_main'>
        
	
	<section class="page-header archive banner waves-image">
    <h1>Year : <span>2017.2</span></h1>
  </section>

<section class="post-list">
	
    <div class='post-wrapper'>
      <article class="post reveal">
  <section class="meta">
    
    <h2 class="title">
      <a href="/blog/2017/02/21/CSS3学习之路/CSS3入门之转换/">
        CSS3入门之转换
      </a>
    </h2>
    
    <time>
      Feb 21, 2017
    </time>
		
  </section>
  <section class="article typo">
	  <h2 id="1、CSS3-转换"><a href="#1、CSS3-转换" class="headerlink" title="1、CSS3 转换"></a>1、CSS3 转换</h2><h3 id="1-1、转换是什么，能实现哪些效果？"><a href="#1-1、转换是什么，能实现哪些效果？" class="headerlink" title="1.1、转换是什么，能实现哪些效果？"></a>1.1、转换是什么，能实现哪些效果？</h3><p>转换是使元素改变形状、尺寸和位置的一种效果，主要能实现的效果如下：</p>
<ol>
<li>移动</li>
<li>缩放</li>
<li>转动</li>
<li>拉长</li>
<li>拉伸</li>
</ol>
<h3 id="1-2、浏览器兼容"><a href="#1-2、浏览器兼容" class="headerlink" title="1.2、浏览器兼容"></a>1.2、浏览器兼容</h3><p>CSS3的转换属性为 <code>transform</code> ，IE10+,Firefox,Chrome,Opera,Safari等现代浏览器支持transform属性，IE9需要-ms-前缀。</p>
<h2 id="2、-2D-转换"><a href="#2、-2D-转换" class="headerlink" title="2、 2D 转换"></a>2、 2D 转换</h2><p>准备工作：</p>
<pre><code>&lt;style&gt;
  .container{
    position:relative;border:1px solid red; width: 100px; height: 100px;
  }
  .container&gt;div{
    width: 50px; height: 50px; background: gray;
  }
&lt;/style&gt;
</code></pre><style>
  .container{
    position:relative;border:1px solid red; width: 100px; height: 100px;
  }
  .container div{
    width: 50px; height: 50px; background: gray;
  }
</style>

<h3 id="2-1、translate-–-移动"><a href="#2-1、translate-–-移动" class="headerlink" title="2.1、translate() – 移动"></a>2.1、translate() – 移动</h3><p>translate(/*x坐标移动位移*/ left, /*y坐标移动位移*/ top)</p>
<pre><code>&lt;h3&gt;右移20px&lt;/h3&gt;
&lt;div class=&quot;container&quot;&gt;
  &lt;div style=&quot;transform: translate(20px);&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;h3&gt;下移20px&lt;/h3&gt;
&lt;div class=&quot;container&quot;&gt;
  &lt;div style=&quot;transform: translate(0px,20px);&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;h3&gt;左移20px，下移20px&lt;/h3&gt;
&lt;div class=&quot;container&quot;&gt;
  &lt;div style=&quot;transform: translate(-20px,20px);&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre><p></p><h3>右移20px</h3><p></p>
<div class="container"><br>  <div style="transform: translate(20px);"></div><br></div><br><h3>下移20px</h3><br><div class="container"><br>  <div style="transform: translate(0px,20px);"></div><br></div><br><h3>左移20px，下移20px</h3><br><div class="container"><br>  <div style="transform: translate(-20px,20px);"></div><br></div>

<h3 id="2-2、rotate-–-旋转"><a href="#2-2、rotate-–-旋转" class="headerlink" title="2.2、rotate() – 旋转"></a>2.2、rotate() – 旋转</h3><p>rotate(/*旋转角度*/ deg)</p>
<pre><code>&lt;h3&gt;旋转135度&lt;/h3&gt;
&lt;div class=&quot;container&quot;&gt;
  &lt;div style=&quot;transform: rotate(135deg);&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre><p></p><h3>旋转135度</h3><p></p>
<div class="container"><br>  <div style="transform: rotate(135deg);"></div><br></div>

<h3 id="2-3、scale-–-缩放"><a href="#2-3、scale-–-缩放" class="headerlink" title="2.3、scale() – 缩放"></a>2.3、scale() – 缩放</h3><p>scale(/*宽度缩放比例*/ widthScale, /*高度缩放比例*/ heightScale)</p>
<pre><code>&lt;h3&gt;缩放到0.5倍&lt;/h3&gt;
&lt;div class=&quot;container&quot;&gt;
  &lt;div style=&quot;transform: scale(0.5, 0.5);&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;h3&gt;宽度缩放到1.5倍，高度缩放到0.25倍&lt;/h3&gt;
&lt;div class=&quot;container&quot;&gt;
  &lt;div style=&quot;transform: scale(1.5, 0.25);&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre><p></p><h3>缩放到0.5倍</h3><p></p>
<div class="container"><br>  <div style="transform: scale(0.5, 0.5);"></div><br></div><br><h3>宽度缩放到1.5倍，高度缩放到0.25倍</h3><br><div class="container"><br>  <div style="transform: scale(1.5, 0.25);"></div><br></div>

<h3 id="2-4、skew-–-倾斜"><a href="#2-4、skew-–-倾斜" class="headerlink" title="2.4、skew() – 倾斜"></a>2.4、skew() – 倾斜</h3><p>skew(/*X轴倾斜角度*/ xDeg, /*Y轴倾斜角度*/ yDeg)</p>
<pre><code>&lt;h3&gt;X轴翻转30度&lt;/h3&gt;
&lt;div class=&quot;container&quot;&gt;
  &lt;div style=&quot;transform: skew(30deg);&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;h3&gt;X轴翻转30度，Y轴翻转10度&lt;/h3&gt;
&lt;div class=&quot;container&quot;&gt;
  &lt;div style=&quot;transform: skew(30deg, 10deg)&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre><p></p><h3>X轴翻转30度</h3><p></p>
<div class="container"><br>  <div style="transform: skew(30deg);"></div><br></div><br><h3>X轴翻转30度，Y轴翻转10度</h3><br><div class="container"><br>  <div style="transform: skew(30deg, 10deg)"></div><br></div>

<h3 id="2-5、matrix-–矩阵"><a href="#2-5、matrix-–矩阵" class="headerlink" title="2.5、matrix() –矩阵"></a>2.5、matrix() –矩阵</h3><pre><code>&lt;h3&gt;旋转30度&lt;/h3&gt;
&lt;div class=&quot;container&quot;&gt;
  &lt;div style=&quot;transform: matrix(0.866,0.5,-0.5,0.866,0,0)&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre><p></p><h3>旋转30度</h3><p></p>
<div class="container"><br>  <div style="transform: matrix(0.866,0.5,-0.5,0.866,0,0)"></div><br></div>


<h3 id="2-6-Transform方法"><a href="#2-6-Transform方法" class="headerlink" title="2.6 Transform方法"></a>2.6 Transform方法</h3><table class="dataintable"><br><tbody><tr><br><th style="width:25%;">函数</th><br><th>描述</th><br></tr><br><br><tr><br><td>matrix(<i>n</i>,<i>n</i>,<i>n</i>,<i>n</i>,<i>n</i>,<i>n</i>)</td><br><td>定义 2D 转换，使用六个值的矩阵。</td><br></tr><br><br><tr><br><td>translate(<i>x</i>,<i>y</i>)</td><br><td>定义 2D 转换，沿着 X 和 Y 轴移动元素。</td><br></tr><br><br><tr><br><td>translateX(<i>n</i>)</td><br><td>定义 2D 转换，沿着 X 轴移动元素。</td><br></tr><br><br><tr><br><td>translateY(<i>n</i>)</td><br><td>定义 2D 转换，沿着 Y 轴移动元素。</td><br></tr><br><br><tr><br><td>scale(<i>x</i>,<i>y</i>)</td><br><td>定义 2D 缩放转换，改变元素的宽度和高度。</td><br></tr><br><br><tr><br><td>scaleX(<i>n</i>)</td><br><td>定义 2D 缩放转换，改变元素的宽度。</td><br></tr><br><br><tr><br><td>scaleY(<i>n</i>)</td><br><td>定义 2D 缩放转换，改变元素的高度。</td><br></tr><br><br><tr><br><td>rotate(<i>angle</i>)</td><br><td>定义 2D 旋转，在参数中规定角度。</td><br></tr><br><br><tr><br><td>skew(<i>x-angle</i>,<i>y-angle</i>)</td><br><td>定义 2D 倾斜转换，沿着 X 和 Y 轴。</td><br></tr><br><br><tr><br><td>skewX(<i>angle</i>)</td><br><td>定义 2D 倾斜转换，沿着 X 轴。</td><br></tr><br><br><tr><br><td>skewY(<i>angle</i>)</td><br><td>定义 2D 倾斜转换，沿着 Y 轴。</td><br></tr><br></tbody></table>


<h2 id="3、3D-转换"><a href="#3、3D-转换" class="headerlink" title="3、3D 转换"></a>3、3D 转换</h2><h3 id="3-1、rotateX、rotateY"><a href="#3-1、rotateX、rotateY" class="headerlink" title="3.1、rotateX、rotateY"></a>3.1、rotateX、rotateY</h3><pre><code>&lt;div class=&quot;container&quot;&gt;
  &lt;div style=&quot;transform: rotateY(0deg)&quot; id=&quot;fun2&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;script&gt;  
function fun2 (element) {
  var i = 0;
  var interval = setInterval(function(){
    element.style.transform = &apos;rotateY(&apos; + i + &apos;deg)&apos;;
    i++;
  }, 5);
}
fun2(document.getElementById(&apos;fun2&apos;));
&lt;/script&gt;
</code></pre><p><div class="container"><br>  <div style="transform: rotateY(0deg)" id="fun2"></div><br></div></p>
<script>  
function fun2 (element) {
  var i = 0;
  var interval = setInterval(function(){
    element.style.transform = 'rotateY(' + i + 'deg)';
    i++;
  }, 5);
}
fun2(document.getElementById('fun2'));
</script>

<h3 id="3-2、Transform方法"><a href="#3-2、Transform方法" class="headerlink" title="3.2、Transform方法"></a>3.2、Transform方法</h3><table class="dataintable"><br><tbody><tr><br><th style="width:25%;">函数</th><br><th>描述</th><br></tr><br><br><tr><br><td>matrix3d(<i>n</i>,<i>n</i>,<i>n</i>,<i>n</i>,<i>n</i>,<i>n</i>,<br><i>n</i>,<i>n</i>,<i>n</i>,<i>n</i>,<i>n</i>,<i>n</i>,<i>n</i>,<i>n</i>,<i>n</i>,<i>n</i>)</td><br><td>定义 3D 转换，使用 16 个值的 4x4 矩阵。</td><br></tr><br><br><tr><br><td>translate3d(<i>x</i>,<i>y</i>,<i>z</i>)</td><br><td>定义 3D 转化。</td><br></tr><br><br><tr><br><td>translateX(<i>x</i>)</td><br><td>定义 3D 转化，仅使用用于 X 轴的值。</td><br></tr><br><br><tr><br><td>translateY(<i>y</i>)</td><br><td>定义 3D 转化，仅使用用于 Y 轴的值。</td><br></tr><br><br><tr><br><td>translateZ(<i>z</i>)</td><br><td>定义 3D 转化，仅使用用于 Z 轴的值。</td><br></tr><br><br><tr><br><td>scale3d(<i>x</i>,<i>y</i>,<i>z</i>)</td><br><td>定义 3D 缩放转换。</td><br></tr><br><br><tr><br><td>scaleX(<i>x</i>)</td><br><td>定义 3D 缩放转换，通过给定一个 X 轴的值。</td><br></tr><br><br><tr><br><td>scaleY(<i>y</i>)</td><br><td>定义 3D 缩放转换，通过给定一个 Y 轴的值。</td><br></tr><br><br><tr><br><td>scaleZ(<i>z</i>)</td><br><td>定义 3D 缩放转换，通过给定一个 Z 轴的值。</td><br></tr><br><br><tr><br><td>rotate3d(<i>x</i>,<i>y</i>,<i>z</i>,<i>angle</i>)</td><br><td>定义 3D 旋转。</td><br></tr><br><br><tr><br><td>rotateX(<i>angle</i>)</td><br><td>定义沿 X 轴的 3D 旋转。</td><br></tr><br><br><tr><br><td>rotateY(<i>angle</i>)</td><br><td>定义沿 Y 轴的 3D 旋转。</td><br></tr><br><br><tr><br><td>rotateZ(<i>angle</i>)</td><br><td>定义沿 Z 轴的 3D 旋转。</td><br></tr><br><br><tr><br><td>perspective(<i>n</i>)</td><br><td>定义 3D 转换元素的透视视图。</td><br></tr><br></tbody></table>

    
    
    
  </section>
</article>
    </div>
  
    <div class='post-wrapper'>
      <article class="post reveal">
  <section class="meta">
    
    <h2 class="title">
      <a href="/blog/2017/02/21/Angular2一路向前/Angular2踩坑大全/">
        Angular2踩坑大全
      </a>
    </h2>
    
    <time>
      Feb 21, 2017
    </time>
		
  </section>
  <section class="article typo">
	  <h2 id="Angular2的那些坑"><a href="#Angular2的那些坑" class="headerlink" title="Angular2的那些坑"></a>Angular2的那些坑</h2><p>1、同样的代码，引用Rxjs库的版本不对，就会导致在IE11下无法运行。(特定版本下重现)<br>正确的版本：<a href="https://code.angularjs.org/2.0.0-beta.12/Rx.js" target="_blank" rel="external">https://code.angularjs.org/2.0.0-beta.12/Rx.js</a></p>
<p>2、在使用TypeScript编写Angular2代码时，一定要将注意 <code>tsconfig.json</code>，其中 <code>experimentalDecorators</code> 和 <code>emitDecoratorMetadata</code> 必须要设置为true，否则无法使用依赖注入。</p>
<p>3、&lt;router-outlet&gt; 不能放在带有 *ngIf的容器内，否则会出现初始化时无法找到。</p>


    
    
    
  </section>
</article>
    </div>
  
    <div class='post-wrapper'>
      <article class="post reveal">
  <section class="meta">
    
    <h2 class="title">
      <a href="/blog/2017/02/21/CSS3学习之路/CSS3入门之边框与背景/">
        CSS3入门之边框与背景
      </a>
    </h2>
    
    <time>
      Feb 21, 2017
    </time>
		
  </section>
  <section class="article typo">
	  <h2 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h2><p>CSS3作为CSS的最新版本，在展示效果上有非常大的提升，接下来，我们就一起领略一下CSS3的风采吧。</p>
<h2 id="2、CSS3边框"><a href="#2、CSS3边框" class="headerlink" title="2、CSS3边框"></a>2、CSS3边框</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;style&gt;</div><div class="line">    .td&#123;</div><div class="line">      width: 200px;</div><div class="line">      height: 100px;</div><div class="line">      border: 1px solid black;</div><div class="line">      margin: 10px 0; </div><div class="line">    &#125;</div><div class="line">&lt;/style&gt;</div></pre></td></tr></table></figure>
<h3 id="2-1、border-radius-用于设置圆角边框"><a href="#2-1、border-radius-用于设置圆角边框" class="headerlink" title="2.1、border-radius(用于设置圆角边框)"></a>2.1、border-radius(用于设置圆角边框)</h3><p>在CSS2时代，要想实现圆角边框，是一件非常麻烦的事情。一种实现方式是使用一个背景图片，为了实现伸缩效果，还需要至少3张图片拼凑，相当麻烦。另外一种实现方式是使用多个div重叠来实现圆角。</p>
<p>在CSS3中，有一个非常简单的属性，那就是border-radius。</p>
<p>语法： <code>border-radius: 1-4 length|% / 1-4 length|%;</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">border-radius: 10px;</div><div class="line">//等价于</div><div class="line">border-top-left-radius:10px;</div><div class="line">border-top-right-radius:10px;</div><div class="line">border-bottom-right-radius:10px;</div><div class="line">border-bottom-left-radius:10px;</div></pre></td></tr></table></figure>
<div style="border-radius:10px;"><br>    演示圆角边框<br></div>

<div style="border-radius:10px;"><br>    演示圆角边框<br></div>

<p><strong>兼容性说明：</strong> IE9+，Chrome,FF,Safari,Oprea<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">div</div><div class="line">&#123;</div><div class="line">  border:2px solid;</div><div class="line">  border-radius:25px;</div><div class="line">  -moz-border-radius:25px; /* Old Firefox */</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="2-2、box-shadow-用于添加边框阴影"><a href="#2-2、box-shadow-用于添加边框阴影" class="headerlink" title="2.2、box-shadow(用于添加边框阴影)"></a>2.2、box-shadow(用于添加边框阴影)</h3><p>语法： <code>box-shadow: h-shadow v-shadow blur spread color inset;</code>,其中h-shadow和v-shadow是必须设置，允许负值。【参数说明：水平阴影的位置，垂直阴影的位置，模糊距离，阴影的尺寸，阴影的颜色，外部引用(outset)改为内部阴影】</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"td"</span> <span class="attr">style</span>=<span class="string">"border-radius:10px; border: 1px solid red;"</span>&gt;</span></div><div class="line">    演示圆角边框</div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"td"</span> <span class="attr">style</span>=<span class="string">"box-shadow: 2px 2px red;"</span>&gt;</span></div><div class="line">	简单阴影</div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"td"</span> <span class="attr">style</span>=<span class="string">"box-shadow: -2px -2px red;"</span>&gt;</span></div><div class="line">  简单阴影</div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"td"</span> <span class="attr">style</span>=<span class="string">"box-shadow: -2px -2px red;"</span>&gt;</span></div><div class="line">	简单阴影</div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"td"</span> <span class="attr">style</span>=<span class="string">"box-shadow: -2px -2px 10px red;"</span>&gt;</span></div><div class="line">  带模糊效果的阴影</div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"td"</span> <span class="attr">style</span>=<span class="string">"box-shadow: -2px -2px 10px red;"</span>&gt;</span></div><div class="line">    带模糊效果的阴影</div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"td"</span> <span class="attr">style</span>=<span class="string">"box-shadow: 2px 2px 10px 10px red;"</span>&gt;</span></div><div class="line">  带模糊效果指定尺寸的阴影</div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"td"</span> <span class="attr">style</span>=<span class="string">"box-shadow: 2px 2px 10px 10px red;"</span>&gt;</span></div><div class="line">	带模糊效果指定尺寸的阴影</div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"td"</span> <span class="attr">style</span>=<span class="string">"box-shadow: 2px 2px 10px 10px red inset;"</span>&gt;</span></div><div class="line">  内部阴影</div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"td"</span> <span class="attr">style</span>=<span class="string">"box-shadow: 2px 2px 10px 10px red inset;"</span>&gt;</span></div><div class="line">    内部阴影</div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p><strong>兼容性说明：</strong> IE9+，Chrome,FF,Safari,Oprea</p>
<h3 id="2-3、border-image-CSS3边框图片"><a href="#2-3、border-image-CSS3边框图片" class="headerlink" title="2.3、border-image(CSS3边框图片)"></a>2.3、border-image(CSS3边框图片)</h3><p>border-image是简写属性，全部是：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">border-image-source  //背景图片源</div><div class="line">border-image-slice  //图片边框内偏移</div><div class="line">border-image-width  //图片边框的宽度</div><div class="line">border-image-outset  //边框图像区域超出边框的量</div><div class="line">border-image-repeat  //边框是否适应平铺(repeated)、铺满(rounded)、拉伸(stretched)</div></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"border-width:10px;border-image: url(http://www.w3school.com.cn/i/border.png) 10 10 round;"</span>&gt;</span></div><div class="line">  简单图片边框</div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"border-width:10px;border-image: url(http://www.w3school.com.cn/i/border.png) 10 10 round"</span>&gt;</span></div><div class="line">	简单图片边框</div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"border-width:10px;border-image: url(http://www.w3school.com.cn/i/border.png) 10 10 50 round"</span>&gt;</span></div><div class="line">  完全设置的图片边框</div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"border-width:10px;border-image: url(http://www.w3school.com.cn/i/border.png) 10 10 50 round"</span>&gt;</span></div><div class="line">完全设置的图片边框</div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p><strong>兼容性说明：</strong> Chrome,FF,Safari,Oprea<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">div</div><div class="line">&#123;</div><div class="line">  border-image:url(border.png) 30 30 round;</div><div class="line">  -moz-border-image:url(border.png) 30 30 round; /* 老的 Firefox */</div><div class="line">  -webkit-border-image:url(border.png) 30 30 round; /* Safari 和 Chrome */</div><div class="line">  -o-border-image:url(border.png) 30 30 round; /* Opera */</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="3、CSS3背景"><a href="#3、CSS3背景" class="headerlink" title="3、CSS3背景"></a>3、CSS3背景</h2><h3 id="整体兼容性"><a href="#整体兼容性" class="headerlink" title="整体兼容性"></a>整体兼容性</h3><p>以下CSS背景的特性，全部支持IE9+,FF,Chrome,Safari,Oprea</p>
<h3 id="3-1、background-size-用于规定背景图片的尺寸"><a href="#3-1、background-size-用于规定背景图片的尺寸" class="headerlink" title="3.1、background-size(用于规定背景图片的尺寸)"></a>3.1、background-size(用于规定背景图片的尺寸)</h3><p>在以前的CSS中，背景图片的大小，是由图片本身的大小决定的。在CSS3中，有一个简单的CSS样式可以设置背景图片的大小，允许我们在不同的环境中重复使用背景图片。可以以像素或百分比规定尺寸。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"</span></span></div><div class="line">  background-image:url(http://www.w3school.com.cn/i/bg_flower_small.gif);</div><div class="line">  background-size: 50% 70%;</div><div class="line">  background-repeat:no-repeat;"&gt;</div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"background-image:url(http://www.w3school.com.cn/i/bg_flower_small.gif);background-size: 50% 70%;background-repeat:no-repeat;"</span>&gt;</span></div><div class="line">	简单设置背景图大小</div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h3 id="3-2、background-origin-规定背景图片的定位区域"><a href="#3-2、background-origin-规定背景图片的定位区域" class="headerlink" title="3.2、background-origin(规定背景图片的定位区域)"></a>3.2、background-origin(规定背景图片的定位区域)</h3><p>盒子模型示意图：<br><img src="http://www.w3school.com.cn/i/background-origin.gif" alt="box"></p>
<p>background-origin属性则可以设置背景图片放置于哪个区域上（content-box,padding-box,border-box）</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"width:66px;height:125px;</span></span></div><div class="line">background-image:url(http://www.w3school.com.cn/i/bg_flower_small.gif);</div><div class="line">background-origin:content-box; </div><div class="line">padding: 20px;border:20px solid red;"&gt;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"width:66px;height:125px;</span></span></div><div class="line">background-image:url(http://www.w3school.com.cn/i/bg_flower_small.gif);</div><div class="line">background-origin:border-box; </div><div class="line">padding: 20px;border:20px solid red;"&gt;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"width:66px;height:125px;</span></span></div><div class="line">background-image:url(http://www.w3school.com.cn/i/bg_flower_small.gif);</div><div class="line">background-origin:padding-box;</div><div class="line">padding: 20px;border:20px solid red;"&gt;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<h3 id="3-3、多重背景"><a href="#3-3、多重背景" class="headerlink" title="3.3、多重背景"></a>3.3、多重背景</h3><p>可以针对标签设置多个背景，用法如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">body</span></div><div class="line">&#123; </div><div class="line">  <span class="attribute">background-image</span>:<span class="built_in">url</span>(bg_flower.gif),<span class="built_in">url</span>(bg_flower_2.gif);</div><div class="line">&#125;</div></pre></td></tr></table></figure>

    
    
    
  </section>
</article>
    </div>
  
    <div class='post-wrapper'>
      <article class="post reveal">
  <section class="meta">
    
    <h2 class="title">
      <a href="/blog/2017/02/21/Angular相关/Angular再回首(1)-Component组件/">
        Angular再回首(1)-Component组件
      </a>
    </h2>
    
    <time>
      Feb 21, 2017
    </time>
		
  </section>
  <section class="article typo">
	  <h2 id="0、再谈组件"><a href="#0、再谈组件" class="headerlink" title="0、再谈组件"></a>0、再谈组件</h2><p><code>Component(组件)</code> 在 <code>Angular1</code> 就已经有雏形了，那就是指令。在 <code>Angular2</code> 中，组件的概念被大大的强化，甚至是Angular2的核心概念。</p>
<p>在前端这么多年的演变中，组件也反哺到 <code>Angular1</code>，成为 <code>Angular1</code> 的一种重要特性，在此之前，我们仅仅可以用 <code>Directive</code> 来实现类似组件的效果。</p>
<h2 id="1、Angular组件与指令"><a href="#1、Angular组件与指令" class="headerlink" title="1、Angular组件与指令"></a>1、Angular组件与指令</h2><p>在 <code>Angular 1.5.x</code> 中，新增加了 <code>angular.component</code> 方法，用于实现组件的构造。</p>
<p>在此之前，我们可能用 <code>angular.directive</code> 来实现类似的效果。</p>
<p>这个时候我们可能就会疑惑，它们有什么区别呢？</p>
<table>
<thead>
<tr>
<th>Feature</th>
<th>Directive</th>
<th>Component</th>
</tr>
</thead>
<tbody>
<tr>
<td>bindings</td>
<td>No</td>
<td>Yes (binds to controller)</td>
</tr>
<tr>
<td>bindToController</td>
<td>Yes</td>
<td>(default: false)    No (use bindings instead)</td>
</tr>
<tr>
<td>compile function</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>controller</td>
<td>Yes</td>
<td>Yes (default function() {})</td>
</tr>
<tr>
<td>controllerAs</td>
<td>Yes</td>
<td>(default: false)    Yes (default: $ctrl)</td>
</tr>
<tr>
<td>link functions</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>multiElement</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>priority</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>require</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>restrict</td>
<td>Yes</td>
<td>No (restricted to elements only)</td>
</tr>
<tr>
<td>scope</td>
<td>Yes (default: false)</td>
<td>No (scope is always isolate)</td>
</tr>
<tr>
<td>template</td>
<td>Yes</td>
<td>Yes, injectable</td>
</tr>
<tr>
<td>templateNamespace</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>templateUrl</td>
<td>Yes</td>
<td>Yes, injectable</td>
</tr>
<tr>
<td>terminal</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>transclude</td>
<td>Yes (default: false)</td>
<td>Yes (default: false)</td>
</tr>
</tbody>
</table>
<p>更多信息，请参考 <a href="https://docs.angularjs.org/guide/component" target="_blank" rel="external">Angular 官方说明</a></p>
<p>从上表我们可以看出，对于 <code>Directive</code>，<code>Component</code> 从设计思路上更加完善，也更加纯粹。总得来说，组件显得更易理解，更简单易用。</p>
<h2 id="2、组件生命周期"><a href="#2、组件生命周期" class="headerlink" title="2、组件生命周期"></a>2、组件生命周期</h2><p>在 <code>angular.directive()</code> 中，是没有生命周期这个概念的，我们无法在指令的特定阶段插入自己的逻辑。</p>
<p>但是在 <code>angular.component()</code> 中，则是具有特定的生命周期，以方便我们进行控制。</p>
<p>生命周期如下：</p>
<ol>
<li>$onInit  – 指令初始化时执行（放置初始化代码）</li>
<li>$onChanges(changesObj)  – 组件数据变化时执行，并可获取变更对象</li>
<li>$doCheck() – 执行变更检测时执行</li>
<li>$onDestroy() – 组件释放时执行（放置清理代码）</li>
<li>$postLink() – 类似后连接函数 （一般放置dom操作，因为此时组件已经渲染好）</li>
</ol>
<p>实例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">(<span class="function">(<span class="params">angular, <span class="built_in">window</span></span>) =&gt;</span> &#123;</div><div class="line">  <span class="class"><span class="keyword">class</span> <span class="title">AlertComponent</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>() &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    $onInit() &#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'init'</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    $onChanges(changesObj)</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'change'</span>, changesObj);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    $doCheck() &#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'check'</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    $onDestroy() &#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'destroy'</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    $postLink() &#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'post link'</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  AlertComponent.$inject = []; <span class="comment">// 配置依赖项</span></div><div class="line"></div><div class="line">  angular.module(<span class="string">'components'</span>).component(<span class="string">'jAlert'</span>, &#123;</div><div class="line">    <span class="attr">templateUrl</span>: <span class="string">'components/alert/alert.html'</span>,</div><div class="line">    <span class="comment">// scope绑定语法，&lt; 单向绑定（变量），@ 单向绑定（纯字符串）， = 双向绑定，&amp; 事件绑定</span></div><div class="line">    bindings: &#123;</div><div class="line">      <span class="attr">menuData</span>: <span class="string">'&lt;'</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">controller</span>: AlertComponent,</div><div class="line">    <span class="attr">controllerAs</span>: <span class="string">'$ctrl'</span>,</div><div class="line">    <span class="attr">require</span>: <span class="string">''</span>,</div><div class="line">    <span class="attr">transclude</span>: <span class="literal">false</span></div><div class="line">  &#125;);</div><div class="line"></div><div class="line">&#125;)(<span class="built_in">window</span>.angular, <span class="built_in">window</span>);</div></pre></td></tr></table></figure>
<p>在页面使用该指令后，可以在控制台看出如下输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">init</div><div class="line">check</div><div class="line">post link</div><div class="line">N个check（脏检查）</div></pre></td></tr></table></figure>
<p>在切换路由，或者其他会删掉该组件的操作时，会看出控制台输出 <code>destroy</code>。</p>
<p>如果中途有数据变化，控制台还会输出 <code>change</code>。 </p>
<p>这就是整个组件的生命周期。</p>
<h2 id="3、属性绑定"><a href="#3、属性绑定" class="headerlink" title="3、属性绑定"></a>3、属性绑定</h2><p>在 <code>directive</code> 中，我们要获取数据，一般会采用 <code>$scope</code> 传参，或者通过link函数来捕获参数。</p>
<p>在新的组件申明中，我们只需要通过 <code>bindings</code> 就可以实现复杂的参数绑定。</p>
<p>简单思考下，我们可能需要哪些绑定呢？</p>
<ol>
<li>双向绑定 （双向）</li>
<li>单向绑定变量 （从外到内）</li>
<li>单向绑定属性（字符串）（从外到内）</li>
<li>输出绑定 （从内到外）</li>
</ol>
<p>在组件的 <code>bindings</code> 属性中，我们也刚好有四种语法，来一一对应这四种绑定。</p>
<p>具体写法如下： </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">bindings: &#123;</div><div class="line">  <span class="attr">model</span>: <span class="string">'='</span>,  <span class="comment">// 双向绑定</span></div><div class="line">  title: <span class="string">'@'</span>,  <span class="comment">// 单项绑定字符串（直接用组件上的属性值）</span></div><div class="line">  key: <span class="string">'&lt;'</span>,  <span class="comment">// 单项绑定变量，取到属性值，然后返回$scope[属性值]</span></div><div class="line">  onClick: <span class="string">'&amp;'</span>  <span class="comment">// 输出绑定，执行外部函数</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>假设组件标签为 <code>&lt;j-test&gt;</code>，那么用法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$scope = &#123;</div><div class="line">  <span class="attr">model</span>: <span class="string">'1'</span>,</div><div class="line">  <span class="attr">key</span>: <span class="string">'abc'</span>,</div><div class="line">  <span class="attr">onClick</span>: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line"></div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">j-test</span> <span class="attr">model</span>=<span class="string">"model"</span> <span class="attr">key</span>=<span class="string">"key"</span> <span class="attr">title</span>=<span class="string">"Title"</span> <span class="attr">on-click</span>=<span class="string">"onClick()"</span>&gt;</span><span class="tag">&lt;/<span class="name">j-test</span>&gt;</span></div></pre></td></tr></table></figure>
<p>此时，我们在组件中，就能获取到对应的值： </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">model</span>: <span class="number">1</span>, <span class="comment">// 从scope中取</span></div><div class="line">  key: <span class="string">'abc'</span>, <span class="comment">// 从scope中取</span></div><div class="line">  title: <span class="string">'Title'</span>, <span class="comment">// 直接用string</span></div><div class="line">  onClick: fn <span class="comment">// 执行该onClick会触发外部函数$scope.onClick</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>注意：关于输出函数传递参数，需要有特定的写法（一定要注意！！！）</strong></p>
<p><em>在组件中的写法</em></p>
<p>在组件中，要给该函数传参，必须使用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.onClick(&#123;</div><div class="line">  <span class="attr">param1</span>: <span class="string">'xxx'</span>,</div><div class="line">  <span class="attr">param2</span>: <span class="string">'BBB'</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>的写法，并建议参数名使用 <code>$</code> 开头，如：<code>$event</code>。</p>
<p><em>在组件绑定中的写法</em></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">j-test</span> <span class="attr">model</span>=<span class="string">"model"</span> <span class="attr">key</span>=<span class="string">"key"</span> <span class="attr">title</span>=<span class="string">"Title"</span> <span class="attr">on-click</span>=<span class="string">"onClick(param1, param2)"</span>&gt;</span><span class="tag">&lt;/<span class="name">j-test</span>&gt;</span></div></pre></td></tr></table></figure>
<p>注意onClick的写法，里面的参数名称，必须和组件中参数对象中的key匹配。</p>
<h2 id="4、给组件设定外部HTML"><a href="#4、给组件设定外部HTML" class="headerlink" title="4、给组件设定外部HTML"></a>4、给组件设定外部HTML</h2><p>在使用组件过程中，我相信很容易遇到需要使用外部html的组件，如 <code>Tabs, Panel</code> 等，那我们给组件内部传入自定义的HTML呢？</p>
<p>这个时候，我们可以使用 <code>ng-transclude</code></p>
<h3 id="4-1、传递单个HTML片段"><a href="#4-1、传递单个HTML片段" class="headerlink" title="4.1、传递单个HTML片段"></a>4.1、传递单个HTML片段</h3><p>首先，主要在注册组件时，开启 <code>transclude</code>（设置transclude为true），然后我们就可以在组件html中，设定占位符，有如下两种方式：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 占位符1 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ng-transclude</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 占位符2 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">ng-transclude</span>&gt;</span><span class="tag">&lt;/<span class="name">ng-transclude</span>&gt;</span></div></pre></td></tr></table></figure>
<p>然后在使用组件的地方，就可以直接把要使用的HTML放在组件标记中，如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">j-test</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>我会被传递到主键内部<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">j-test</span>&gt;</span></div></pre></td></tr></table></figure>
<h3 id="4-2、传递多个HTML片段"><a href="#4-2、传递多个HTML片段" class="headerlink" title="4.2、传递多个HTML片段"></a>4.2、传递多个HTML片段</h3><p>以上，我们知道了如何传递单个HTML片段，但传递多个HTML片段也是非常有必要的，如 <code>Dialog</code>组件，<br>我们很可能会传递 <code>dialog-header</code>, <code>dialog-body</code> 等等，那此时又应如何呢？</p>
<p>这个场景，我们可以借助 <code>ng-transclude</code> 的 <code>slot</code> 功能实现，</p>
<p>首先，是占位符的变化，如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 占位符1 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ng-transclude</span>=<span class="string">"header"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ng-transclude</span>=<span class="string">"body"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 占位符2 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">ng-transclude</span> <span class="attr">ng-transclude-slot</span>=<span class="string">"header"</span>&gt;</span><span class="tag">&lt;/<span class="name">ng-transclude</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">ng-transclude</span> <span class="attr">ng-transclude-slot</span>=<span class="string">"body"</span>&gt;</span><span class="tag">&lt;/<span class="name">ng-transclude</span>&gt;</span></div></pre></td></tr></table></figure>
<p>其次是组件配置的变化，因为有多个 <code>transclude</code>，那么仅仅设置为 <code>true</code>，就不太能满足需求了。<br>需要修改如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">transclude: &#123;</div><div class="line">  <span class="attr">header</span>: <span class="string">'?panelHeader'</span>, <span class="comment">// panelHeader表示内部标签，?表示是可选的</span></div><div class="line">  body: <span class="string">'panelBody'</span> <span class="comment">// 没有问号，表示该节点必选</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来，就应该是调用时的改变，调用如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">j-panel</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">panel-header</span>&gt;</span></div><div class="line">    我是Panel Header（可选）</div><div class="line">  <span class="tag">&lt;/<span class="name">panel-header</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">panel-body</span>&gt;</span></div><div class="line">    我是Panel Body（必须）</div><div class="line">  <span class="tag">&lt;/<span class="name">panel-body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">j-panel</span>&gt;</span></div></pre></td></tr></table></figure>
<h2 id="5、组件-require"><a href="#5、组件-require" class="headerlink" title="5、组件 require"></a>5、组件 <code>require</code></h2><p>同 <code>Directive</code> 一样，组件也可以相互依赖，只需要在注册组件时，设置require属性即可，写法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>: &#123;</div><div class="line">  <span class="attr">componentCtrl</span>: <span class="string">'^parentComponent'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="6、小结"><a href="#6、小结" class="headerlink" title="6、小结"></a>6、小结</h2><p>新增的 <code>angular.component</code> 就是这么一个东西，比起 <code>directive</code> 更加纯粹，更加强大，更加易用。<br>建议在后续使用中，多多尝试该方式。</p>


    
    
    
  </section>
</article>
    </div>
  
    <div class='post-wrapper'>
      <article class="post reveal">
  <section class="meta">
    
    <h2 class="title">
      <a href="/blog/2017/02/21/Canvas学习札记/01_初识Canvas，绘制简单图形/">
        01_初识Canvas，绘制简单图形
      </a>
    </h2>
    
    <time>
      Feb 21, 2017
    </time>
		
  </section>
  <section class="article typo">
	  <h2 id="0、关于Canvas"><a href="#0、关于Canvas" class="headerlink" title="0、关于Canvas"></a>0、关于Canvas</h2><p><code>&lt;canvas&gt;</code> 是HTML5新增的一个标签，用于定义图形，比如图表和其他图像。</p>
<p><code>&lt;canvas&gt;</code> 标签只是图形容器，必须要使用脚本来绘制图形。</p>
<p>一句话概括就是：<code>&lt;canvas&gt;</code> 是浏览器上的画图，允许你通过js自由作画。</p>
<h3 id="Canvas和SVG与VML的不同"><a href="#Canvas和SVG与VML的不同" class="headerlink" title="Canvas和SVG与VML的不同"></a>Canvas和SVG与VML的不同</h3><p><code>&lt;canvas&gt;</code> 有一个基于JS的绘图API，它本身并不会绘制图形。SVG和VML都是用一个XML文档来描述图形。</p>
<p>虽然它们在功能上基本相同，但是从表面上来看，它们非常不同。SVG和VML绘图易于编辑，只需要从描述中修改元素属性。而Canvas想移除元素，往往需要擦掉绘图重新绘制它。</p>
<h3 id="Canvas兼容HTML5标准属性和事件"><a href="#Canvas兼容HTML5标准属性和事件" class="headerlink" title="Canvas兼容HTML5标准属性和事件"></a>Canvas兼容HTML5标准属性和事件</h3><p><code>&lt;canvas&gt;</code> 作为一个HTML的新标签，标准的HTML属性和事件它都支持。比如可以设置 <code>title、style、class</code> 等属性，也可以使用诸如 <code>onclick</code> 等事件。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Canvas Test<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></div><div class="line">    <span class="selector-tag">body</span>&#123;</div><div class="line">      <span class="attribute">text-align</span>: center;</div><div class="line">    &#125;</div><div class="line">    <span class="selector-class">.c1</span>&#123;</div><div class="line">      <span class="attribute">border</span>: <span class="number">1px</span> solid red;</div><div class="line">      <span class="attribute">height</span>: <span class="number">600px</span>;</div><div class="line">      <span class="attribute">width</span>: <span class="number">800px</span>;</div><div class="line">    &#125;</div><div class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"c1"</span> <span class="attr">onclick</span>=<span class="string">"alert('abc')"</span> <span class="attr">class</span>=<span class="string">"c1"</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<h2 id="1、使用Canvas"><a href="#1、使用Canvas" class="headerlink" title="1、使用Canvas"></a>1、使用Canvas</h2><p>要使用<code>canvas</code>，首先，我们先得html中加入canvas标签。最好，再加上一个id属性（也可以不加，只是查找该元素要稍微麻烦点）。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"c1"</span> <span class="attr">onclick</span>=<span class="string">"alert('abc')"</span> <span class="attr">class</span>=<span class="string">"c1"</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">    <span class="keyword">var</span> c1 =<span class="built_in">document</span>.getElementById(<span class="string">'c1'</span>);</div><div class="line">    <span class="comment">// 如果不用id属性，我们可以用如下方式来获取canvas对象</span></div><div class="line">    <span class="comment">//var c1 = document.getElementsByTagName('canvas')[0]; </span></div><div class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line">...</div></pre></td></tr></table></figure>
<p>在获取到 <code>canvas</code> 元素之后，我们需要通过 <code>getContext(contextID)</code> 方法获取到画布。</p>
<p>当前 <code>contextID</code>的值仅仅可以用’2d’，在未来，可能会允许传递’3d’，来进行三维绘图。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"c1"</span> <span class="attr">onclick</span>=<span class="string">"alert('abc')"</span> <span class="attr">class</span>=<span class="string">"c1"</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">    <span class="keyword">var</span> c1 =<span class="built_in">document</span>.getElementById(<span class="string">'c1'</span>);</div><div class="line">    <span class="comment">// 如果不用id属性，我们可以用如下方式来获取canvas对象</span></div><div class="line">    <span class="comment">//var c1 = document.getElementsByTagName('canvas')[0];</span></div><div class="line">    <span class="keyword">var</span> context = c1.getContext(<span class="string">'2d'</span>);</div><div class="line">    <span class="built_in">console</span>.log(context); <span class="comment">//可以看到context是一个CanvasRenderingContext2D对象</span></div><div class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line">...</div></pre></td></tr></table></figure>
<p><code>CanvasRenderingContext2D</code> 对象实现了一个画布所使用的大多数方法。现在我们就需要对它来进行使用，将图像绘制到浏览器上。</p>
<h3 id="1-1、绘制矩形"><a href="#1-1、绘制矩形" class="headerlink" title="1.1、绘制矩形"></a>1.1、绘制矩形</h3><p>关于矩形的绘制，主要有三个方法：</p>
<ul>
<li>fillRect(x, y, width, height) 用于填充矩形</li>
<li>strokeRect(x, y, width, height) 用于绘制矩形边框</li>
<li>clearRect(x, y, width, height) 用于清空矩形区域（设置矩形区域为空白）</li>
</ul>
<p>其中 <code>x,y</code>表示从那个点开始绘制。<code>width,height</code> 表示矩形的宽度和高度。</p>
<p>要设置矩形的填充颜色，需要通过 <code>fillStyle</code> 来控制，支持 <code>&#39;red&#39;, &#39;#fff&#39;, &#39;rgb(10,10,10)&#39;, &#39;rgba(10,10,10,10,0.5)&#39;</code>等多种颜色属性。</p>
<p>要设置矩形的边框颜色，需要通过 <code>strokeStyle</code> 来控制，属性值和 <code>fillStyle</code> 一致。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line"><span class="comment">//绘制红色矩形</span></div><div class="line">context.fillStyle = <span class="string">'red'</span>; </div><div class="line">context.fillRect(<span class="number">10</span>,<span class="number">10</span>,<span class="number">100</span>,<span class="number">100</span>);</div><div class="line"></div><div class="line"><span class="comment">//绘制蓝色矩形框</span></div><div class="line">context.strokeStyle = <span class="string">'blue'</span>;</div><div class="line">context.strokeRect(<span class="number">150</span>,<span class="number">150</span>,<span class="number">100</span>,<span class="number">100</span>);</div><div class="line"></div><div class="line"><span class="comment">//清空矩形区域（设置矩形区域为空白）</span></div><div class="line">context.clearRect(<span class="number">100</span>,<span class="number">100</span>,<span class="number">100</span>,<span class="number">100</span>);</div><div class="line">...</div></pre></td></tr></table></figure>
<h3 id="1-2、绘制线条"><a href="#1-2、绘制线条" class="headerlink" title="1.2、绘制线条"></a>1.2、绘制线条</h3><p>我们可以通过 <code>lineTo(x, y)</code> 绘制直线。两点成直线，绘制直线需要两个点，所以我们需要先设置一个起点，一般来说，我们使用 <code>moveTo(x, y)</code> 设置笔触的位置。当然，你也可以用 <code>lineTo(x, y)</code> 来设置一个笔触点。</p>
<p>在没有设置笔触的场景下，以下两段代码的效果完全一致：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//画线，设置起点。</span></div><div class="line">context.moveTo(<span class="number">200</span>, <span class="number">200</span>);</div><div class="line"><span class="comment">//设置轨迹</span></div><div class="line">context.lineTo(<span class="number">500</span>,<span class="number">500</span>);</div><div class="line"><span class="comment">//画线</span></div><div class="line">context.stroke();</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//画线，设置起点。</span></div><div class="line">context.lineTo(<span class="number">200</span>, <span class="number">200</span>);</div><div class="line"><span class="comment">//设置轨迹</span></div><div class="line">context.lineTo(<span class="number">500</span>,<span class="number">500</span>);</div><div class="line"><span class="comment">//画线</span></div><div class="line">context.stroke();</div></pre></td></tr></table></figure>
<p><strong>一般来说，我们会在 <code>canvas</code> 初始化或者 <code>beginPath()</code> 调用后，通过 <code>moveTo(x, y)</code> 来设置一个初始笔触点。</strong></p>
<p>要同时绘制多个线条，我们应该通过 <code>beginPath()</code> 来建立路径。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//用线条绘制了一个矩形</span></div><div class="line">context.beginPath();</div><div class="line">context.moveTo(<span class="number">400</span>, <span class="number">400</span>);</div><div class="line">context.lineTo(<span class="number">450</span>, <span class="number">400</span>);</div><div class="line">context.lineTo(<span class="number">450</span>, <span class="number">450</span>);</div><div class="line">context.lineTo(<span class="number">400</span>, <span class="number">450</span>);</div><div class="line">context.closePath();</div><div class="line"><span class="comment">//真实的绘图</span></div><div class="line">context.stroke();</div></pre></td></tr></table></figure>
<p>看了以上的代码，可能会有一个疑惑，为什么仅仅三个线条就构成了一个矩形呢？</p>
<p>原因在于当调用 <code>closePath()</code> 的时候，会把最后的笔触点和最开始的笔触点连接在一起，这个时候也就构成了第四条直线。</p>
<p> <strong>注意：当前路径为空，即调用beginPath()之后，或者canvas刚建的时候，第一条路径构造命令通常被视为是moveTo（），无论最后的是什么。出于这个原因，你几乎总是要在设置路径之后专门指定你的起始位置。</strong></p>
<p> <strong>闭合路径 <code>closePath()</code>,不是必需的。这个方法会通过绘制一条从当前点到开始点的直线来闭合图形。如果图形是已经闭合了的，即当前点为开始点，该函数什么也不做。</strong></p>
<p> <strong>当你调用 <code>fill()</code> 函数时，所有没有闭合的形状都会自动闭合，所以你不需要调用 <code>closePath()</code> 函数。但是调用stroke()时不会自动闭合。</strong></p>
<p>再来填充一个梯形玩玩：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">context.beginPath();</div><div class="line">context.moveTo(<span class="number">100</span>, <span class="number">400</span>);</div><div class="line">context.lineTo(<span class="number">200</span>, <span class="number">400</span>);</div><div class="line">context.lineTo(<span class="number">250</span>, <span class="number">500</span>);</div><div class="line">context.lineTo(<span class="number">50</span>, <span class="number">500</span>);</div><div class="line">context.fill();</div></pre></td></tr></table></figure>
<h3 id="1-3、绘制矩形线条"><a href="#1-3、绘制矩形线条" class="headerlink" title="1.3、绘制矩形线条"></a>1.3、绘制矩形线条</h3><p>矩形线条是一个比较常用的图形，所以提供了一个简单的方法来直接绘制：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//绘制矩形线条</span></div><div class="line">context.beginPath();</div><div class="line">context.rect(<span class="number">700</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">50</span>);</div><div class="line">context.stroke();</div><div class="line">context.fillStyle = <span class="string">'red'</span>;</div><div class="line">context.fill();</div></pre></td></tr></table></figure>
<h3 id="1-4、绘制圆弧"><a href="#1-4、绘制圆弧" class="headerlink" title="1.4、绘制圆弧"></a>1.4、绘制圆弧</h3><p>绘制圆弧或者圆的时候，我们可以使用如下方法：</p>
<ul>
<li>arc(x, y, radius, startAngle, endAngle, anticlockwise) 画一个以（x,y）为圆心的以radius为半径的圆弧（圆），从startAngle开始到endAngle结束，按照anticlockwise给定的方向（默认为顺时针）来生成。</li>
<li>arcTo(x1, y1, x2, y2, radius) 根据给定的控制点和半径画一段圆弧，再以直线连接两个控制点。</li>
</ul>
<p>anticlockwise为true则表示逆时针绘制。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//绘制圆弧</span></div><div class="line">context.beginPath();</div><div class="line">context.arc(<span class="number">550</span>, <span class="number">150</span>, <span class="number">100</span>, getRadian(<span class="number">90</span>) , getRadian(<span class="number">360</span>), <span class="literal">false</span>);</div><div class="line">context.stroke();</div><div class="line">context.beginPath();</div><div class="line">context.arc(<span class="number">550</span>, <span class="number">150</span>, <span class="number">100</span>, <span class="number">0</span>, getRadian(<span class="number">90</span>), <span class="literal">false</span>);</div><div class="line">context.fill();</div></pre></td></tr></table></figure>
<p>以上代码，绘制了两个弧形，一个空心，一个实心。一般再绘制圆弧的时候就不要执行 <code>moveTo(x, y)</code>，否则绘制终点会被连接到这个触点上。</p>
<p><strong>注意：在arc函数中，<code>startAngle</code> 和 <code>endAngle</code> 属性值都是弧度，而不是我们所熟知的角度。所以我们一个一个角度转换为弧度的函数，如下：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRadian</span>(<span class="params">degrees<span class="regexp">/*角度值*/</span></span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> (<span class="built_in">Math</span>.PI / <span class="number">180</span>) * degrees;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>arcTo没吃透，暂时描述不出来，先简单看看示例：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//绘制圆弧（必须要设定起始点）</span></div><div class="line">context.beginPath();</div><div class="line">context.fillRect(<span class="number">600</span>, <span class="number">400</span>, <span class="number">10</span>, <span class="number">10</span>);</div><div class="line">context.fillRect(<span class="number">700</span>, <span class="number">500</span>, <span class="number">10</span>, <span class="number">10</span>);</div><div class="line">context.fillStyle = <span class="string">'blue'</span>;</div><div class="line">context.fillRect(<span class="number">700</span>, <span class="number">400</span>, <span class="number">10</span>, <span class="number">10</span>);</div><div class="line"></div><div class="line">context.beginPath();</div><div class="line">context.moveTo(<span class="number">700</span>, <span class="number">400</span>);</div><div class="line">context.arcTo(<span class="number">600</span>, <span class="number">600</span>, <span class="number">700</span>, <span class="number">700</span>, <span class="number">500</span>);</div><div class="line">context.stroke();</div></pre></td></tr></table></figure>
<h2 id="2、其他"><a href="#2、其他" class="headerlink" title="2、其他"></a>2、其他</h2><h3 id="2-1、canvas检查支持性"><a href="#2-1、canvas检查支持性" class="headerlink" title="2.1、canvas检查支持性"></a>2.1、canvas检查支持性</h3><p>如果仅仅需要在UI上体现，那么我们可以在 <code>&lt;canvas&gt;</code> 标签内部放置元素，如果浏览器不支持 <code>&lt;canvas&gt;</code> 标签，那么内部的元素就会被浏览器解析，而显示出来。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"stockGraph"</span> <span class="attr">width</span>=<span class="string">"150"</span> <span class="attr">height</span>=<span class="string">"150"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Canvas not be support.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></div></pre></td></tr></table></figure>
<p>除此之外，我们也可以用js的方式来检查。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> c1 = <span class="built_in">document</span>.getElementById(<span class="string">'c1'</span>);</div><div class="line"><span class="comment">//如果canvas元素没有getContext方法，那么就证明浏览器不支持canvas。</span></div><div class="line"><span class="keyword">if</span>(!c1.getContext)&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'Canvas not be support.'</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-2、canvas的width和height属性"><a href="#2-2、canvas的width和height属性" class="headerlink" title="2.2、canvas的width和height属性"></a>2.2、canvas的width和height属性</h3><p><code>&lt;canvas&gt;</code> 对象有两个比较特别的属性，<code>width、height</code>，这两者用于控制画布的大小，width的默认值是300，height的默认值为150。<strong>当这两个属性值有变化时，在该画布上已经完成的任何绘图都会擦除掉。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> c1 = <span class="built_in">document</span>.getElementById(<span class="string">'c1'</span>);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'default width:'</span>, c1.width, <span class="string">'; default height:'</span>, c1.height);</div><div class="line">c1.width = <span class="number">500</span>;</div><div class="line">c1.height = <span class="number">600</span>;</div></pre></td></tr></table></figure>
<p><code>&lt;canvas&gt;</code> 的的height和width属性如果和用css设置的height和width样式不一致，那么就可能会产生扭曲。</p>
<h3 id="2-3、来个好玩的，画个桃心"><a href="#2-3、来个好玩的，画个桃心" class="headerlink" title="2.3、来个好玩的，画个桃心"></a>2.3、来个好玩的，画个桃心</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawHeart</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  context.fillStyle = <span class="string">'purple'</span>;</div><div class="line">  <span class="comment">//三次曲线</span></div><div class="line">  context.beginPath();</div><div class="line">  context.moveTo(<span class="number">75</span>, <span class="number">40</span>);</div><div class="line">  context.bezierCurveTo(<span class="number">75</span>, <span class="number">37</span>, <span class="number">70</span>, <span class="number">25</span>, <span class="number">50</span>, <span class="number">25</span>);</div><div class="line">  context.bezierCurveTo(<span class="number">20</span>, <span class="number">25</span>, <span class="number">20</span>, <span class="number">62.5</span>, <span class="number">20</span>, <span class="number">62.5</span>);</div><div class="line">  context.bezierCurveTo(<span class="number">20</span>, <span class="number">80</span>, <span class="number">40</span>, <span class="number">102</span>, <span class="number">75</span>, <span class="number">120</span>);</div><div class="line">  context.bezierCurveTo(<span class="number">110</span>, <span class="number">102</span>, <span class="number">130</span>, <span class="number">80</span>, <span class="number">130</span>, <span class="number">62.5</span>);</div><div class="line">  context.bezierCurveTo(<span class="number">130</span>, <span class="number">62.5</span>, <span class="number">130</span>, <span class="number">25</span>, <span class="number">100</span>, <span class="number">25</span>);</div><div class="line">  context.bezierCurveTo(<span class="number">85</span>, <span class="number">25</span>, <span class="number">75</span>, <span class="number">37</span>, <span class="number">75</span>, <span class="number">40</span>);</div><div class="line">  context.fill();</div><div class="line">&#125;</div><div class="line">drawHeart();</div><div class="line"><span class="string">``</span><span class="string">` </span></div><div class="line"></div><div class="line">### 2.4 附上测试代码</div><div class="line"></div><div class="line">`<span class="string">``</span>html</div><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line"><span class="xml"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Canvas Test<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></div><div class="line">    <span class="selector-tag">body</span> &#123;</div><div class="line">      <span class="attribute">text-align</span>: center;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="selector-class">.c1</span> &#123;</div><div class="line">      <span class="attribute">border</span>: <span class="number">1px</span> solid red;</div><div class="line">      <span class="attribute">height</span>: <span class="number">600px</span>;</div><div class="line">      <span class="attribute">width</span>: <span class="number">800px</span>;</div><div class="line">    &#125;</div><div class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"c1"</span> <span class="attr">onclick</span>=<span class="string">"alert('abc')"</span> <span class="attr">class</span>=<span class="string">"c1"</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"main.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> c1 = <span class="built_in">document</span>.getElementById(<span class="string">'c1'</span>);</div><div class="line"><span class="comment">// 如果不用id属性，我们可以用如下方式来获取canvas对象</span></div><div class="line"><span class="comment">//var c1 = document.getElementsByTagName('canvas')[0];</span></div><div class="line">c1.width = <span class="number">800</span>;</div><div class="line">c1.height = <span class="number">600</span>;</div><div class="line"><span class="keyword">var</span> context = c1.getContext(<span class="string">'2d'</span>);</div><div class="line"><span class="built_in">console</span>.log(context); <span class="comment">//可以看到context是一个CanvasRenderingContext2D对象</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRadian</span>(<span class="params">degrees<span class="regexp">/*角度值*/</span></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> (<span class="built_in">Math</span>.PI / <span class="number">180</span>) * degrees;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//绘制红色矩形</span></div><div class="line">context.fillStyle = <span class="string">'red'</span>;</div><div class="line">context.fillRect(<span class="number">10</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">100</span>);</div><div class="line"></div><div class="line"><span class="comment">//绘制蓝色矩形框</span></div><div class="line">context.strokeStyle = <span class="string">'blue'</span>;</div><div class="line">context.strokeRect(<span class="number">150</span>, <span class="number">150</span>, <span class="number">100</span>, <span class="number">100</span>);</div><div class="line"></div><div class="line"><span class="comment">//清空矩形区域（设置矩形区域为空白）</span></div><div class="line">context.clearRect(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>);</div><div class="line"></div><div class="line"><span class="comment">//画线，设置起点。</span></div><div class="line">context.moveTo(<span class="number">200</span>, <span class="number">200</span>);</div><div class="line"><span class="comment">//设置轨迹</span></div><div class="line">context.lineTo(<span class="number">500</span>, <span class="number">500</span>);</div><div class="line"><span class="comment">//画线</span></div><div class="line">context.stroke();</div><div class="line"></div><div class="line"><span class="comment">//绘制空心矩形</span></div><div class="line">context.beginPath();</div><div class="line">context.moveTo(<span class="number">400</span>, <span class="number">400</span>);</div><div class="line">context.lineTo(<span class="number">450</span>, <span class="number">400</span>);</div><div class="line">context.lineTo(<span class="number">450</span>, <span class="number">450</span>);</div><div class="line">context.lineTo(<span class="number">400</span>, <span class="number">450</span>);</div><div class="line">context.closePath();</div><div class="line">context.stroke();</div><div class="line"></div><div class="line"><span class="comment">//绘制实心梯形</span></div><div class="line">context.beginPath();</div><div class="line">context.moveTo(<span class="number">100</span>, <span class="number">400</span>);</div><div class="line">context.lineTo(<span class="number">200</span>, <span class="number">400</span>);</div><div class="line">context.lineTo(<span class="number">250</span>, <span class="number">500</span>);</div><div class="line">context.lineTo(<span class="number">50</span>, <span class="number">500</span>);</div><div class="line">context.fill();</div><div class="line"></div><div class="line"><span class="comment">//绘制圆弧</span></div><div class="line">context.beginPath();</div><div class="line">context.arc(<span class="number">550</span>, <span class="number">150</span>, <span class="number">100</span>, getRadian(<span class="number">90</span>), getRadian(<span class="number">360</span>), <span class="literal">true</span>);</div><div class="line">context.stroke();</div><div class="line">context.beginPath();</div><div class="line">context.arc(<span class="number">550</span>, <span class="number">150</span>, <span class="number">100</span>, <span class="number">0</span>, getRadian(<span class="number">90</span>), <span class="literal">true</span>);</div><div class="line">context.stroke();</div><div class="line"></div><div class="line"><span class="comment">//绘制圆弧（必须要设定起始点）</span></div><div class="line">context.beginPath();</div><div class="line">context.fillRect(<span class="number">600</span>, <span class="number">400</span>, <span class="number">10</span>, <span class="number">10</span>);</div><div class="line">context.fillRect(<span class="number">700</span>, <span class="number">500</span>, <span class="number">10</span>, <span class="number">10</span>);</div><div class="line">context.fillStyle = <span class="string">'blue'</span>;</div><div class="line">context.fillRect(<span class="number">700</span>, <span class="number">400</span>, <span class="number">10</span>, <span class="number">10</span>);</div><div class="line"></div><div class="line">context.beginPath();</div><div class="line">context.moveTo(<span class="number">700</span>, <span class="number">400</span>);</div><div class="line">context.arcTo(<span class="number">600</span>, <span class="number">600</span>, <span class="number">700</span>, <span class="number">700</span>, <span class="number">500</span>);</div><div class="line">context.stroke();</div><div class="line"></div><div class="line"><span class="comment">//绘制矩形线条</span></div><div class="line">context.beginPath();</div><div class="line">context.rect(<span class="number">700</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">50</span>);</div><div class="line">context.stroke();</div><div class="line">context.fillStyle = <span class="string">'red'</span>;</div><div class="line">context.fill();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawHeart</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  context.fillStyle = <span class="string">'purple'</span>;</div><div class="line">  <span class="comment">//三次曲线</span></div><div class="line">  context.beginPath();</div><div class="line">  context.moveTo(<span class="number">75</span>, <span class="number">40</span>);</div><div class="line">  context.bezierCurveTo(<span class="number">75</span>, <span class="number">37</span>, <span class="number">70</span>, <span class="number">25</span>, <span class="number">50</span>, <span class="number">25</span>);</div><div class="line">  context.bezierCurveTo(<span class="number">20</span>, <span class="number">25</span>, <span class="number">20</span>, <span class="number">62.5</span>, <span class="number">20</span>, <span class="number">62.5</span>);</div><div class="line">  context.bezierCurveTo(<span class="number">20</span>, <span class="number">80</span>, <span class="number">40</span>, <span class="number">102</span>, <span class="number">75</span>, <span class="number">120</span>);</div><div class="line">  context.bezierCurveTo(<span class="number">110</span>, <span class="number">102</span>, <span class="number">130</span>, <span class="number">80</span>, <span class="number">130</span>, <span class="number">62.5</span>);</div><div class="line">  context.bezierCurveTo(<span class="number">130</span>, <span class="number">62.5</span>, <span class="number">130</span>, <span class="number">25</span>, <span class="number">100</span>, <span class="number">25</span>);</div><div class="line">  context.bezierCurveTo(<span class="number">85</span>, <span class="number">25</span>, <span class="number">75</span>, <span class="number">37</span>, <span class="number">75</span>, <span class="number">40</span>);</div><div class="line">  context.fill();</div><div class="line">&#125;</div><div class="line">drawHeart();</div></pre></td></tr></table></figure>

    
    
    
  </section>
</article>
    </div>
  
    <div class='post-wrapper'>
      <article class="post reveal">
  <section class="meta">
    
    <h2 class="title">
      <a href="/blog/2017/02/21/DotNetCore/01_Dotnet Core尝鲜/">
        01_Dotnet Core尝鲜
      </a>
    </h2>
    
    <time>
      Feb 21, 2017
    </time>
		
  </section>
  <section class="article typo">
	  <h1 id="0、About-Dotnet-Core"><a href="#0、About-Dotnet-Core" class="headerlink" title="0、About Dotnet Core"></a>0、About Dotnet Core</h1><p><code>Dotnet Core</code> 是新一代的 <code>.Net Framework</code>，是一个具有跨平台能力的应用程序开发框架。它本身是由多个子项目组成的。包括 <code>Core Fx</code>、<code>Core CLR</code>、<code>.Net Compiler Platform</code> 等等。</p>
<p><code>Dotnet Core</code> 具有高效的开发效率，高性能和跨平台能力，是 <code>.Net平台</code> 的一次大跃进。</p>
<h1 id="1、尝试-Dotnet-Core"><a href="#1、尝试-Dotnet-Core" class="headerlink" title="1、尝试 Dotnet Core"></a>1、尝试 Dotnet Core</h1><h3 id="1-1、Install"><a href="#1-1、Install" class="headerlink" title="1.1、Install"></a>1.1、Install</h3><p><code>Dotnet Core</code> 从发布至今，已经有很长一段时间了。期间也发布了beta，rc等版本。就在前不久，正式版也已经发布了，经过了之前大量的api变化，现在core已经非常稳定了。这个阶段，已经值得我们去尝试、去使用它了。</p>
<p>要尝试 <code>Dotnet core</code>, 我们先进入它的网站<a href="https://dotnet.github.io/" target="_blank" rel="external">https://dotnet.github.io/</a>，<a href="https://www.microsoft.com/net/core#windows" target="_blank" rel="external">https://www.microsoft.com/net/core#windows</a> 。</p>
<p>根据我们的操作系统版本，选择合适的开发包。我这里是Windows下开发，理所当然的下载 <a href="https://go.microsoft.com/fwlink/?LinkID=809122" target="_blank" rel="external">the .NET Core SDK for Windows</a> 。</p>
<p>安装好之后，在命令行输入 <code>dotnet --version</code> ，如果输出了版本信息，那就表示安装成功了。</p>
<p><strong>注意：如果之前尝试过Dotnet Core，请保证在安装最新版本的SDK之前，先卸载干净。</strong></p>
<h3 id="1-2、Console-App"><a href="#1-2、Console-App" class="headerlink" title="1.2、Console App"></a>1.2、Console App</h3><p>在安装好SDK之后，我们就可以开始创建项目了。新建一个文件夹，进入控制台，执行 <code>dotnet new</code>，即可看到在目录下生成了如下文件结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Program.cs</div><div class="line">project.json</div></pre></td></tr></table></figure>
<p>内容如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Program.cs</span></div><div class="line"></div><div class="line"><span class="keyword">using</span> System;</div><div class="line"></div><div class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApplication</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></div><div class="line">    &#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></div><div class="line">        &#123;</div><div class="line">            Console.WriteLine(<span class="string">"Hello World!"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">//project.json</div><div class="line"></div><div class="line">&#123;</div><div class="line">  "version": "1.0.0-*",</div><div class="line">  "buildOptions": &#123;</div><div class="line">    "debugType": "portable",</div><div class="line">    "emitEntryPoint": true</div><div class="line">  &#125;,</div><div class="line">  "dependencies": &#123;&#125;,</div><div class="line">  "frameworks": &#123;</div><div class="line">    "netcoreapp1.0": &#123;</div><div class="line">      "dependencies": &#123;</div><div class="line">        "Microsoft.NETCore.App": &#123;</div><div class="line">          "type": "platform",</div><div class="line">          "version": "1.0.0"</div><div class="line">        &#125;</div><div class="line">      &#125;,</div><div class="line">      "imports": "dnxcore50"</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此时我们可以通过 <code>dotnet restore</code> 来安装依赖。</p>
<p><strong>注意：就算project.json中的dependencies属性为空对象，我们也要执行 <code>dotnet restore</code>，该命令会生成project.lock.json文件。</strong></p>
<p><strong>注意2：如果我们的网络环境的走的代理，那么可能会在安装依赖这个步骤遇到407错误，此时我们需要配置Nuget的代理设置，找到 <code>%AppData%/NuGet/NuGet.Config</code> 文件，然后添加如下配置项：</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">config</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">add</span> <span class="attr">key</span>=<span class="string">"http_proxy"</span> <span class="attr">value</span>=<span class="string">"s1firewall:8080"</span> /&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">add</span> <span class="attr">key</span>=<span class="string">"http_proxy.user"</span> <span class="attr">value</span>=<span class="string">"jh3r"</span> /&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">add</span> <span class="attr">key</span>=<span class="string">"http_proxy.password"</span> <span class="attr">value</span>=<span class="string">"xxx"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">config</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></div></pre></td></tr></table></figure>
<p><strong>通过这样的设置，就可以使用代理来安装依赖了。</strong></p>
<p>当我们安装好依赖之后，通过执行 <code>dotnet run</code> 来编译和运行我们的程序，此时可以在控制台看到输出： <code>Hello World!</code></p>
<p>以上，就是我们使用 <code>Dotnet Core</code> 的一般步骤了。</p>
<h3 id="1-3、Web-App"><a href="#1-3、Web-App" class="headerlink" title="1.3、Web App"></a>1.3、Web App</h3><p>在尝试了Console App之后，我们也来试试Web App 在 <code>Dotnet Core</code> 下是如何运行的。</p>
<p>首先，基本步骤如上，先创建一个项目模板。</p>
<p>接着，首先要使用Web功能，我们需要指定依赖，在project.json中的dependencies属性中增加依赖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&quot;dependencies&quot;: &#123;</div><div class="line">  &quot;Microsoft.AspNetCore.Server.Kestrel&quot;: &quot;1.0.0&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>注意：在设定依赖的时候，一定要注意版本号，如果依赖库的版本号不兼容Core的版本，那么很可能会出现一些莫名其妙的错误，而找不到原因。</strong></p>
<p>增加依赖之后，我们再次通过 <code>dotnet restore</code> 来安装依赖。</p>
<p>这个时候，我们来编写Web宿主程序，内容如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Program.cs</span></div><div class="line"></div><div class="line"><span class="keyword">using</span> System;</div><div class="line"><span class="keyword">using</span> Microsoft.AspNetCore.Hosting;</div><div class="line"><span class="keyword">namespace</span> <span class="title">WebApplication</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></div><div class="line">    &#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></div><div class="line">        &#123;</div><div class="line">            <span class="keyword">var</span> host = <span class="keyword">new</span> WebHostBuilder()</div><div class="line">                .UseKestrel()</div><div class="line">                .UseStartup&lt;Startup&gt;() <span class="comment">//此处使用了类型Startup，来自于Startup.cs</span></div><div class="line">                .UseUrls(<span class="string">"http://localhost: 10000"</span>)</div><div class="line">                .Build();</div><div class="line">            host.Run();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Startup.cs</span></div><div class="line"></div><div class="line"><span class="keyword">using</span> System;</div><div class="line"><span class="keyword">using</span> Microsoft.AspNetCore.Builder;</div><div class="line"><span class="keyword">using</span> Microsoft.AspNetCore.Http;</div><div class="line"></div><div class="line"><span class="keyword">namespace</span> <span class="title">WebApplication</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Startup</span></div><div class="line">    &#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">IApplicationBuilder app</span>)</span></div><div class="line">        &#123;</div><div class="line">            app.Run((context) =&gt; </div><div class="line">            &#123;</div><div class="line">                <span class="keyword">return</span> context.Response.WriteAsync(<span class="string">"Hello, From Core."</span>);</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编写好如上代码之后，我们在执行 <code>dotnet run</code>，访问 <code>http://localhost:10000</code> 就可以看到我们的Web程序已经成功运行起来了。</p>
<p>以上则是一个简单的Web程序所需要的代码。</p>
<h1 id="2、Other"><a href="#2、Other" class="headerlink" title="2、Other"></a>2、Other</h1><h3 id="2-1、Dotnet-Core-与-Node-js-的性能测试。"><a href="#2-1、Dotnet-Core-与-Node-js-的性能测试。" class="headerlink" title="2.1、Dotnet Core 与 Node.js 的性能测试。"></a>2.1、<code>Dotnet Core</code> 与 <code>Node.js</code> 的性能测试。</h3><p>在 <code>Dotnet Core</code> 的官方宣传中，号称比 <code>Node.js</code> 快8倍。实际上，通过计算从0到100000000的累加来看，两者的差距并不大（几十ms的差别，Node稍弱）。</p>
<p>由于时间环境关系，没有进行更复杂测试，但我想在高并发下，Node的机制可能会有更高的性能。在大量IO操作处理中，<code>Dotnet Core</code>会有绝对的优势【后续可验证】。</p>
<h3 id="2-2、如何直接运行Dotnet-Core程序？"><a href="#2-2、如何直接运行Dotnet-Core程序？" class="headerlink" title="2.2、如何直接运行Dotnet Core程序？"></a>2.2、如何直接运行Dotnet Core程序？</h3><p>在开发模式下，我们通过 <code>dotnet run</code> 来运行程序，那我们如何来运行发布好的程序呢？</p>
<p>首先，我们可以通过 <code>dotnet publish</code> 来生成好我们的应用程序（在Windows下生成的是dll，其他平台未测试）。</p>
<p>在发布模式，我们的程序所依赖的包，也会被一同发布到目录下，我们可以在 <code>/appRoot/bin/Debug/netcoreapp1.0/publish</code> 中找到我们发布好的文件。</p>
<p>此时，我们就可以将publish目录拷贝到其他电脑运行了。</p>
<p>由于发布好的文件入口点是 <code>.dll</code> 文件，我们要运行它的话，需要通过 <code>dotnet xxx.dll</code> 来进行启动。</p>
<p><strong>注意：在publish的时候，我们可以使用参数<code>dotnet publish -c Release</code> 生成Release版本的发布包，目录对应变更为 <code>bin/Release/</code></strong></p>
<p><strong>注意2：请不要删除publish目录下的文件，否则可能导致无法运行。经测试，<appname>.deps.json 和 <appname>.pdb可以删除，但依赖和 <appname>.runtimeconfig.json是绝对不能删除的。</appname></appname></appname></strong></p>
<h3 id="2-3-后续"><a href="#2-3-后续" class="headerlink" title="2.3 后续"></a>2.3 后续</h3><p>此文为 <code>Dotnet Core</code> 系列第一篇，后续计划将Web开发所需要用到的一些基本知识点，库等均在 <code>Dotnet Core</code> 调试通，且成文。</p>
<p><strong>加油，<code>Dotnet!</code></strong></p>
<p><strong>【6.30号更新】</strong></p>
<h3 id="2-4、如何创建web项目"><a href="#2-4、如何创建web项目" class="headerlink" title="2.4、如何创建web项目"></a>2.4、如何创建web项目</h3><p>在 1.3 中，我们知道如何把一个Console App 改造为一个Web项目，但这对应开发一个Web应用来说还不够。</p>
<p>其实，<code>dotnet new</code> 可以默认创建 Web 项目开发模板。</p>
<p>通过 <code>dotnet new -t --help</code> 我们可以看到 <code>dotnet new</code> 能帮我们创建的项目类型有如下四种：</p>
<ol>
<li>Console</li>
<li>Web</li>
<li>Lib</li>
<li>xunittest</li>
</ol>
<p>我们可以直接通过 <code>dotnet new -t Web</code> 来创建一个 Web 项目模板，简单快捷。</p>
<h3 id="2-5、如果在Linux下发布（CentOS7）"><a href="#2-5、如果在Linux下发布（CentOS7）" class="headerlink" title="2.5、如果在Linux下发布（CentOS7）"></a>2.5、如果在Linux下发布（CentOS7）</h3><p><code>Dotnet Core</code> 开发的程序，具有跨平台能力，那如何在非Windows上发布呢？各大操作系统方式并不同。</p>
<p>在CentOS7（仅支持7+）上发布非常简单。</p>
<p>首先是在CentOS7上安装 <code>Dotnet Core</code>，不知道如何安装？请查阅 <a href="https://www.microsoft.com/net/core#centos" target="_blank" rel="external">https://www.microsoft.com/net/core#centos</a> 。</p>
<p>安装好之后，只需要在Windows把开发好的程序，通过 <code>dotnet publish</code> 生成发布目录，然后将该目录拷贝到CentOS上即可。</p>
<p>最后，在CentOS上执行 <code>dotnet xxx.dll</code> 即可运行项目了。</p>
<p><strong>注意： xxx.dll是你开发的项目的主程序</strong></p>


    
    
    
  </section>
</article>
    </div>
  
    <div class='post-wrapper'>
      <article class="post reveal">
  <section class="meta">
    
    <h2 class="title">
      <a href="/blog/2017/02/21/ES6入门/ES6入门系列二（特性总览上）/">
        ES6入门系列二（特性总览上）
      </a>
    </h2>
    
    <time>
      Feb 21, 2017
    </time>
		
  </section>
  <section class="article typo">
	  <h2 id="0、导言"><a href="#0、导言" class="headerlink" title="0、导言"></a>0、导言</h2><p>最近从coffee切换到js，代码量一下子变大了不少，也多了些许陌生感。为了在JS代码中，更合理的使用ES6的新特性，特在此对ES6的特性做一个简单的总览。</p>
<h2 id="1、箭头函数-Arrows"><a href="#1、箭头函数-Arrows" class="headerlink" title="1、箭头函数(Arrows)"></a>1、箭头函数(Arrows)</h2><p>使用 =&gt; 简写的函数称之为箭头函数，和C#的lambda，CoffeeScript的语法比较类似。</p>
<pre><code>var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

//简单使用
var arr2 = arr.map(x =&gt; x + 1);
console.log(arr2);
//等价于
arr2 = arr.map(function (x) {
  return x + 1;
});
console.log(arr2);

//此处必须用()包裹对象，否则语法错误
var arr3 = arr.map((x, i) =&gt; ({
  idx: i,
  value: x
}));
console.log(arr3);
//等价于
arr3 = arr.map(function (x, i) {
  return {
    idx: i,
    value: x
  };
});
console.log(arr3);

//如果函数是一个语句块
var arr4 = [];
arr.forEach(x =&gt; {
  if (x % 3 === 0) {
    arr4.push(x);
  }
});
console.log(arr4);
//等价于
arr4.length = 0;
arr.forEach(function (x) {
  if (x % 3 === 0) {
    arr4.push(x);
  }
});
console.log(arr4);

//此处this一直指向obj对象。和一般function不同，箭头函数共享词法作用域。
var obj = {
  name: &apos;test&apos;,
  foods: [&apos;fish&apos;, &apos;milk&apos;],
  eat() {
    this.foods.forEach(x =&gt;
      console.log(this.name + &apos;like eat &apos; + x) //注意。此地不能有分号，因为属于表达式，不是语句块。
    );
  }
};
obj.eat();
</code></pre><h2 id="2、类定义（classes）"><a href="#2、类定义（classes）" class="headerlink" title="2、类定义（classes）"></a>2、类定义（classes）</h2><p>在ES6中，可以直接使用class关键字定义类，并可以定义构造函数，静态方法，get/set 方法，实例方法等。</p>
<pre><code>&apos;use strict&apos;;
class Animal {
  constructor(name) {
    this.name = name;
  }
  eat() {
    console.log(this.name + &apos; should eat food.&apos;);
  }
};

class Dog extends Animal {
  //构造函数
  constructor(age) {
      super(&apos;Dog&apos;);
      this.age = age;
      //实例方法
      this.instanceFun = function () {
        console.log(&apos;Instance Function.&apos;);
      }
    }
    //静态方法
  static go() {
      console.log(&apos;Dog will go.&apos;);
    }
    //原型方法
  prototypeFunc() {
    console.log(&apos;Prototype Function.&apos;);
  }

  //get、set
  get dogName() {
    return &apos;Name: &apos; + this.name;
  }
  set dogName(value) {
    this.name = value;
  }

  //get
  get dogAge() {
    return &apos;Age: &apos; + this.age;
  }
}

var dog = new Dog(4);
Dog.go();
dog.eat();
dog.instanceFun();
dog.prototypeFunc();
console.log(dog.dogName);
dog.dogName = &apos;x&apos;;
console.log(dog.dogName);
console.log(dog.dogAge);
dog.dogAge = 5; //会失败，属性没有getter。
</code></pre><h2 id="3、增强的对象常量（Enhanced-Object-Literals）"><a href="#3、增强的对象常量（Enhanced-Object-Literals）" class="headerlink" title="3、增强的对象常量（Enhanced Object Literals）"></a>3、增强的对象常量（Enhanced Object Literals）</h2><pre><code>var obj = {
  name: &apos;obj&apos;,
  __proto__: {
    name: &apos;parent&apos;
  },

  toString() {
    // 可以通过super直接取到原型对象的属性
    return super.name + &apos;:&apos; + this.name;
  },

  [&apos;prop_&apos; + (() =&gt; 1)()]: 1 //动态属性
};

console.log(obj.toString());
console.log(obj.prop_1);
</code></pre><h2 id="4、模板字符串（Template-Strings）"><a href="#4、模板字符串（Template-Strings）" class="headerlink" title="4、模板字符串（Template Strings）"></a>4、模板字符串（Template Strings）</h2><p>简化了字符串的构造，拼接等。</p>
<pre><code>//基本字符串，\n有效。
var str = `Basic string &apos;\n&apos; in Javascript.`;
console.log(str);
// Basic string &apos;
// &apos; in Javascript.

//多行字符串
str = `Multiline 
strings`;
console.log(str);
// Multiline
// strings

//字符串插值
var name = &apos;Jay&apos;;
str = `Hello, ${name}`;
console.log(str); // &apos;Hello, Jay.&apos;
</code></pre><h2 id="5、解构（Destructuring）–-Node和Chrome中执行不成功，忽略"><a href="#5、解构（Destructuring）–-Node和Chrome中执行不成功，忽略" class="headerlink" title="5、解构（Destructuring）– Node和Chrome中执行不成功，忽略"></a>5、解构（Destructuring）– Node和Chrome中执行不成功，忽略</h2><p>允许使用模式匹配，来匹配数组和对象。</p>
<h2 id="6、Default-Rest-Spread-–-Node和Chrome中执行不成功，忽略"><a href="#6、Default-Rest-Spread-–-Node和Chrome中执行不成功，忽略" class="headerlink" title="6、Default + Rest + Spread – Node和Chrome中执行不成功，忽略"></a>6、Default + Rest + Spread – Node和Chrome中执行不成功，忽略</h2><h2 id="7、局部变量-常量（Let-Const）"><a href="#7、局部变量-常量（Let-Const）" class="headerlink" title="7、局部变量+常量（Let + Const）"></a>7、局部变量+常量（Let + Const）</h2><pre><code>&apos;use strict&apos;; //必须启用严格模式

{
  let x = 1;
}
console.log(x); //Error:x is not defined.

const PI = 3.14;
PI = 3.15; //Error: 无法对常量赋值
console.log(PI); //3.14
</code></pre><h2 id="8、迭代器-For-Of（Iterators-For-Of）"><a href="#8、迭代器-For-Of（Iterators-For-Of）" class="headerlink" title="8、迭代器 + For..Of（Iterators + For..Of）"></a>8、迭代器 + For..Of（Iterators + For..Of）</h2><p>比较类似于C#中的IEnumerable，使用for..of来访问迭代器。它不要求实现一个数组，而是使用和LINQ类似的懒加载。</p>
<pre><code>(function () {
  &apos;use strict&apos;;
  let test = {
    [Symbol.iterator]() {
      let pre = 0,
        cur = 1;
      return {
        next() {//此处方法名不能变
          pre = cur;
          cur = pre + cur;
          console.log(&apos;pre = &apos; + pre);
          console.log(&apos;cur = &apos; + cur);
          //返回值的属性名也不能改变
          return {
            done: false,
            value: cur
          };
        }
      }
    }
  };

  for (var n of test) {
    if (n &gt; 1000) {
      break;
    }
    console.log(n);
  }
})();

// 用于获取数组的键值
for (var item of[1, 3, 5, 7, 9]) {
  console.log(item);
}
</code></pre><h2 id="9、生成器（Generators）"><a href="#9、生成器（Generators）" class="headerlink" title="9、生成器（Generators）"></a>9、生成器（Generators）</h2><p>允许在function*()函数中使用yield关键字。</p>
<pre><code>function* foo(x) {
  var y = 2 * (yield(x + 1));
  var z = yield(y / 3);
  return (x + y + z);
}

var it = foo(5);

console.log(it.next()); // { value:6, done:false }
console.log(it.next(12)); // { value:8, done:false }
console.log(it.next(13)); // { value:42, done:true }
</code></pre><h2 id="10、unicode"><a href="#10、unicode" class="headerlink" title="10、unicode"></a>10、unicode</h2><p>增加了对unicode字符的支持。比如“𠮷”（这个和吉不一样哦！）</p>
<pre><code>console.log(&apos;𠮷&apos;.length); //2

// 正则表达式增加了u这个参数，匹配unicode字符。
console.log(&quot;𠮷&quot;.match(/./u)[0].length) // 2

// new form
&quot;\u{20BB7}&quot;==&quot;𠮷&quot;==&quot;\uD842\uDFB7&quot;

// new String ops
&quot;𠮷&quot;.codePointAt(0) == 0x20BB7

// for-of iterates code points
for(var c of &quot;𠮷&quot;) {
  console.log(c);
}
</code></pre><h2 id="11、参考资料"><a href="#11、参考资料" class="headerlink" title="11、参考资料"></a>11、参考资料</h2><p>1、ECMAScript 6 features <a href="https://github.com/lukehoban/es6features" target="_blank" rel="external">https://github.com/lukehoban/es6features</a></p>
<p>2、ECMAScript 6 入门 <a href="http://es6.ruanyifeng.com/" target="_blank" rel="external">http://es6.ruanyifeng.com/</a></p>


    
    
    
  </section>
</article>
    </div>
  
    <div class='post-wrapper'>
      <article class="post reveal">
  <section class="meta">
    
    <h2 class="title">
      <a href="/blog/2017/02/21/ES6入门/ES6入门系列一（基础）/">
        ES6入门系列一（基础）
      </a>
    </h2>
    
    <time>
      Feb 21, 2017
    </time>
		
  </section>
  <section class="article typo">
	  <p>##1、let命令<br><strong>Tips:</strong></p>
<ol>
<li>块级作用域（只在当前块中有效）</li>
<li>不会变量提升（必须先申明在使用）</li>
<li>让变量独占该块，不再受外部影响</li>
<li>不允许重复声明</li>
</ol>
<p><strong>总之：let更像我们熟知的静态语言的的变量声明指令</strong></p>
<p>ES6新增了let命令，用来声明变量。用法类似于var，但所声明的变量，只能在let命令所在的代码块内有效。</p>
<p>let声明的变量只有块级作用域</p>
<pre><code>&apos;use strict&apos;
{
  let a = 1;
}
console.log(a); //结果是什么？
</code></pre><p>看一段熟悉的代码：</p>
<pre><code>var a = [];
for (var i = 0; i &lt; 10; i++) {
  a[i] = function () {
    console.log(i);
  };
}
console.log(a[6]()); //结果是什么？
</code></pre><p>如果改用let的话，那么看以下代码输出什么？</p>
<pre><code>&apos;use strict&apos;
var a = [];
for (let i = 0; i &lt; 10; i++) {
  a[i] = function () {
    console.log(i);
  };
}
console.log(a[6]()); // ?
</code></pre><p>同时，在使用let的时候，必须先申明再使用，不像var会变量提升：</p>
<pre><code>&apos;use strict&apos;
console.log(a);
let a = 1;
</code></pre><p>ES6中明确规定，如果区块存在let和const，那么该区块就形成封闭作用域，凡是在声明致歉就使用这些变量，就会报错。简称“暂时性死区”（temporal dead zone，简称TDZ）。</p>
<p>看一个不太容易发现的死区：（注：该代码未测试）</p>
<pre><code>function bar(x=y, y=2) {
  return [x, y];
}

bar(); // 报错
</code></pre><p>调用bar之所以报错，是因为参数x默认值等于另一个参数y，而此时y还没有声明，属于“死区”。</p>
<p>需要注意，函数参数作用域和函数体的作用域是分离的：</p>
<pre><code>let foo = &apos;outer&apos;;

function bar(func) {
  let foo = &apos;inner&apos;;
  console.log(func()); // outer
}

bar(function(){
  console.log(foo);
});
</code></pre><p>同时，let还不允许重复声明</p>
<pre><code>{
  let a = 1;
  var a = 1;
}
{
  let a = 1;
  let a = 2;
}
</code></pre><p>##2、const命令<br><strong>Tips：</strong></p>
<ol>
<li>const用于声明常量，一旦声明，值就不能改变</li>
<li>const具有块级作用域</li>
<li>const不能变量提升（先声明后使用）</li>
<li>不可重复声明</li>
</ol>
<p><strong>const看起来很像我们熟知的静态语言的只读对象</strong></p>
<p>const声明常量，一旦声明，值将是不可变的。</p>
<pre><code>&apos;use strict&apos;
const PI = 3.1415;
PI // 3.1415
PI = 3; //Error
</code></pre><p>const指令指向变量所在的地址，所以对该变量进行属性设置是可行的（未改变变量地址），如果想完全不可变化（包括属性），那么可以使用冻结。</p>
<pre><code>&apos;use strict&apos;
const C1 = {};
C1.a = 1;
console.log(C1.a); // 1 

//冻结对象，此时前面用不用const都是一个效果
const C2 = Object.freeze({}); 
C2.a = 1; //Error,对象不可扩展
console.log(C2.a);
</code></pre><p>##3、全局对象属性</p>
<p>JavaScript中，全局对象是最顶层的对象，浏览器中是window对象，Node中是global对象，ES5规定，所有全局变量都是全局对象的属性。</p>
<p>在ES6中，var和function申明的变量，属于全局对象的属性，let和const则不是全局对象的属性。</p>
<pre><code>&apos;use strict&apos;
let b = 2;
console.log(global.b); // undefined
</code></pre>

    
    
    
  </section>
</article>
    </div>
  
    <div class='post-wrapper'>
      <article class="post reveal">
  <section class="meta">
    
    <h2 class="title">
      <a href="/blog/2017/02/21/ES6入门/ES6入门系列三（特性总览下）/">
        ES6入门系列三（特性总览下）
      </a>
    </h2>
    
    <time>
      Feb 21, 2017
    </time>
		
  </section>
  <section class="article typo">
	  <h1 id="0、导言"><a href="#0、导言" class="headerlink" title="0、导言"></a>0、导言</h1><p>最近从coffee切换到js，代码量一下子变大了不少，也多了些许陌生感。</p>
<p>为了在JS代码中，更合理的使用ES6的新特性，特在此对ES6的特性做一个简单的总览。</p>
<h1 id="1、模块-Module-Chrome测试不可用"><a href="#1、模块-Module-Chrome测试不可用" class="headerlink" title="1、模块(Module - Chrome测试不可用)"></a>1、模块(Module - Chrome测试不可用)</h1><blockquote>
<p>在ES6中，有class的概念，不过这只是语法糖，并没有解决模块化问题。Module功能则是为了解决模块化问题而提出的。</p>
</blockquote>
<p>我们可以使用如下方式定义模块：</p>
<p>11_lib.js文件内容</p>
<pre><code>// 导出属性和方法
export var PI = 3.1415926;
export function calcCircularArea(r){
  return PI * r * r;
}
</code></pre><p>app.js文件内容</p>
<pre><code>//导出所有，使用别名调用
import * as lib from &apos;11_lib&apos;;
console.log(lib.calcCircularArea(2));
console.log(lib.PI);

//导出属性和方法
import {calcCircularArea, PI} from &apos;11_lib&apos;;
console.log(calcCircularArea(2));
console.log(PI);
</code></pre><h1 id="2、模块加载器-Module-Loaders-Chrome测试不可用"><a href="#2、模块加载器-Module-Loaders-Chrome测试不可用" class="headerlink" title="2、模块加载器(Module Loaders - Chrome测试不可用)"></a>2、模块加载器(Module Loaders - Chrome测试不可用)</h1><p>既然用了定义module的规范，那么也就需要一个模块加载器，需要支持如下内容：</p>
<ol>
<li>动态加载</li>
<li>状态隔离</li>
<li>全局命名空间隔离</li>
<li>编译钩子</li>
<li>嵌套虚拟化</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">System.import(<span class="string">'11_lib'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">m</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(m.calcCircularArea(<span class="number">2</span>));</div><div class="line">  <span class="built_in">console</span>.log(m.PI);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h1 id="3、图-集合-弱引用图-若引用集合-Map-Set-WeakMap-WeakSet"><a href="#3、图-集合-弱引用图-若引用集合-Map-Set-WeakMap-WeakSet" class="headerlink" title="3、图 + 集合 + 弱引用图 + 若引用集合(Map + Set + WeakMap + WeakSet)"></a>3、图 + 集合 + 弱引用图 + 若引用集合(Map + Set + WeakMap + WeakSet)</h1><p>在ES6中，新增了几种数据结构。</p>
<p><strong>Map</strong>是一种类似于Object的结构，Object本质上是键值对的集合，但是只能是字符串当做键，所以有一定的使用限制。Map的话，则可以拿任意类型来作为key。具体使用如下：</p>
<pre><code>var map = new Map();
var key = {key: &apos;hah&apos;};
map.set(key, &apos;1&apos;); //设置key-value
map.set(key, 2); //对已有key进行设置，表示覆盖
console.log(map.get(key)); //获取key的值
console.log(map.size);//获取map的元素个数
map.has(key); //判断map中有指定的key
map.delete(key); //删除map中指定的key
map.clear(); //清空map
</code></pre><p><strong>WeakMap</strong>和Map是比较类似的，唯一的区别是只接受对象作为键名（null除外），而且键名所指向的对象，不计入垃圾回收机制。</p>
<p><strong>Set</strong>是一种类似于数组，但成员的值都是唯一（引用唯一）的一种数据结构。具体使用如下：</p>
<pre><code>var set = new Set();//定义set
set.add(1).add(2).add(1).add(&apos;2&apos;); //添加数据
console.log(set.size);//查看set中元素的数量，结果应该是3，因为重复添加不计算，2和&apos;2&apos;不等。
set.delete(1); //删除set的值（通过value删除）。
set.has(1); //set是否包含某个value
set.keys(); //返回set的所有key
set.values(); //返回set的所有value
set.clear();//清空set
</code></pre><p><strong>WeakSet</strong>和Set也是比较类型的，和Set有两个区别，一个是成员只能是对象；二个是WeakSet是不可遍历的。</p>
<h1 id="4、代理（Proxies）-Chrome测试不可用"><a href="#4、代理（Proxies）-Chrome测试不可用" class="headerlink" title="4、代理（Proxies） (Chrome测试不可用)"></a>4、代理（Proxies） (Chrome测试不可用)</h1><p>代理允许用宿主的行为来创建对象，能够实现拦截，对象的虚拟化，日志和分析等功能。</p>
<h1 id="5、数据类型Symbols"><a href="#5、数据类型Symbols" class="headerlink" title="5、数据类型Symbols"></a>5、数据类型Symbols</h1><p>在ES5中，JS只有6中原始类型，在ES6中，新增了Symbols类型，成为了JS中的第7种原始类型。<br>该类型表示独一无二的值。使用如下：</p>
<p>var key = Symbol(); //定义Symbol对象<br>console.log(typeof key); //symbol ，表示为类型，而且不是string类型的。<br>key = Symbol(‘这是一个说明’); //可以在定义Symbol的时候，添加一个说明</p>
<p>Symbol不能与其他类型值进行运算，但是可以显式转换为字符串，和转换为布尔值</p>
<pre><code>console.log(key.toString());
console.log(String(key));

if(key){
  console.log(&apos;key is true&apos;);
}
</code></pre><p>在对象的内部，要使用Symbol值定义属性时，必须放在方括号中。</p>
<pre><code>var obj = {
  [key]: &apos;abc&apos;
};
</code></pre><h1 id="6、可以子类化的内置对象"><a href="#6、可以子类化的内置对象" class="headerlink" title="6、可以子类化的内置对象"></a>6、可以子类化的内置对象</h1><p>在ES6中，我们可以自定义类型来继承内置对象，这个时候，如果要自定义构造函数，必须要在构造函数中调用super(),来呼叫父类的构造。</p>
<pre><code>&apos;use strict&apos;;
class MyArray extends Array {
    // 如果要定义constuctor，那么就必须要使用super来执行父类的构造
    constructor(){
      super();
    }
}

var arr = new MyArray();
arr[1] = 12;
console.log(arr.length === 2);
</code></pre><h1 id="7、新增的API（Math-Number-String-Array-Object-APIs）"><a href="#7、新增的API（Math-Number-String-Array-Object-APIs）" class="headerlink" title="7、新增的API（Math + Number + String + Array + Object APIs）"></a>7、新增的API（Math + Number + String + Array + Object APIs）</h1><p>如下代码，一目了然：</p>
<pre><code>//数字类api
Number.EPSILON; //增加常量e
Number.isInteger(Infinity) // false
Number.isNaN(&quot;NaN&quot;) // false

//数学类api
Math.acosh(3) // 1.762747174039086
Math.hypot(3, 4) // 5
Math.imul(Math.pow(2, 32) - 1, Math.pow(2, 32) - 2) // 2

//字符串类api
&quot;abcde&quot;.includes(&quot;cd&quot;) // true
&quot;abc&quot;.repeat(3) // &quot;abcabcabc&quot;

//数组api
Array.from(document.querySelectorAll(&apos;*&apos;)) // Returns a real Array
Array.of(1, 2, 3) // Similar to new Array(...), but without special one-arg behavior
[0, 0, 0].fill(7, 1) // [0,7,7]
[1, 2, 3].find(x =&gt; x == 3) // 3
[1, 2, 3].findIndex(x =&gt; x == 2) // 1
[1, 2, 3, 4, 5].copyWithin(3, 0) // [1, 2, 3, 1, 2]
[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].entries() // iterator [0, &quot;a&quot;], [1,&quot;b&quot;], [2,&quot;c&quot;]
[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].keys() // iterator 0, 1, 2
[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].values() // iterator &quot;a&quot;, &quot;b&quot;, &quot;c&quot;

//对象api
Object.assign(Point, { origin: new Point(0,0) })
</code></pre><h1 id="8、二进制和八进制字面量（Binary-and-Octal-Literals）"><a href="#8、二进制和八进制字面量（Binary-and-Octal-Literals）" class="headerlink" title="8、二进制和八进制字面量（Binary and Octal Literals）"></a>8、二进制和八进制字面量（Binary and Octal Literals）</h1><p>直接上示例：</p>
<pre><code>var n1 = 0b111110101; //0b前缀，表示二进制字面量
console.log(n1); //输出的时候，直接用10进制展示

var n2 = 0o12345; //0o前缀，表示八进制字面量
console.log(n2);
</code></pre><h1 id="9、承诺（Promises）"><a href="#9、承诺（Promises）" class="headerlink" title="9、承诺（Promises）"></a>9、承诺（Promises）</h1><p><strong>Promise</strong>是ES6中新增的异步编程库。</p>
<pre><code>//使用承诺定义一个异步任务
var p = new Promise((resolve, reject)=&gt;{
  return setTimeout(function(){
    reject(&apos;ok&apos;);
  }, 2000);
});

p.then((data)=&gt;{
  console.log(data);
}, (data)=&gt;{
  console.log(&apos;error&apos; + data);
}).then(()=&gt;{
  console.log(&apos;throw err&apos;);
  throw &apos;Error&apos;;
}).catch(err =&gt; {
  console.log(err);
});
</code></pre><h1 id="10、参考资料"><a href="#10、参考资料" class="headerlink" title="10、参考资料"></a>10、参考资料</h1><p>1、ECMAScript 6 features <a href="https://github.com/lukehoban/es6features" target="_blank" rel="external">https://github.com/lukehoban/es6features</a></p>
<p>2、ECMAScript 6 入门 <a href="http://es6.ruanyifeng.com/" target="_blank" rel="external">http://es6.ruanyifeng.com/</a></p>


    
    
    
  </section>
</article>
    </div>
  
    <div class='post-wrapper'>
      <article class="post reveal">
  <section class="meta">
    
    <h2 class="title">
      <a href="/blog/2017/02/21/JS札记/JS实现继承的几种方式/">
        JS实现继承的几种方式
      </a>
    </h2>
    
    <time>
      Feb 21, 2017
    </time>
		
  </section>
  <section class="article typo">
	  <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>JS作为面向对象的弱类型语言，继承也是其非常强大的特性之一。那么如何在JS中实现继承呢？让我们拭目以待。</p>
<h2 id="JS继承的实现方式"><a href="#JS继承的实现方式" class="headerlink" title="JS继承的实现方式"></a>JS继承的实现方式</h2><p>既然要实现继承，那么首先我们得有一个父类，代码如下：</p>
<pre><code>// 定义一个动物类
function Animal (name) {
  // 属性
  this.name = name || &apos;Animal&apos;;
  // 实例方法
  this.sleep = function(){
    console.log(this.name + &apos;正在睡觉！&apos;);
  }
}
// 原型方法
Animal.prototype.eat = function(food) {
  console.log(this.name + &apos;正在吃：&apos; + food);
};
</code></pre><h3 id="1、原型链继承"><a href="#1、原型链继承" class="headerlink" title="1、原型链继承"></a>1、原型链继承</h3><p><strong>核心：</strong> 将父类的实例作为子类的原型</p>
<pre><code>function Cat(){    
}
Cat.prototype = new Animal();
Cat.prototype.name = &apos;cat&apos;;

//　Test Code
var cat = new Cat();
console.log(cat.name);
console.log(cat.eat(&apos;fish&apos;));
console.log(cat.sleep());
console.log(cat instanceof Animal); //true 
console.log(cat instanceof Cat); //true
</code></pre><p>特点：</p>
<ol>
<li>非常纯粹的继承关系，实例是子类的实例，也是父类的实例</li>
<li>父类新增原型方法/原型属性，子类都能访问到</li>
<li>简单，易于实现</li>
</ol>
<p>缺点：</p>
<ol>
<li>要想为子类新增属性和方法，必须要在<code>new Animal()</code>这样的语句之后执行，不能放到构造器中</li>
<li>无法实现多继承</li>
<li>来自原型对象的引用属性是所有实例共享的（详细请看附录代码： <a href="javascript:void(0" target="_blank" rel="external">示例1</a>;)）</li>
<li>创建子类实例时，无法向父类构造函数传参</li>
</ol>
<p>推荐指数：★★（3、4两大致命缺陷）</p>
<h3 id="2、构造继承"><a href="#2、构造继承" class="headerlink" title="2、构造继承"></a>2、构造继承</h3><p><strong>核心：</strong>使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）</p>
<pre><code>function Cat(name){
  Animal.call(this);
  this.name = name || &apos;Tom&apos;;
}

// Test Code
var cat = new Cat();
console.log(cat.name);
console.log(cat.sleep());
console.log(cat instanceof Animal); // false
console.log(cat instanceof Cat); // true
</code></pre><p>特点：</p>
<ol>
<li>解决了1中，子类实例共享父类引用属性的问题</li>
<li>创建子类实例时，可以向父类传递参数</li>
<li>可以实现多继承（call多个父类对象）</li>
</ol>
<p>缺点：</p>
<ol>
<li>实例并不是父类的实例，只是子类的实例</li>
<li>只能继承父类的实例属性和方法，不能继承原型属性/方法</li>
<li>无法实现函数复用，每个子类都有父类实例函数的副本，影响性能</li>
</ol>
<p>推荐指数：★★（缺点3）</p>
<h3 id="3、实例继承"><a href="#3、实例继承" class="headerlink" title="3、实例继承"></a>3、实例继承</h3><p><strong>核心：</strong>为父类实例添加新特性，作为子类实例返回</p>
<pre><code>function Cat(name){
  var instance = new Animal();
  instance.name = name || &apos;Tom&apos;;
  return instance;
}

// Test Code
var cat = new Cat();
console.log(cat.name);
console.log(cat.sleep());
console.log(cat instanceof Animal); // true
console.log(cat instanceof Cat); // false
</code></pre><p>特点：</p>
<ol>
<li>不限制调用方式，不管是<code>new 子类()</code>还是<code>子类()</code>,返回的对象具有相同的效果</li>
</ol>
<p>缺点：</p>
<ol>
<li>实例是父类的实例，不是子类的实例</li>
<li>不支持多继承</li>
</ol>
<p>推荐指数：★★</p>
<h3 id="4、拷贝继承"><a href="#4、拷贝继承" class="headerlink" title="4、拷贝继承"></a>4、拷贝继承</h3><pre><code>function Cat(name){
  var animal = new Animal();
  for(var p in animal){
    Cat.prototype[p] = animal[p];
  }
  Cat.prototype.name = name || &apos;Tom&apos;;
}

// Test Code
var cat = new Cat();
console.log(cat.name);
console.log(cat.sleep());
console.log(cat instanceof Animal); // false
console.log(cat instanceof Cat); // true
</code></pre><p>特点：</p>
<ol>
<li>支持多继承</li>
</ol>
<p>缺点：</p>
<ol>
<li>效率较低，内存占用高（因为要拷贝父类的属性）</li>
<li>无法获取父类不可枚举的方法（不可枚举方法，不能使用for in 访问到）</li>
</ol>
<p>推荐指数：★（缺点1）</p>
<h3 id="5、组合继承"><a href="#5、组合继承" class="headerlink" title="5、组合继承"></a>5、组合继承</h3><p><strong>核心：</strong>通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用</p>
<pre><code>function Cat(name){
  Animal.call(this);
  this.name = name || &apos;Tom&apos;;
}
Cat.prototype = new Animal();

// Test Code
var cat = new Cat();
console.log(cat.name);
console.log(cat.sleep());
console.log(cat instanceof Animal); // true
console.log(cat instanceof Cat); // true
</code></pre><p>特点：</p>
<ol>
<li>弥补了方式2的缺陷，可以继承实例属性/方法，也可以继承原型属性/方法</li>
<li>既是子类的实例，也是父类的实例</li>
<li>不存在引用属性共享问题</li>
<li>可传参</li>
<li>函数可复用</li>
</ol>
<p>缺点：</p>
<ol>
<li>调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了）</li>
</ol>
<p>推荐指数：★★★★（仅仅多消耗了一点内存）</p>
<h3 id="6、寄生组合继承"><a href="#6、寄生组合继承" class="headerlink" title="6、寄生组合继承"></a>6、寄生组合继承</h3><p><strong>核心：</strong>通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点</p>
<pre><code>function Cat(name){
  Animal.call(this);
  this.name = name || &apos;Tom&apos;;
}
(function(){
  // 创建一个没有实例方法的类
  var Super = function(){};
  Super.prototype = Animal.prototype;
  //将实例作为子类的原型
  Cat.prototype = new Super();
})();

// Test Code
var cat = new Cat();
console.log(cat.name);
console.log(cat.sleep());
console.log(cat instanceof Animal); // true
console.log(cat instanceof Cat); //true
</code></pre><p>特点：</p>
<ol>
<li>堪称完美</li>
</ol>
<p>缺点：</p>
<ol>
<li>实现较为复杂</li>
</ol>
<p>推荐指数：★★★★（实现复杂，扣掉一颗星）</p>
<h2 id="附录代码："><a href="#附录代码：" class="headerlink" title="附录代码："></a>附录代码：</h2><p>示例一：</p>
<pre><code>function Animal (name) {
  // 属性
  this.name = name || &apos;Animal&apos;;
  // 实例方法
  this.sleep = function(){
    console.log(this.name + &apos;正在睡觉！&apos;);
  }
  //实例引用属性
  this.features = [];
}
function Cat(name){
}
Cat.prototype = new Animal();

var tom = new Cat(&apos;Tom&apos;);
var kissy = new Cat(&apos;Kissy&apos;);

console.log(tom.name); // &quot;Animal&quot;
console.log(kissy.name); // &quot;Animal&quot;
console.log(tom.features); // []
console.log(kissy.features); // []

tom.name = &apos;Tom-New Name&apos;;
tom.features.push(&apos;eat&apos;);

//针对父类实例值类型成员的更改，不影响
console.log(tom.name); // &quot;Tom-New Name&quot;
console.log(kissy.name); // &quot;Animal&quot;
//针对父类实例引用类型成员的更改，会通过影响其他子类实例
console.log(tom.features); // [&apos;eat&apos;]
console.log(kissy.features); // [&apos;eat&apos;]

原因分析：

关键点：属性查找过程

执行tom.features.push，首先找tom对象的实例属性（找不到），
那么去原型对象中找，也就是Animal的实例。发现有，那么就直接在这个对象的
features属性中插入值。
在console.log(kissy.features); 的时候。同上，kissy实例上没有，那么去原型上找。
刚好原型上有，就直接返回，但是注意，这个原型对象中features属性值已经变化了。
</code></pre>

    
    
    
  </section>
</article>
    </div>
  
</section>


  <nav id="page-nav">
    
    <a class="prev" rel="prev" href="/blog/archives/2017/02/page/9/">
      <span class="icon icon-chevron-left"></span>
      <span class="text">Previous</span>
    </a>
    
    
    <a class="next" rel="next" href="/blog/archives/2017/02/page/11/">
      <span class="text">Next</span>
      <span class="icon icon-chevron-right"></span>
    </a>
    
  </nav>
  


      </div>
      <aside class='l_side'>
        
  <section class='m_widget about'>

<img class='avatar waves-image' src='https://avatars1.githubusercontent.com/u/4043284?v=3&amp;s=460' />

<div class='header'>Jay.M.Hu</div>
<div class='content'>
<div></div>
</div>
</section>

  <section class='m_widget friendly-links'>
<div class='header'>Links</div>
<div class='content'>
    <ul class="entry">
    
        <li><a class="flat-box" target="_blank" href="http://humin.cnblogs.com/">
            <div class='name'>幻天芒 - 博客园</div>
        </a></li>
    
    </ul>
</div>
</section>

  <section class='m_widget categories'>
<div class='header'>Categories</div>
<div class='content'>
    
</div>
</section>

  


      </aside>
      <script>setLoadingBarProgress(60);</script>
    </div>
  </div>
  <footer id="footer" class="clearfix">

	<div class="social-wrapper">
  	
      
        <a href="https://github.com/hstarorg" class="social github"
          target="_blank" rel="external">
          <span class="icon icon-github"></span>
        </a>
      
        <a href="/atom.xml" class="social rss"
          target="_blank" rel="external">
          <span class="icon icon-rss"></span>
        </a>
      
    
  </div>
  
  <div>Theme <a href='https://github.com/stkevintan/hexo-theme-material-flow' class="codename">MaterialFlow</a> designed by <a href="http://keyin.me/" target="_blank">Kevin Tan</a>.</div>
  
</footer>


  <script>setLoadingBarProgress(80);</script>
  

<script src="//apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
<script src='//cdn.bootcss.com/node-waves/0.7.5/waves.min.js'></script>
<script src="//cdn.bootcss.com/scrollReveal.js/3.3.2/scrollreveal.min.js"></script>
<script src="/blog/js/jquery.fitvids.js"></script>
<script>
	var GOOGLE_CUSTOM_SEARCH_API_KEY = "";
	var GOOGLE_CUSTOM_SEARCH_ENGINE_ID = "";
	var ALGOLIA_API_KEY = "";
	var ALGOLIA_APP_ID = "";
	var ALGOLIA_INDEX_NAME = "";
  var AZURE_SERVICE_NAME = "";
  var AZURE_INDEX_NAME = "";
  var AZURE_QUERY_KEY = "";
  var BAIDU_API_ID = "";
  var SEARCH_SERVICE = "hexo";
  var ROOT = "/blog/"||"/";
  if(!ROOT.endsWith('/'))ROOT += '/';
</script>
<script src="/blog/js/search.js"></script>
<script src="/blog/js/app.js"></script>


  <script>setLoadingBarProgress(100);</script>
</body>
</html>
