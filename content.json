{"pages":[{"title":"","permalink":"http://hstarorg.github.io/blog/about/index.html","text":"关于我熟悉 C#、JavaScript、HTML、CSS 等语言, 主要从事 .Net、NodeJS、前端 等方面的工作。 我的联系方式 Github: hstarorg Twitter: Hstar19 Facebook: 胡敏 知乎: hstar 微博: 出来混总会遇到吃货"},{"title":"","permalink":"http://hstarorg.github.io/blog/about/r.js","text":"const fs = require('fs'); const path = require('path'); const mdFiles = []; const addMdFilesToArr = (folder) => { fs.readdirSync(folder).forEach(f => { let filePath = path.join(folder, f); let tmpF = fs.statSync(filePath); if (tmpF.isDirectory()) { addMdFilesToArr(filePath); } else if (path.extname(f) === '.md') { mdFiles.push(filePath); } }); } addMdFilesToArr(__dirname); let processCount = 0; mdFiles.forEach(file => { let name = path.basename(file); let content = fs.readFileSync(file, 'utf8'); let date = new Date(); if (name.indexOf('[') === 0) { date = name.match(/\\[\\d{8}\\]/)[0]; date = new Date(+date.substr(1, 4), date.substr(5, 2) - 1, date.substr(7, 2)); } let dateStr = date.toLocaleString().replace(/-/g, '/'); name = name.replace(/\\[\\d{8}\\]/g, '').replace('.md', ''); let needProcess = true; if (content.indexOf('---') === 0) { needProcess = false; } if (needProcess) { fs.writeFileSync(file, `---\\ntitle: ${name}\\ndate: ${dateStr}\\n---\\n\\n${content}`, 'utf8'); processCount++; } }); console.log(mdFiles.length, 'ok', processCount);"}],"posts":[{"title":"VsCode简易配置手册","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/前端相关/VsCode简易配置手册/","text":"0、什么是VsCode（Visual Studio Code - vsc）VsCode是MS基于Atom Shell开发的新一代 跨平台 编辑器。vsc将简洁和”编码-编辑-调试”循环的流水线特点结合在代码编辑器中。 截止该文创建时，最新版本是0.10.11。官网地址： https://code.visualstudio.com 1、VsCode的优势对比业界各类强大的编辑器，VsCode有哪些优势呢？ 跨平台 - VsCode兼容Windows,Linux,OSX三大平台 高性能 - VsCode对比Atom，有更高的性能，更快的大文件加载速度 集成Git - Git作为最流行的版本控制工具，VsCode默认集成 代码调试 - 强大的调试工具 智能提示（代码不全） - 强大的代码不全，语义理解 插件机制 - 可以很方便的扩展需要的功能 2、配置编辑器2.1、用户设置通过选择菜单栏上的Files &gt; Preferences &gt; User Settings，或者是按F1，然后输入user，进行user settings.json的配置。 在配置时，默认是分栏的界面，左侧是标准的系统配置项，右侧是用户自定义配置项。配置右边的项就可以参考左边的标准配置。 由于默认配置已经非常实用了，所以需要我们自定义配置的项并不多： 12345678&#123; \"editor.tabSize\": 2, //tab键所占用的字符数 \"files.exclude\": &#123; //需要排除的文件（夹），不在EXPLORER面板中显示 \".idea/\": false, \".vscode/\": false, \"typings/\": false &#125;&#125; 2.2、工作空间配置与用户设置一样，我们可以针对工作空间进行配置，此处的配置文件，保存在目录下vscode/settings.json中。 2.3 常用快捷键说明 Ctrl+Shift+\\ 在块标记之间跳转 Ctrl+Down or Ctrl+Up 上下移动一行 Ctrl+Alt+Down or Ctrl+Alt+Up 上下纵向选择 Alt+Click 添加辅助光标，然后就可以多个光标编辑了 Ctrl+D 当有选中字符时，跳转到下一个该字符处 Ctrl+F2 or Ctrl+Shift+L 选中所有出现的选中字符 Ctrl+T 搜索语法 F1打开输入框，删除&gt;,输入?,可以看到相关命令 更多快捷键，请参考：https://code.visualstudio.com/docs/customization/keybindings 3、Debugging相关配置当前支持的Debugging语言有node，Chrome，Go，大概配置如下： 12345678910111213141516171819202122232425262728293031&#123; \"version\": \"0.2.0\", \"configurations\": [ &#123; \"name\": \"Launch\", //名称 \"type\": \"node\", //类型 \"request\": \"launch\", \"program\": \"app.js\", //要启动的程序 \"stopOnEntry\": false, \"args\": [], //启动参数 \"cwd\": \".\", //从那个相对路径启动 \"runtimeExecutable\": null, \"runtimeArgs\": [ \"--nolazy\" ], \"env\": &#123; \"NODE_ENV\": \"development\" //环境变量 &#125;, \"externalConsole\": false, \"preLaunchTask\": \"\", \"sourceMaps\": false, \"outDir\": null &#125;, &#123; \"name\": \"Attach\", \"type\": \"node\", \"request\": \"attach\", \"port\": 5858 &#125; ]&#125; 4、Tasks相关配置在VsCode中，我们还可以自定义task。首先在.vscode目录下创建tasks.json，进行task的配置： 12345678910111213141516&#123; \"version\": \"0.1.0\", \"command\": \"gulp\", \"isShellCommand\": true, \"tasks\": [ &#123; \"taskName\": \"less\", //配置任务名称 // Make this the default build command. \"isBuildCommand\": true, // Show the output window only if unrecognized errors occur. \"showOutput\": \"silent\", // Use the standard less compilation problem matcher. \"problemMatcher\": \"$lessCompile\" &#125; ]&#125; 5、语言环境相关配置在使用VsCode的过程中，非常吸引人的一个特性就是智能提示。在0.10.8和之前的版本，node代码是直接可以通过typings来智能提示的。但是在0.10.10版本之后，就需要通过配置文件来启用功能了。 5.1 JavaScript在使用JavaScript的时候，配置文件是jsconfig.json(tsconfig.json的子集)，如果目录中存放该问题，表示该目录是项目的根路径。jsconfig配置文件本身列出属于该项目以及编译器的选项。大致内容如下： 12345678910111213&#123; \"compilerOptions\": &#123; \"target\": \"ES6\", //可选es3,es5,es6,es2015 \"module\": \"commonjs\" //可选amd,umd,commonjs,system &#125;, \"files\": [ \"app.js\", \"model.js\" ], \"exclude\": [ //排除的目录，不在搜索 \"node_modules\" ]&#125; Tips: 如果应用程序有的代码在app/ or src/下，那么jsconfig应该在这些目录下创建 Tips: 如果你的工作空间中，包含多个不同的应用程序（比如client和server），那么请在每个文件夹下增加独立的jsconfig.json文件 Tips： 如果没有jsconfig.json，默认是排除node_modules目录 5.2、DockerfileDockerfile编写支持，极大的丰富了VsCode的多样性。要支持Dockerfile，需要通过ext install 来安装Dockerfile and Docker Compose File Support扩展。 创建好一个Dockerfile文件后，使用空格就可以使用智能提示了。 5.3、关于智能提示所需要的typing文件要安装typing文件，那么首先需要我们全局安装npm install typings -g，typings相关地址https://github.com/typings/typings 通过typings search --name &lt;name&gt; 可以全名匹配搜索插件 通过typings search &lt;name&gt; 可以模糊搜索插件 通过typings install &lt;name&gt; --ambient --save 可以安装type definition 如何要js文件能够智能提示呢？ 方式一：可以在js文件中首行使用引用注释的方式： 1234/// &lt;reference path=\"typings/main.d.ts\" /&gt;'use strict';var fs = require('fs');fs.access... 方式二：把typings文件加入到jsconfig.json中的files项下，不要忘记Reload JavaScript Project 12345678910&#123; \"compilerOptions\": &#123; \"target\": \"ES6\", //可选es3,es5,es6,es2015 \"module\": \"commonjs\", //可选amd,umd,commonjs,system \"moduleResolution\": \"node\" &#125;, \"files\": [ \"typings/main.d.ts\" ]&#125; 另，附上DefinitelyTyped仓库地址：https://github.com/DefinitelyTyped/DefinitelyTyped 6、MORE更多内容，请查阅：https://code.visualstudio.com/docs/ 补充说明，2016-3-18 16:08:01更新 如果在VsCode中开启了EsLint，而又使用了import等语法，请使用如下.eslintrc 1234567891011121314151617181920&#123; \"parserOptions\": &#123; \"ecmaVersion\": 6, \"sourceType\": \"module\", //支持import \"ecmaFeatures\": &#123; \"globalReturn\": true, \"impliedStrict\": true, \"jsx\": true, \"experimentalObjectRestSpread\": true, \"modules\": true &#125; &#125;, \"rules\": &#123; \"semi\": 2 &#125;, \"env\": &#123; \"browser\": false, \"node\": true &#125;&#125;"},{"title":"认识AMD、CMD、UMD、CommonJS","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/前端相关/认识AMD、CMD、UMD、CommonJS/","text":"0、导言JavaScript的生态系统一直在稳步增长，当各种组件混合使用时，就可能会发现不是所有的组件都能“和平共处”，为了解决这些问题，各种模块规范就出来了。 1、AMD（Asynchromous Module Definition - 异步模块定义）AMD是RequireJS在推广过程中对模块定义的规范化产出，AMD是异步加载模块，推崇依赖前置。 define(&apos;module1&apos;, [&apos;jquery&apos;], ($) =&gt; { //do something... }); 代码中依赖被前置，当定义模块（module1）时，就会加载依赖（jquery） 2、CMD（Common Module Definition - 公共模块定义）CMD是SeaJS在推广过程中对模块定义的规范化产出，对于模块的依赖，CMD是延迟执行，推崇依赖就近。 define((require, exports, module) =&gt; { module.exports = { fun1: () =&gt; { var $ = require(&apos;jquery&apos;); return $(&apos;#test&apos;); } }; }); 如上代码，只有当真正执行到fun1方法时，才回去执行jquery。 同时CMD也是延自CommonJS Modules/2.0规范 CommonJS提到CMD，就不得不提起CommonJS，CommonJS是服务端模块的规范，由于Node.js被广泛认知。 根据CommonJS规范，一个单独的文件就是一个模块。加载模块使用require方法，该方法读取一个文件并执行，最后返回文件内部的module.exports对象。 //file1.js moudle.exports = { a: 1 }; //file2.js var f1 = require(&apos;./file1&apos;); var v = f1.a + 2; module.exports ={ v: v }; CommonJS 加载模块是同步的，所以只有加载完成才能执行后面的操作。像Node.js主要用于服务器的编程，加载的模块文件一般都已经存在本地硬盘，所以加载起来比较快，不用考虑异步加载的方式，所以CommonJS规范比较适用。但如果是浏览器环境，要从服务器加载模块，这是就必须采用异步模式。所以就有了 AMD CMD 解决方案。 UMD（Universal Module Definition - 通用模块定义）UMD又是个什么玩意呢？UMD是AMD和CommonJS的一个糅合。AMD是浏览器优先，异步加载；CommonJS是服务器优先，同步加载。 既然要通用，怎么办呢？那就先判断是否支持node.js的模块，存在就使用node.js；再判断是否支持AMD（define是否存在），存在则使用AMD的方式加载。这就是所谓的UMD。 ((root, factory) =&gt; { if (typeof define === &apos;function&apos; &amp;&amp; define.amd) { //AMD define([&apos;jquery&apos;], factory); } else if (typeof exports === &apos;object&apos;) { //CommonJS var $ = requie(&apos;jquery&apos;); module.exports = factory($); } else { //都不是，浏览器全局定义 root.testModule = factory(root.jQuery); } })(this, ($) =&gt; { //do something... 这里是真正的函数体 });"},{"title":"那些容易出错的Dom操作","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/前端相关/那些容易出错的Dom操作/","text":"0、导言在用惯了 jQuery 这种利器之后，回到原生JS的Dom操作，一时间反而感觉有点陌生。 最近在做的项目中，为了尽可能少的引用三方库，所有DOM操作都是用的原生JS来实现的。在这里也分享下在DOM操作中，容易混淆的一些知识点。 原生JS可能会有兼容性问题，以下方法如非特别说明，均在 Chrome latest(53), Firefox latest(47), Edge25, IE11 中测试通过 1、获取视口高度所谓视口高度，就是在浏览器中，我们可见区域的高度，它不会随着内容的变化而变化，只会跟着浏览器本身的大小变化而变化（工具栏高度也会影响浏览区域的大小）。 先来一段完整的测试代码： 12345window.addEventListener('resize', function()&#123; console.log('window.innerWidth:', window.innerWidth, ', window.innerHeight:', window.innerHeight); console.log('document.documentElement.clientWidth:', document.documentElement.clientWidth, ', document.documentElement.clientHeight:', document.documentElement.clientHeight); console.log('document.body.clientWidth:', document.body.clientWidth, ', document.body.clientHeight:', document.body.clientHeight);&#125;); 打开不同的页面（是否有滚动条，页面内容大于视口高度），分析得知： window.innerWidth 和 window.innerHeight 是获取浏览器视口的宽高，包含滚动条。 document.documentElement.clientWidth 和 document.documentElement.clientHeight 是获取浏览器视口的宽高，但不包含滚动条。 document.body.clientWidth 和 document.body.clientHeight 是获取页面的宽高，不包含滚动条 通过也根据结果得出：IE、FF、Chrome的滚动条宽度/高度为 17px， Edge25中滚动条宽度/高度为 12px。 除此之外，还可以通过 window.outerWidth 和 window.outerHeight 获取浏览器的宽高，包含工具栏，标题栏等的宽高。 结论： 12let viewHeight = window.innerHeight || document.documentElement.clientHeight;let viewWidth = window.innerWidth || document.documentElement.clientWidth; 2、获取iframe内容高度iframe 本身等价于一个独立的窗口, 所以要获取iframe内容的高度和获取页面内容高度一致。 在获取视口宽度时，我们知道，通过 document.body.clientHeight 可以获取 body 的高度，那么还有其他的方式可以获取么？ 还是先上一个测试代码： 123456789101112var timerId;window.addEventListener('resize', function () &#123; window.clearTimeout(timerId); timerId = setTimeout(function () &#123; console.log('document.documentElement.clientHeight:', document.documentElement.clientHeight); console.log('document.documentElement.offsetHeight:', document.documentElement.offsetHeight); console.log('document.documentElement.scrollHeight:', document.documentElement.scrollHeight); console.log('document.body.clientHeight:', document.body.clientHeight); console.log('document.body.offsetHeight:', document.body.offsetHeight); console.log('document.body.scrollHeight:', document.body.scrollHeight); &#125;, 200);&#125;); 这个测试的结果如下： 12345678910111213141516171819// ChromedocumentElement.offsetHeight = documentElement.scrollHeight = body.scrollHeightbody.offsetHeight = body.clientHeightdocumentElement.offsetHeight &gt; body.offsetHeight (大24px)// FirefoxdocumentElement.offsetHeight = documentElement.scrollHeightbody.scrollHeight = body.offsetHeight = body.clientHeightdocumentElement.offsetHeight &gt; body.offsetHeight (大24px)// Edge25documentElement.offsetHeight = body.scrollHeight &gt; documentElement.scrollHeight (大1px)body.clientHeight = body.offsetHeightdocumentElement.offsetHeight &gt; body.clientHeight (大24px)// IE11documentElement.offsetHeight = documentElement.scrollHeightbody.scrollHeight = body.offsetHeight = body.clientHeightdocumentElement.offsetHeight &gt; body.offsetHeight (大24px) 根据以上结果，暂时还无法得出结论，所以我们接着测试： 测试一：设置body的margin:0 以上四个都有大24px，先来分析下这个是怎么来的。 初步分析是由于 body 默认的 margin: 8px 导致的，当设置body的 margin: 0 之后，这个差距变成了 16px。 Edge25比较特殊，相关数据变成了： 123documentElement.offsetHeight = documentElement.scrollHeight &lt; body.scrollHeight （小1px）body.clientHeight = body.offsetHeightdocumentElement.offsetHeight &gt; body.clientHeight (大16px) 测试二：给body设置固定高度 此时，我们给body设定一个固定高度，得出以下结果： 1documentElement.offsetHeight = body.clientHeight = body.offsetHeight = 我们设定的高度 测试三：增加超高的 absolute 元素 当absolute元素高度不超过整个页面高度时，无影响。 当absolute元素高度超过整个页面高度时，结果如下： 12345678// Chromebody.scrollHeight = 设定的absolute元素高度// Firefox, IE11documentElement.scrollHeight = 设定的absolute元素高度// Edge25documentElement.scrollHeight = body.scrollHeight = 设定的absolute元素高度 综合以上测试，在这里得出一个获取页面高度的代码如下： 12let pageHeight = Math.max(documentElement.scrollHeight, body.scrollHeight); 注意，以上方案并不具有通用性，还需根据自己的场景来灵活选择。 3、URL编码我们在浏览器中进行URL编码一般有两个方法，encodeURI 和 encodeURIComponent，那它们之间有啥区别呢？ 不多说，先来段代码就知道了： 12345678let str = '_- key fda';console.log(encodeURI(str)); //_-%20key%20fdaconsole.log(encodeURIComponent(str)); //_-%20key%20fdastr = 'https://www.google.com/search?q=Path+must+be+a+string.+Received+null&amp;oq=Path';console.log(encodeURI(str)); //https://www.google.com/search?q=Path+must+be+a+string.+Received+null&amp;oq=Pathconsole.log(encodeURIComponent(str)); //https%3A%2F%2Fwww.google.com%2Fsearch%3Fq%3DPath%2Bmust%2Bbe%2Ba%2Bstring.%2BReceived%2Bnull%26oq%3DPath 由此可以看出，当str是简单的非url字符串时，两者并没有差异。但当我们要对一个完整的URL进行编码的时候，就需要使用 encodeURIComponent 。 4、新Tab打开链接实现一般做法是模拟一个 a 标签，然后打开，代码如下： 123456789var a = document.createElement('a');a.setAttribute('href', url);a.setAttribute('target', '_blank');// 以下两行为兼容IE9而实现，IE9要求必须在body中的a才可以跳转a.style.display = 'none';document.body.appendChild(a);a.click();document.body.removeChild(a); 5、设置iframe内容如果设置局部内容，直接获取 contentDocument 就可以做到，那如果要填充一个完整的HTML文档，该如何做呢？ 123456// 找到documentlet fd = document.getElementById('previewFrame').contentDocument;fd.open(); // 打开输入流fd.write('');fd.write(fullHtml); // 写入完整的HTML内容fd.close(); // 关闭输入流 6、获取滚动高度老规矩，先来段测试代码： 12345678var timerId;window.addEventListener('scroll', function () &#123; window.clearTimeout(timerId); timerId = setTimeout(function () &#123; console.log('document.documentElement.scrollTop:', document.documentElement.scrollTop); console.log('document.body.scrollTop:', document.body.scrollTop); &#125;, 200);&#125;); 通过在浏览器中测试，得到以下结果： 1234567// Chrome and EdgedocumentElement.scrollTop 始终等于 0document.body.scrollTop 是真实的滚动高度// Firefox and IE11documentElement.scrollTop 是真实的滚动高度document.body.scrollTop 始终为0 因此当我们要计算滚动高度的时候，可以采用如下代码： 1let scrollTop = document.documentElement.scrollTop || document.body.scrollTop; 7、获取屏幕大小这个就比较简单了，代码如下： 12345// 屏幕宽度screen.width// 屏幕高度 screen.height"},{"title":"利用Karma、Mocha搭建测试环境","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/测试相关/利用Karma、Mocha搭建测试环境/","text":""},{"title":"使用chai-http实现API测试","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/测试相关/使用chai-http实现API测试/","text":"0x1、导言一个前后端分离的完整的项目中，一般少不了 API TEST，那我们如何来做API相关的测试呢？ 我们可以使用客户端工具（如PostMan），来进行模拟请求，还可以写一个小程序来请求待测试的API。 既然也算是测试，为什么我们不直接和一般的 unit test 使用同样的工具呢？ 在我们使用 mocha 测试工具函数的同时，我们也可以结合 chai-http 来实现API的测试。 0x2、关于 chai-httpchai-http 官方定义是：一个HTTP响应的断言库，是 Chai 断言库的一个补充。（原文：HTTP Response assertions for the Chai Assertion Library. ） 使用它，我们可以模拟发起HTTP请求，然后使用断言语法来判断响应是否满足需求。 1234567chai.request('rootpath') .put('/user/me') .send(&#123; password: '123', confirmPassword: '123' &#125;) .end(function (err, res) &#123; expect(err).to.be.null; expect(res).to.have.status(200); &#125;); 0x3、API测试演示"},{"title":"利用Nightwatch.js实现e2e测试","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/测试相关/利用Nightwatch.js实现e2e测试/","text":""},{"title":"MOCHA测试代码汇总","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/测试相关/MOCHA测试代码汇总/","text":"0x0、导言Mocha是应用最广泛的JS测试框架，但是现在，它的维护者公开说，Mocha快死了，原文Twitter地址。 死不死的理我们太远，我们先来回味一波。。。 0x1、关于单元测试什么是单元测试？ 维基百科： 单元测试（英语：Unit Testing）又称为模块测试, 是针对程序模块（软件设计的最小单位）来进行正确性检验的测试工作 个人理解： 编写测试代码/脚本，通过执行测试代码来保证某一功能（一般是方法）的结果可预期。 如何做单元测试？ 抛开 mocha, 我们应该怎么做单元测试呢？ 我们会考虑书写一段代码或者脚本，来调用我们写好的方法，通过 Console 输出来查看最终结果。 使用单元测试，能够有效的保证代码的正确性，并且有利于我们之后的大胆重构。必须有用例保证，就不怕改出大量新bug。 当然，这仅仅是最原始的测试方式，一般情况下，我们会选择使用单元测试工具。 0x2、MochaMocha(摩卡) 是一个多功能的，支持浏览器和 Node 的 JavaScript 测试工具。仅仅是测试工具，当然还不能满足我们的需要，我们一般还会结合一些插件来进行使用，如下： chai BDD/TDD风格的断言库 chai-http Http请求包 如何用 Mocha 来做单元测试呢？ 首先是引入断言库，然后定义测试块，如下： 1234567const assert = require('assert');describe('Test object exist', () =&gt; &#123; it('first test', () =&gt; &#123; assert.equal(1, 2, '实际值和期望值不一致'); &#125;);&#125;); 多种风格断言演示 测试本身比较容易理解，就我来说，我比较容易忘记断言库的写法，接下来就以 chai 为例，体验下几种方式的断言代码： 第一步，我们要先引入断言库，允许多种风格的断言： 1234const chai = require('chai');const assert = chai.assert; // TDDconst expect = chai.expect; // BDDchai.should(); // BDD 接着，我们来一一演示断言的使用： 判断类型 12345678910111213141516171819202122232425const chai = require('chai');const assert = chai.assert; // TDDconst expect = chai.expect; // BDDchai.should(); // BDDdescribe('Test object exist', () =&gt; &#123; it('object is exist', () =&gt; &#123; let a = 'abc'; let b = 1; let c = true; let d = /xxx/; let e = new Date(); let f = function () &#123; &#125;; let g = &#123;&#125;; let h = []; assert.isString(a); // a必须是字符串 assert.isNotString(f); // f必须不是字符串 expect(b).to.be.a('number'); // b必须是一个数字 expect(c).to.be.a('boolean'); // c必须是boolean d.should.be.a('RegExp'); // d必须是正则 e.should.be.a('date'); // e必须是Date assert.isArray(h); // h必须是Array assert.isObject(g); // g必须是对象 &#125;);&#125;); 判断属性存在与否/属性值是否满足预期 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152const chai = require('chai');const assert = chai.assert; // TDDconst expect = chai.expect; // BDDchai.should(); // BDDdescribe('Test Property', () =&gt; &#123; it('property and value', () =&gt; &#123; let a = &#123; b: 1, c: false, deep: &#123; test: '1' &#125; &#125;; // 对象a必须包含属性b assert.property(a, 'b'); expect(a).has.property('b'); a.should.has.property('b'); // 对象a不能包含属性d assert.notProperty(a, 'd'); expect(a).not.has.property('d'); a.should.not.has.property('d'); // 对象必须有嵌套属性deep.test assert.deepProperty(a, 'deep.test'); expect(a).has.deep.property('deep.test'); expect(a).has.property('deep').has.property('test'); a.should.has.deep.property('deep.test'); a.should.has.property('deep').has.property('test'); // 对象必须不包含嵌套属性deep.test2 assert.notDeepProperty(a, 'deep.test2'); expect(a).not.has.deep.property('deep.test2'); a.should.not.has.deep.property('deep.test2'); // 对象属性值必须等于指定值，注意，是===判断 assert.propertyVal(a, 'b', 1); expect(a).has.property('b', 1); a.should.has.property('b', 1); // 对象属性值必须不等于指定值 assert.propertyNotVal(a, 'c', true); expect(a).not.has.property('c', 0); a.should.not.has.property('c', undefined); // 对象必须包含多个指定的属性 assert.property(a, 'b').property('c').property('deep.test2') expect(a).has.property('a').has.property('c'); &#125;);&#125;); 比较目标值与期望值 12345678910111213141516171819202122232425262728293031const chai = require('chai');const assert = chai.assert; // TDDconst expect = chai.expect; // BDDchai.should(); // BDDdescribe('Test Value', () =&gt; &#123; it('value equal or not equal', () =&gt; &#123; let a = 'abc'; let b = [1, '2', false]; let c = &#123; a: 1, b: &#123; c: 2 &#125; &#125;; // 直接比较 assert.equal('abc', a); expect(a).eql('abc'); a.should.eq('abc'); let cCopy = Object.assign(&#123;&#125;, c); assert.deepEqual(cCopy, c); expect(cCopy).deep.equal(c); cCopy.should.be.deep.equal(c); &#125;); it('test multi equal function', () =&gt; &#123; let c = &#123; a: &#123; b: 'str' &#125; &#125;; let cCopy = Object.assign(&#123;&#125;, c); cCopy.should.be.eql(&#123; a: &#123; b: 'str' &#125; &#125;); // 内容相等即可，不判断引用（别名：eqls, deep.equal, deep.eq, deep.equals） cCopy.should.be.equal(a = cCopy); // 严格完全相等， === 判断（别名：eq, equals） &#125;);&#125;); 目标是否存在 12345678910111213141516171819202122232425const chai = require('chai');const assert = chai.assert; // TDDconst expect = chai.expect; // BDDconst should = chai.should(); // BDDdescribe('Test Value', () =&gt; &#123; it('value exist', () =&gt; &#123; let a = 'hi'; let b = null; let c; // 对象存在 assert.isOk(a); expect(a).to.be.exist; a.should.to.be.exist; // 对象不存在 assert.isNotOk(b); assert.isNotOk(c); expect(b).to.be.not.exist; expect(c).to.be.not.exist; should.not.exist(b); should.not.exist(c); &#125;);&#125;); 判断数组长度 123456789101112131415161718192021222324const chai = require('chai');const assert = chai.assert; // TDDconst expect = chai.expect; // BDDconst should = chai.should(); // BDDdescribe('Test Length', () =&gt; &#123; it('array length', () =&gt; &#123; let arr = [1, 2, 3]; // 判断数组长度 assert.lengthOf(arr, 3); expect(arr).length(3); arr.should.length(3); // 小于4 expect(arr).length.below(4); expect(arr).length.lessThan(4); arr.should.length.below(4); // 大于2 expect(arr).length.above(2); arr.should.length.above(2); &#125;);&#125;); 空判断 1234567891011121314151617181920const chai = require('chai');const assert = chai.assert; // TDDconst expect = chai.expect; // BDDconst should = chai.should(); // BDDdescribe('Test Empty', () =&gt; &#123; it('array|string|object empty', () =&gt; &#123; let arr = []; let a = ''; let b = &#123;&#125;; // 判断数组为空 assert.isTrue(arr.length === 0); // assert没有直接空判断，需要转换一下思路 expect(arr).empty; arr.should.empty; // 其他类型判断（注意：null和undefined不能用此方式判断） expect(a).empty; b.should.be.empty; &#125;);&#125;); 注意：还有其他较多的用法，如果理解了上面的这几种，按照同样的思路，结合api就基本能使用其他的模式了。一般情况下，以上的几种断言也足够我们使用了。 注意2：更多断言，请参考： chai断言API"},{"title":"从零开始H5（二）：HTML5新技术点","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/从零开始H5/从零开始H5（二）：HTML5新技术点/","text":"现在，将我们的页面升级到HTML5了。为什么要这样去做呢？通过简单的升级我们没看到任何大的变化。 答案即将揭晓，升级到HTML5之后，我们可以使用如下技术： 1、不再需要插件，就有对音频\\视频的内置支持，可以充分利用HTML5新增了&lt;audio&gt;和&lt;video&gt;标签，可以让我们操作音视频。 2、更有描述性的标记针对Web语义化，HTML5新增了许多带有特定语义的标签，如header、footer、section、article、dialog、summary等等。 3、富客户端支持，可以使用画布、转换和JavaScript创建炫酷的界面和动画使用画布（canvas）和JavaScript，我们可以直接在Web页面上画图像、线条等，同时对开发Web游戏也是更加友好的。 4、新增客户端存储和缓存功能使用Application-Cache，我们可以让我们的网页离线浏览，同时可以采用localStorage和sessionStorage来存储数据。 5、新增Web工作线程，让JavaScript更高效可以让耗时的JS，在后台工作，让UI的响应更快，提高用户体验。 6、可以结合CSS3的新内容，如高级选择器、动画、阴影可以让元素运行动画，也可以让元素具有圆角边框，甚至阴影。也能通过简单的代码快速选择对象。 7、新增位置API（移动设备）通过该API，页面能够知道访问者的地理位置，这在移动设备访问中，尤其重要。"},{"title":"从零开始H5（一）：升级你的HTML到HTML5","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/从零开始H5/从零开始H5（一）：升级你的HTML到HTML5/","text":"现有的网页大部分还是基于HTML4开发的，那么如何简单的升级到HTML5呢？1、从doctype定义开始HTML4： &lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt; HTML5： &lt;!doctype html&gt; 注意：这不仅仅是HTML5的doctype，这也是HTML将来所有版本的doctype。不仅如此，它甚至在老版本的浏览器中也能正常工作。 2、简化metaHTML4： &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt; HTML5： &lt;meta charset=&quot;utf-8&quot; /&gt; 3、简化link标记HTML4： &lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;index.css&quot; /&gt; HTML5： &lt;link rel=&quot;stylesheet&quot; href=&quot;index.css&quot; /&gt; 注意：升级到HTML5后，使用link不在需要指定type了，因为已经宣布CSS作为HTML5的标准样式，这也是HTML5的默认样式。 4、简化script标记HTML4： &lt;script type=&quot;text/javascript&quot; src=&quot;index.js&quot;&gt;&lt;/script&gt; HTML5： &lt;script src=&quot;index.js&quot;&gt;&lt;/script&gt; &lt;script&gt; console.log(&apos;html5&apos;); &lt;/sscript&gt; 注意：对于HTML5，JavaScript已经成为标准，所以不在需要指定type了，同时，对于script标签，结尾标记不能简写。 Q/A1、为什么做了这些改变，在老式浏览器上也能用？拿link和script来说，浏览器早已假定默认使用CSS和JavaScript，所以和标准一致。包括doctype和meta也是一样。 2、doctype以后也不会在变了，合适吗？doctype的使用主要在于告诉浏览器采用它们的”标准模式”表现内容，所以不管以后HTML6或者其他，&lt;!doctype html&gt;已经足够表达意思了。 3、XHTML怎么了？很多年前听说它是未来的发展方向？它夭折了。因为灵活性超过了严格语法。当然，如果你喜欢XML，那么还可以用严格模式编写HTML5。"},{"title":"JSONP详解","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/前端相关/JSONP详解/","text":"0、关于JSONP什么的JSONPJSONP（JSON with Padding）是资料格式 JSON 的一种“使用模式”，可以让网页从别的网域要资料。另一个解决这个问题的新方法是跨来源资源共享。（参考：https://zh.wikipedia.org/wiki/JSONP） JSONP的起源 曾经的Ajax不能跨域请求（现在的也不能，不过有cors） Web上使用script调用js文件不存在跨域问题（实际上，只要拥有src属性的标签都允许跨域，比如script,img,iframe） 那个时候，想要通过web端跨域访问数据，只可以在服务器端设法把数据装进js，然后客户端调用 刚好这个时候JSON大行其道 所以，解决方案就出来，web端像调用脚本一样来跨域请求服务器上动态生成的js文件 为了便于客户端使用数据，逐渐形成了一种非正式传输协议，人们把它称作JSONP。 JSONP用来做什么通过JSONP的起源，我们大概也知道了JSONP就是为了跨域资源访问的。 1、JSONP实现原理我们知道，在script标签中请求的js代码，到客户端之后，是能被自动执行的。 我们先构造一个后端（采用node实现）： var http = require(&apos;http&apos;); var server = http.createServer((req, res) =&gt; { var sendObj = { url: req.url, name: &apos;test&apos; }; res.write(`callback(${JSON.stringify(sendObj)})`); res.end(); }); server.listen(9999, () =&gt; { console.log(&apos;started.&apos;) }); 我们要使用这个这个数据呢？可以用Ajax，可能会产生跨域问题 另外，可以用如下写法： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;JSONP TEST&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; function callback(obj){ console.log(obj); } &lt;/script&gt; &lt;script src=&quot;http://localhost:9999/abc&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 打开这个页面后，我们会看到控制台会输出一个对象Object {url: &quot;/abc&quot;, name: &quot;test&quot;},也就是后端返回的对象。 当使用script请求地址时，会将返回的字符串，默认当成js解析。由于后端返回是的callback(xxx),所以会调用本地的callback函数。 从原理上来看，要使用JSONP，必须要后端返回相应的数据，这个就是JSONP的模式了，允许客户端传递一个callback函数，后端将数据包裹在callback函数中返回。 从原理也能看出，JSONP并不要求必须传递JSON格式的数据，只要是JS函数能够认可的数据都是可以传递的 2、封装JSONP调用JSONP知道了原理，我们很容易能够实现一个jsonp的函数调用，代码如下： window.JSONP = function(url, callback){ callback = callback || &apos;callback&apos;; var result; return new Promise((resolve, reject) =&gt; { var overwritten; var scriptEl = document.createElement(&apos;script&apos;); scriptEl.src = url + &apos;?callback=&apos; + callback; //加载完成后，删除callback scriptEl.onload = function(){ if(overwritten === undefined){ delete window[callback]; }else{ window[callback] = overwritten; } resolve(result); } //挂载一个callback到window上 overwritten = window[callback]; //先保存一个，用完之后再还原 window[callback] = function(data){ result = data } document.head.appendChild(scriptEl); }); }; 如何用？ window.JSONP(&apos;http://localhost:9999/abc&apos;).then((data) =&gt; { console.log(data); }); 3、扩展在jQuery中，我们使用jsonp感觉就和使用ajax没有区别，但实际上它们的底层实现实现是完全不一样的，毕竟原理都不同。 虽然很多库和框架都把jsonp封装到了ajax中，但是一定要记得jsonp不是ajax的一个特例。 当前，除了用jsonp跨域之外，还可以采用服务端代理（通过不跨域的后端程序，发送webClient去请求数据，然后转发），CORS（API服务器允许跨域的一种设置）。"},{"title":"CORS详解","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/前端相关/CORS详解/","text":"0、关于CORS说到CORS，就不得不先了解跨站HTTP请求（Cross-site HTTP request）。 跨域HTTP请求是指发起请求的资源所在域不同于该请求所指向资源所在的域的HTTP请求。 正如大家所知，出于安全考虑，浏览器会限制脚本中发起的跨站请求。使用XMLHttpRequest发起HTTP请求必须遵守同源策略。 具体而言，Web 应用程序能且只能使用 XMLHttpRequest 对象向其加载的源域名发起 HTTP 请求，而不能向任何其它域名发起请求。 由于Web应用技术越来越丰富，我们非常渴望在不丢失安全的前提下，能够实现跨站请求。特别是现在的Web程序结构，一般是HTML+REST API。在之前的实现中，我们一般采用jsonp来发起跨站请求，这其实是利用了html标签的特点。 W3C的Web应用工作组推荐了一种新的机制，即跨域资源共享（Cross-Origin Resource Sharing），也就是当前我们提到的CORS。 CORS的核心，就是让服务器来确定是否允许跨域访问。 1、典型场景1.1、简单请求什么是简单请求？全部满足以下条件的请求可以称之为简单请求： 只使用GET、HEAD或者POST请求方法。如果是POST，则数据类型（Content-Type）只能是application/x-www-form-urlencodeed、multipart/form-data、text/plain中的一种。 没有使用自定义的请求头（如x-token） 按照这个规则，那我们的能实现跨域请求的情况如下： Server代码： 12345678910111213'use strict';var http = require('http');var server = http.createServer((req, res) =&gt; &#123; //之后设置了Access-Control-Allow-Origin，才会允许跨域 res.setHeader('Access-Control-Allow-Origin', '*'); res.write('abc'); res.end();&#125;);server.listen(10000, () =&gt; &#123; console.log('started.');&#125;); Client代码： 1234567891011121314151617181920212223242526var xhr = new XMLHttpRequest();xhr.onreadystatechange = function()&#123; if(xhr.readyState === XMLHttpRequest.DONE)&#123; console.log('Result：', xhr.responseText); &#125;&#125;//场景一：GET请求，不需要Header，允许跨域xhr.open('GET', 'http://localhost:10000/', true);xhr.send();//场景二： POST请求，需要设置为指定Header（不设置content-type也可），允许跨域xhr.open('POST', 'http://localhost:10000/', true);//此处value必须是text/plain或者application/x-www-form-urlencoded或者multipart/form-data。//此处也可以不设置xhr.setRequestHeader('Content-Type', 'text/plain');xhr.send();//场景三：DELETE请求（不允许跨域）xhr.open('DELETE', 'http://localhost:10000/', true);xhr.send();//场景四：POST请求，有自定义Header（不允许跨域）xhr.open('POST', 'http://localhost:10000/', true);xhr.setRequestHeader('x-token', 'a');xhr.send(); 1.2、预请求不同于简单请求，预请求要求必须先发送一个OPTIONS请求给站点，来查明该站点是否允许跨域请求，这样做的原因是为了避免跨站请求可能对目的站点的数据造成的损坏。 如果请求满足以下任一条件，则会产生预请求： 请求以GET、HEAD、POST之外的方法发起。或者，使用POST，但数据类型为application/x-www-form-urlencoded, multipart/form-data 或者 text/plain 以外的数据类型。（注：之前的版本只有text/plain可以不用发起预请求）。 使用了自定义请求头。 按照如上规则，我们来列举几个应用场景： Server端代码： 123456789101112131415161718'use strict';var http = require('http');var server = http.createServer((req, res) =&gt; &#123; //之后设置了Access-Control-Allow-Origin，才会允许跨域 res.setHeader('Access-Control-Allow-Origin', '*'); res.setHeader('Access-Control-Allow-Methods', 'POST, DELETE, GET'); res.setHeader('Access-Control-Allow-Headers', 'x-token'); //设置预请求缓存1天，1天内再次请求，可以跳过预请求 //此功能需要客户端缓存支持，如果客户端禁用缓存，那么每次都会预请求 res.setHeader('Access-Control-Max-Age', 60 * 60 * 24); res.write('abc'); res.end();&#125;);server.listen(10000, () =&gt; &#123; console.log('started.');&#125;); Client端代码： 123456789101112131415161718192021222324var xhr = new XMLHttpRequest();xhr.onreadystatechange = function()&#123; if(xhr.readyState === XMLHttpRequest.DONE)&#123; console.log('Result：', xhr.responseText); &#125;&#125;//场景一：DELETE请求，发送OPTIONS，匹配，允许跨域xhr.open('DELETE', 'http://localhost:10000/', true);xhr.send();//场景二：PUT请求，发送OPTIONS，不匹配，不允许跨域xhr.open('PUT', 'http://localhost:10000/', true);xhr.send();//场景三：DELETE请求匹配，使用自定义Header不匹配，不允许跨域xhr.open('DELETE', 'http://localhost:10000/', true);xhr.setRequestHeader('x-token1', 'aa');xhr.send();//场景四：POST请求，匹配的自定义Header，允许跨域xhr.open('POST', 'http://localhost:10000/', true);xhr.setRequestHeader('x-token', 'a');xhr.send(); 1.3、带凭证的请求一般来说，对于跨站请求，浏览器是不会发送凭证（HTTP Cookies和验证信息）的。如果要发送带凭证的信息，只需要给XMLHttpRequest设置一个特殊的属性withCredentials = true，通过这种方式，浏览器就允许发送凭证信息。 带凭证的请求可能是简单请求，也可以是会有预请求。是否允许跨域，会先判断简单请求和预请求的规则，然后还会带上带凭证的请求自己的规则。 在带凭证的请求中，后端的响应必须包含HeaderAccess-Control-Allow-Credentials=true，同时Header Access-Control-Allow-Origin，不能再使用*号这种匹配符。 具体示例如下： 服务端代码： 123456789101112131415161718'use strict';var http = require('http');var server = http.createServer((req, res) =&gt; &#123; //要处理带凭证的请求，此Header不能使用*。 res.setHeader('Access-Control-Allow-Origin', 'http://10.16.85.170:8000'); res.setHeader('Access-Control-Allow-Methods', 'POST, DELETE, GET'); res.setHeader('Access-Control-Allow-Headers', 'x-token'); res.setHeader('Access-Control-Max-Age', 60 * 60 * 24); //只有设置了该Header，才允许带凭证的请求。 res.setHeader('Access-Control-Allow-Credentials', true); res.write('abc'); res.end();&#125;);server.listen(10000, () =&gt; &#123; console.log('started.');&#125;); 客户端代码： 1234567891011var xhr = new XMLHttpRequest();xhr.onreadystatechange = function()&#123; if(xhr.readyState === XMLHttpRequest.DONE)&#123; console.log('Result：', xhr.responseText); &#125;&#125;//优先满足预请求，然后满足凭证请求，允许跨域。xhr.open('POST', 'http://localhost:10000/', true);xhr.withCredentials = true;xhr.setRequestHeader('x-token', 'a');xhr.send(); 2、HTTP响应头2.1、 后端HTTP响应头此处列举后端有关CORS的响应头： Access-Control-Allow-Origin： | * 允许的域名 Access-Control-Expose-Headers: 允许的白名单Header，多个用逗号隔开 Access-Control-Max-Age: 预请求缓存时间，单位秒 Access-Control-Allow-Credentials: true | false 是否允许带凭证的请求 Access-Control-Allow-Methods: 允许的请求类型，多个用逗号隔开 Access-Control-Allow-Headers: 在实际请求中，允许的自定义header，多个用逗号隔开 2.2、 浏览器发出跨域请求的响应头此处列举出浏览器在发送跨域请求时，会带上的响应头： Origin: 告诉服务器，请求来自哪里，仅仅是服务器名，不包含路径。 Access-Control-Request-Method: 预请求时，告诉服务器实际的请求方式 Access-Control-Request-Headers: 预请求时，告诉服务器，实际请求所携带的自定义Header 3、参考资料 MDN HTTP access control (CORS) MDN HTTP访问控制(CORS)"},{"title":"CSS布局（上）","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/前端相关/CSS布局（上）/","text":"1、CSS布局之display1.1、dispalydispaly是CSS中最重要的用于控制布局的属性，每个元素都有一个默认的display，大多数元素的默认值通常是block（块级元素）或inline（行内元素）。 另一个常用的display是none。一些特殊元素的默认值就是它，如script、link等。 1.2 display:none 与 visibility:hiddendisplay设置为none，是不会保存元素本该显示的空间，但是visibility:hidden会保留。 &lt;div style=&quot;width: 100px; height: 100px; border: 1px solid red;float:left;&quot;&gt; &lt;span style=&quot;display:none;&quot;&gt;ABCD&lt;/span&gt;EFG &lt;/div&gt; &lt;div style=&quot;width: 100px; height: 100px; border: 1px solid red;float:left;&quot;&gt; &lt;span style=&quot;visibility:hidden;&quot;&gt;ABCD&lt;/span&gt;EFG &lt;/div&gt; ABCDEFG ABCDEFG### 1.3、更多的display值比较常用的有list-item,inline-block,table,table-cell,flex等。全部列表如下： none inline block contents list-item inline-block inline-table table table-cell table-column table-column-group table-footer-group table-header-group table-row table-row-group flex inline-flex grid inline-grid ruby ruby-base ruby-text ruby-base-container ruby-text-container run-in / Global values / display: inherit; display: initial; display: unset;### 1.4 可改写的display属性虽然每个元素都有默认的display，但是我们可以随时随地的重写它，比如将li元素修改为inline-block，制作水平菜单。## 2、元素居中### 2.1、水平居中通过设置margin为auto可以实现水平居中，前提是元素必须得有宽度 2.2、垂直居中因为table的cell可以设置垂直居中，所以玩么可以模拟这样的效果 &lt;div style=&quot;width: 400px;height: 200px;border: 1px solid red;display: table-cell; vertical-align: middle;&quot;&gt; &lt;div style=&quot;width:100px; height:100px;background: blue;&quot;&gt;&lt;/div&gt; &lt;/div&gt; 2.3、绝对居中知道水平居中和垂直居中，那么绝对居中就比较容易实现了。组合一下： &lt;div style=&quot;width: 200px;height: 200px;border: 1px solid red;display: table-cell; vertical-align: middle;&quot;&gt; &lt;div style=&quot;width:100px; height:100px;background: blue;margin:0 auto;&quot;&gt;&lt;/div&gt; &lt;/div&gt; 还有没有更好的方式呢？如下： 通过设置position:absolute,然后top、bottom、left、right值为0，margin:auto;实现绝对居中。如果要相对容器居中，设置容器的position为relative。 &lt;div style=&quot;width: 200px;height: 200px;border: 1px solid red; position:relative;&quot;&gt; &lt;div style=&quot;width:100px; height:100px;background: blue;margin:auto;position:absolute;top:0;left:0;bottom:0; right: 0;&quot;&gt;&lt;/div&gt; &lt;/div&gt; 3、盒子模型盒子模型(box-sizing)有两种典型值，分别为content-box,border-box。 3.1、content-box此时，设置在元素上的宽度为内容宽度，那么元素所占用的宽度为：width + border * 2 + padding * 2 + margin * 2。宽度同理 3.2、border-box此时，设置在元素上的宽度为包含border的宽度，那么占用总宽度为width + margin * 2。内容宽度为width - padding * 2 - border * 2。 3.3 示例&lt;div style=&quot;width:100px; margin: 10px; padding: 15px; border: 5px solid blue; box-sizing:content-box&quot;&gt;&lt;/div&gt; &lt;div style=&quot;width:100px; margin: 10px; padding: 15px; border: 5px solid blue; box-sizing:border-box&quot;&gt;&lt;/div&gt; 3.4、浏览器兼容性为了保证浏览器兼容性，需要加上特定浏览器前缀。 4、元素定位如果要实现更多复杂的布局，那么就需要了解下position了。 4.1、position:staticstatic是position属性的默认值，position:static的元素不会被特殊定位。 4.2、position:relative在相对定位(relative)的元素上设置top、right、bottom、left会使其偏离正常位置，其他元素不会调整位置来弥补它偏离后剩下的空隙。 &lt;div style=&quot;border:1px solid red; width: 400px; height: 200px;&quot;&gt; &lt;div style=&quot;background: blue; width:100px; height: 100px;&quot;&gt;&lt;/div&gt; ABCDE &lt;/div&gt; &lt;div style=&quot;border:1px solid red; width: 400px; height: 200px;&quot;&gt; &lt;div style=&quot;background: blue; width:100px; height: 100px;position:relative; left: 100px;top:50px;&quot;&gt;&lt;/div&gt; ABCDE &lt;/div&gt; ABCDE ABCDE 4.3、position:fixed固定定位（fixed）元素会相对于视窗来定位，所以就算页面滚动，它还是会留在相同位置。示例请看左下角。 &lt;div style=&quot;width: 100px;height:100px; position:fixed; bottom: 0; right: 0; border: 1px solid red;&quot;&gt;固定定位&lt;/div&gt; 固定定位 4.4、position:absolute绝对定位元素（absolute）与fixed类似，但是它不是相对视窗，而是相对最近的positioned（position值不是static的元素都是positioned元素）祖先元素，如果没有这样的祖先元素，那么它相对于文档的body元素，并且会随着页面滚动而滚动。 &lt;div style=&quot;border:1px solid red; width: 400px; height: 200px;position:relative;&quot;&gt; &lt;div style=&quot;background: blue; width:100px; height: 100px;position:absolute;top: 25px;right:25px;&quot;&gt;&lt;/div&gt; &lt;/div&gt;"},{"title":"Iframe跨域通信的几种方式","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/前端相关/Iframe跨域通信的几种方式/","text":"0、前言虽然iframe已经越来越不流行了，但是在某些特定的场景下，使用它可以大大减小我们的工作量。 当在页面内使用iframe，甚至是嵌套iframe的时候，它们之间少不了要通信。如果是同域的情况，那我们可以直接进行通信。 然而，很多场景下，往往是跨域通信，那这个时候我们可以用怎样的方式来跨域通信呢？ 请看此文分解。 1、重现跨域我们新建两个 index.html，分别部署两个不同的端口上。 12345678910111213// localhost:8001/index.html...&lt;body&gt; &lt;h1&gt;Page1&lt;/h1&gt; &lt;iframe src=\"http://localhost:8003\" frameborder=\"5\" style=\"width: 100%;height: 300px\"&gt;&lt;/iframe&gt; &lt;script&gt; window.getPage1Title = function()&#123; return 'abc'; &#125;; &lt;/script&gt;&lt;/body&gt;... 1234567891011// localhost:8003/index.html&lt;body&gt; &lt;h1&gt;Page2&lt;/h1&gt; &lt;button onclick=\"fun1();\"&gt;Test&lt;/button&gt; &lt;script&gt; function fun1()&#123; var parentTitle = window.parent.getPage1Title(); alert(parentTitle); &#125; &lt;/script&gt;&lt;/body&gt; 从浏览器打开 http://localhost:8001，然后点击iframe中的按钮，会出现一个如下提示： 1(index):15 Uncaught SecurityError: Blocked a frame with origin &quot;http://localhost:8003&quot; from accessing a frame with origin &quot;http://10.16.85.170:8001&quot;. Protocols, domains, and ports must match. 简而言之，就是不允许跨域访问。 2、方式1 - 通过修改domain来实现跨域访问该方式适合主域相同，而子域不同的场景。此时可以在多个iframe中，通过修改document.domain = ‘主域’ 的方式来实现跨域。 特定场合适用，不推荐 3、方式2 - 通过 window.name 跨域访问该方式原理是通过先请求其他的域的页面，把要传输的值赋值给 window.name 属性，然后把该iframe的src地址，修改为不跨域的一个页面。此时，由于是同一个iframe，所以name还是之前的数据，通过这样的方式变相的来获取其他域的数据。 示例如下： 在子页面中，仅仅需要把数据赋值给 window.name123456789// localhost:8003/index.html...&lt;body&gt; &lt;h1&gt;Page2&lt;/h1&gt; &lt;script&gt; window.name = '我是page2的数据'; &lt;/script&gt;&lt;/body&gt;... 父页面中，需要修改iframe为不跨域，然后获取数据 1234567891011121314151617181920// localhost:8001/index.html...&lt;body&gt; &lt;h1&gt;Page1&lt;/h1&gt; &lt;iframe id=\"f1\" frameborder=\"5\" style=\"width: 100%;height: 300px\"&gt;&lt;/iframe&gt; &lt;script&gt; var iframe = document.getElementById('f1'); var isCrossFrameUrl = true; iframe.onload = function()&#123; if(isCrossFrameUrl)&#123; iframe.src = 'about:block;'; isCrossFrameUrl = false; return; &#125; console.log(iframe.contentWindow.name); &#125;; iframe.src = 'http://localhost:8003'; &lt;/script&gt;&lt;/body&gt;... 这种方式实现起来，比较别扭，另外只能获取单次数据，并不友好，不推荐使用。 4、方式3 - 通过 navigator 对象来跨域(已过期，不能使用了)该方式利用多个iframe窗口，访问的 navigator 对象都是同一个，而且并没有跨域问题这个原理；通过在该对象上注册和发送事件的方式来跨域访问。 5、通过 window.postMessage 传递消息这是IE8+之后正统的iframe跨域解决方案，全称“跨文档消息”，是一个HTML5的新特性。 1otherWindow.postMessage(message, targetOrigin, [transfer]); 其中第一个参数是消息对象，允许JS数据类型，第二个是要发送到的域，可以设置为 * 表示不限制。 使用如下： 123456789101112// localhost:8001/index.html...&lt;body&gt; &lt;h1&gt;Page1&lt;/h1&gt; &lt;iframe id=\"f1\" src=\"http://localhost:8003/\" frameborder=\"5\" style=\"width: 100%;height: 300px\"&gt;&lt;/iframe&gt; &lt;script&gt; window.addEventListener('message', function(evt)&#123; console.log(evt); &#125;); &lt;/script&gt;&lt;/body&gt;... 123456789// localhost:8003/index.html...&lt;body&gt; &lt;h1&gt;Page2&lt;/h1&gt; &lt;script&gt; parent.postMessage('test', '*'); &lt;/script&gt;&lt;/body&gt;... 打开 http://localhost:8001 就可以看到父页面已经收到子页面发过来的消息了。 evt对象有几个重要的属性需要我们去了解一下： data // 具体发送的数据 origin // 发送者origin（http://localhost:8003） source // 发送者（window对象） 该方式是当前最合适的跨文档通信方式，如果没有兼容IE6、7的需求，建议全部使用该方式。"},{"title":"CSS布局（下）","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/前端相关/CSS布局（下）/","text":"1、CSS布局之浮动1.1、float之图文混排float的意思就是元素漂浮在上层。 可以直接通过设置float属性实现图文混排，代码如下： &lt;div style=&quot;width:200px;height:200px;border: 1px solid gray;&quot;&gt; &lt;img src=&quot;&quot; alt=&quot;&quot; style=&quot;width:100px;height:100px;float:right;&quot;&gt; Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus imperdiet, nulla et dictum interdum, nisi lorem egestas odio, vitae scelerisque enim ligula venenatis dolor. &lt;/div&gt; Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus imperdiet, nulla et dictum interdum, nisi lorem egestas odio, vitae scelerisque enim ligula venenatis dolor. 1.2、float的副作用当为元素设置float只有，它将会漂浮起来。那么它之后的元素就会忽略它，而进行定位。所以会导致元素重叠： &lt;div style=&quot;width:50px;height:50px;border:1px solid red;float:left&quot;&gt; 我是悬浮元素 &lt;/div&gt; &lt;div style=&quot;width:100px;height:100px;border:1px solid blue;&quot;&gt; 我是标准div元素内容 &lt;/div&gt; 我是悬浮元素 我是标准div元素内容 这个时候，就需要清除浮动(clear:both)，另外，还可以通过clear:left|right来分别清除左右浮动： &lt;div style=&quot;width:50px;height:50px;border:1px solid red;float:left&quot;&gt; 我是悬浮元素 &lt;/div&gt; &lt;div style=&quot;width:100px;height:100px;border:1px solid blue;clear:both;&quot;&gt; 我是标准div元素内容 &lt;/div&gt; 我是悬浮元素 我是标准div元素内容 1.3、奇怪的浮动效果在内容的浮动元素高度大于外部容器时，效果如下： &lt;div style=&quot;width:100px;border:1px solid blue;&quot;&gt; &lt;div style=&quot;width:50px;height:150px;border:1px solid red;float:right&quot;&gt; 我是悬浮元素 &lt;/div&gt; 我是标准div元素内容 &lt;/div&gt; 我是悬浮元素 我是标准div元素内容 如何修复？可以通过clearfix样式来修复： .clearfix { overflow: auto; zoom: 1;/针对IE需要额外关照/ } 我是悬浮元素 我是标准div元素内容 .clearfix { overflow: auto; zoom: 1;/针对IE需要额外关照/ } 我是悬浮元素 我是标准div元素内容 2、CSS布局之百分比宽度百分比宽度可以非常容易的实现动态布局，但是当窗口变得很窄的时候，元素的展示可能会错乱。所以需要选择最合适的布局方式。 另外，不能使用min-width来修复这个问题，因为如果是左右结构，对左边的元素设定min-width，右边的元素是不会遵守的，可能会引起重叠。 3、CSS布局之媒体查询（Media Query）“响应式设计（Responsive Design）”是一种让网站针对不同的浏览器和设备“响应”不同显示效果的策略，这样可以让网站在任何情况下显示的很棒！ 如果要兼容移动端，请加上如下类似meta &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, maximum-scale=2, minimum-scale=0.5, user-scalable=no&quot;&gt; 因为众所周知，手机端的屏幕分辨率相当多，所以可以强制指定屏幕的width是等于设备宽度的，忽略分辨率。maximum-scale 是指最大缩放比例。 4、CSS布局之columnCSS columns是较新的标准，不支持IE9及以下和Opera Mini，所以需要使用浏览器前缀。Column可以很轻松的实现文字的多列布局，示例如下： &lt;div style=&quot;width:150px;-webkit-column-count:3;-webkit-column-gap: 1em;&quot;&gt; CSS布局CSS布局CSS布局CSS布局CSS布局CSS布局CSS布局CSS布局CSS布局CSS布局 &lt;/div&gt; CSS布局CSS布局CSS布局CSS布局CSS布局CSS布局CSS布局CSS布局CSS布局CSS布局 5、CSS布局之flexboxflexbox布局模式被用来重新定义CSS中的布局方式。 &lt;style&gt; .container{ width: 80%; border: 1px solid red; height:50px; display: flex; } &lt;/style&gt; &lt;div class=&quot;container&quot;&gt; &lt;div style=&quot;width:100px;&quot;&gt;&lt;/div&gt; &lt;div style=&quot;flex:3;background:lightgray;&quot;&gt;1&lt;/div&gt; &lt;div style=&quot;flex:5;background:lightyellow;&quot;&gt;2&lt;/div&gt; &lt;/div&gt; .container{ width: 80%; border: 1px solid red; height:50px; display: flex; } 1 2 分析一下以上代码，只需要在容器上设置display:flex，那么内部元素的如果设置了flex样式，那么就会按照flex进行计算，然后实现flex布局。 flex布局，还能实现简单的垂直居中布局。 &lt;div class=&quot;container&quot; style=&quot;align-items: center; justify-content: center;&quot;&gt; 我是垂直居中的元素 &lt;/div&gt; 我是垂直居中的元素 其中，align-items设置水平居中，justify-content设置了垂直居中。"},{"title":"Nginx常规用法解析","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/前端相关/Nginx常规用法解析/","text":"0、Nginx简介Nginx 是时下最流行的静态Web服务器之一，使用它能快速的托管一个web站点。 当然，它的功能并不仅限于此，负载均衡，反向代理，它都非常拿手。 然而，要使用它，就不得不提到它的配置文件。本文就大致来了解下 Nginx 常规配置。 注意：由于环境因素，该文所有测试均在Win10上使用 nginx-1.11.5 测试通过。 1、如何开始？1.1、安装注意：该安装是指在Windows上安装 首先，我们进入 Nginx 的下载地址：https://nginx.org/en/download.html（书写该文时，nginx 最新版本是 1.11.5）。 然后，找到nginx的Windows压缩包并下载，然后解压到指定目录即可。 提示：Linux下安装也是同样的思路，下载压缩包，解压缩。 1.2、启动解压好之后，进入解压目录，我们会看到一个 nginx.exe，它就是 nginx 的启动文件。 进入该目录的cmd环境，执行 nginx 即可启动 nginx，此时我们打开的是一个阻塞的控制台。当我们关闭控制台之后，nginx 服务也相应的关闭了。 大部分时候，我们需要它能在后台执行，此时我们可以使用 start nginx 来启动一个后台运行的 nginx 实例。 如果是线上环境，可能还要求它能够开机启动，此时我们可以采用把 nginx 作为Windows服务的方式来实现开机启动，具体做法请参考： http://www.spkevin.com/?p=946。 1.3、重新载入配置当我们后台启动 nginx 之后，如果修改了配置文件，想重新载入配置怎么办呢？当然，我们可以停止，然后再启动。实际上，还有更简单的方法，执行如下命令： 12345# 重新载入配置文件$ nginx -s reload# 重新打开日志文件$ nginx -s reopen 1.4、停止服务12345# 停止（快速停止，不保存相关信息，快）$ nginx -s stop# 退出（完整有序的停止，保存相关信息，慢）$ nginx -s quit 2、托管静态目录托管静态目录是 Nginx 最常用的功能之一，该功能是将一个目录部署为一个静态的Web站点。 先使用 start nginx 启动 nginx（默认绑定的是80端口，可能会有冲突，需要修改下端口绑定）。 修改端口绑定：在 nginx/conf 的目录下，打开 nginx.conf 配置文件，找到80，修改为另外一个端口号即可。 启动之后，我们直接输入 http://localhost:&lt;port&gt; 即可查看到Nginx的欢迎页面。 先来分析下它的配置文件： 1234567891011http &#123; ... server &#123; listen 7777; location / &#123; root html; # 从html相对目录查找内容 index index.html index.htm; # 默认首页查找顺序 &#125; &#125;&#125; 什么意思呢？我们主要需要关注 server/location 节点，其中 root属性 表示去哪个目录查找文件，index属性 表示默认首页查找顺序。 2.1、托管多个站点当我们要托管多个站点的时候，我们可以以同样的方式，创建多个 server 节点，这样就能监听不同的端口，也能托管不同的目录。 2.2、有条件查找（复杂实例）123456789101112131415161718192021server &#123; listen 8101; # 监听8101端口 server_name newegg-central-2.0; # 设置server_name，类似iis的主机头 root /dist; index index.html; location ~* \\.(eot|ttf|woff|woff2)$ &#123; # 针对字体请求做特殊处理 add_header x-nc2-server $server_addr; add_header Access-Control-Allow-Origin '*'; # 允许字体跨域 &#125; location ~* \\.[a-zA-Z0-9]+$ &#123; # 针对有后缀名的请求特殊处理，直接返回 add_header x-nc2-server $server_addr; &#125; location / &#123; # 针对不满足上述条件的请求做处理 add_header x-nc2-server $server_addr; access_log off; error_page 404 = /index.html; # 如果遇到了404，则返回首页（为浏览器history api做的特殊处理，客户端路由） &#125;&#125; 3、反向代理反向代理是根据客户端的请求，从后端的服务器上获取资源，然后再将这些资源返回给客户端。所以我们需要一个后端，此处随便找一个站点来测试，如 “www.newegg.com”，让如何实现我们访问 localhost:7778，就能返回 newegg的数据呢？ 配置如下： 123456server &#123; listen 7778; # 监听7778端口 location / &#123; proxy_pass http://www.newegg.com; #根据客户端请求返回newegg的数据 &#125;&#125; 3.1、利用反向代理，处理跨域跨域是前后端分离项目中，比较容易遇到的一个问题，在这里演示下，如何利用Nginx来避免跨域问题。 该方法的原理是，将API通过反向代理，让它看起来和站点是在同一个域，避免发起跨域请求。 先在7777端口托管的index.html中添加如下代码： 12345&lt;script&gt; let xhr = new XMLHttpRequest(); xhr.open('GET', 'http://localhost:7779', true); xhr.send();&lt;/script&gt; 访问 http://localhost:7777，可以明显的看到有跨域请求，接下来，我们来解决该问题， 首先，修改请求域名为： http://localhost:7777/api 这样就变成了同域，然后配置 nginx，把 /api的请求转发到真实的后端api上。 配置如下： 12345678location / &#123; root html; index index.html index.htm;&#125;location /api &#123; # 把所有已/api 开头的请求，转发到7779端口 proxy_pass http://localhost:7779;&#125; 4、负载均衡负载均衡是将应用部署到多个地方，然后用统一入口访问，解决单点故障问题。 先用 Node 创建两个 Web server，代码如下： 123456789101112// Server 1const http = require('http');let server = http.createServer((req, res) =&gt; &#123; res.write('Server 1, port: 7801'); res.end();&#125;);server.listen(7801, err =&gt; &#123; if(err) return console.error(err); console.log('server 1 started.port: 7801');&#125;); 为了方便查看效果，我们将 Server 2 的端口修改为 7802，输出的文字也稍微变下。 接下来我们来进行负载均衡的配置，在 nginx 中，负载均衡有几种方式： 轮询（默认方式） 加权轮询（轮询升级版，可以指定权重） ip_hash（通过ip计算hash，然后跳转到指定服务器） fair（第三方，根据后台服务器的响应时间来分配请求，响应时间短，优先分配，适应性较强） upstream_hash（ip hash升级版，可以指定hash因子） 这里我们就简单测试下前两种方式，实现配置如下： 1234567891011121314http &#123; ... upstream test_server &#123; server localhost:7801; # 后端服务器1, server localhost:7802; # 后端服务器2 &#125; server &#123; listen 7779; location / &#123; proxy_pass http://test_server; # 负载均衡 &#125; &#125;&#125; 此时，访问 http://localhost:7779，会发现 Server1 和 Server2 循环命中，这就是默认的轮询方式负载。 接着，测试带权重的负载，修改配置如下： 1234567891011121314http &#123; ... upstream test_server &#123; server localhost:7801 weight=2; # 后端服务器1，权重2 server localhost:7802 weight=1; # 后端服务器2，权重1 &#125; server &#123; listen 7779; location / &#123; proxy_pass http://test_server; # 负载均衡 &#125; &#125;&#125; 此时，再多次请求 http://localhost:7779，会发现 Server1 出现两次，Server2 出现一次交替命中。 5、更多配置123456789101112http &#123; ... gzip on; # 开启Gzip server &#123; ... location / &#123; add_header &lt;field&gt; value [always]; # 返回时追加Header proxy_set_header &lt;field&gt; &lt;value&gt;; # 反向代理时，发送Header &#125; &#125;&#125; 更多指令，请查询：https://nginx.org/en/docs/dirindex.html 想了解完整配置，请查阅：https://nginx.org/en/docs/ 6、其他6.1、测试使用的完整Nginx配置文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147#user nobody;worker_processes 1;#error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;#pid logs/nginx.pid;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; # 定制日志格式 #log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' # '$status $body_bytes_sent \"$http_referer\" ' # '\"$http_user_agent\" \"$http_x_forwarded_for\"'; #access_log logs/access.log main; sendfile on; #tcp_nopush on; # 定制保持连接超时时间 #keepalive_timeout 0; keepalive_timeout 65; # 是否启用gzip #gzip on; upstream test_server &#123; server localhost:7801 weight=2; server localhost:7802 weight=1; &#125; server &#123; listen 7777; server_name localhost; # 设置编码格式 #charset koi8-r; # 是否开启访问日志 #access_log logs/host.access.log main; location / &#123; root html; index index.html index.htm; &#125; location /api &#123; proxy_pass http://localhost:7779; &#125; # 指定错误页面 #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ &#123; # proxy_pass http://127.0.0.1; #&#125; # 托管PHP的相关配置 # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #&#125; # deny access to .htaccess files, if Apache's document root # concurs with nginx's one # #location ~ /\\.ht &#123; # deny all; #&#125; &#125; server &#123; listen 7778; location / &#123; proxy_pass http://www.newegg.com; &#125; &#125; server &#123; listen 7779; location / &#123; proxy_pass http://test_server; &#125; &#125; # another virtual host using mix of IP-, name-, and port-based configuration # #server &#123; # listen 8000; # listen somename:8080; # server_name somename alias another.alias; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125; # 托管HTTPS # HTTPS server # #server &#123; # listen 443 ssl; # server_name localhost; # ssl_certificate cert.pem; # ssl_certificate_key cert.key; # ssl_session_cache shared:SSL:1m; # ssl_session_timeout 5m; # ssl_ciphers HIGH:!aNULL:!MD5; # ssl_prefer_server_ciphers on; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125;&#125;"},{"title":"Web API接口之Geolocation","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/前端相关/Web API接口之Geolocation/","text":"0、关于GeolocationGeolocation，地理位置API。用于获取用户的位置信息。它不算是现有的HTML5标准的“直系”成员，但是是W3C的一个标准。它几乎就是一个真正的JavaScript API！ 1、位置相关1.1、经纬度表示位置要想知道用户的位置，就需要有一个坐标系统，这就是我们的经纬度。一般我们用度/分/秒表示经纬度，如果需要将经纬度转换为小数，可以使用如下函数： function degreesToDecimal(degrees, minutes, seconds){ return degrees + (minutes / 60) + (seconds / 3600); } 1.2、API如何确定你的位置浏览器要获取你的位置信息，并不要求你非得使用最新的智能手机，即使桌面浏览器也能获取你的位置。那么是如何获取到位置的呢？ 其实，获取位置信息的方式有很多，比如： IP地址 –通过ip地址库获取你的位置 GPS –通过全球定位系统获取你的位置（高精度） 蜂窝电话 –通过三角定位获取你的位置 Wi-Fi – 同样适用类似蜂窝电话的三角定位获取位置 我们没办法知道设备是使用的何种方法获取我们的位置信息，一些聪明的浏览器很可能会使用多种方式来确定你的位置。 2、如何使用Geolocation在使用Geolocation之前，我们需要先是否支持，通过如下代码： if(navigator.geolocation){ //Supported. } else { window.alert(&apos;No geolocation support.&apos;); } 2.1、获取位置获取位置信息的方法是一个异步方法，我们应该如下来使用它： if(navigator.geolocation){ var callback = function(pos){ console.log(&apos;你的位置是：&apos;, pos); }; navigator.geolocation.getCurrentPosition(callback); } else { window.alert(&apos;No geolocation support.&apos;); } 其中pos长什么样呢？大概是如下这个样子的： { coords： { // Coordinates accuracy: 137082, altitude: null, altitudeAccuracy: null, heading: null, latitude: 24.1848198, longitude: 120.63149479999998, speed: null }, timestamp: 1453877895563 } 其中latitude和longitude就是我们的经纬度了。 该方法的语法是：navigator.geolocation.getCurrentPosition(success[, error[, options]])，具体参数含义，请接着往下看。 2.2、监控位置变化在2.1中，我们知道如何获取位置，那如何监控位置变化呢？很容易相当的办法，就是我们定时去获取位置信息，然后比对。那么有没有更好的方式呢？当然，Geolocation API已经帮我们考虑好了。如下： //正常时，会获取到一个地理位置信息 var watchSuccess = function(pos){ var latitude = pos.coords.latitude; var longitude = pos.coords.longitude; console.log(&apos;你的经纬度是：&apos;, latitude, longitude); }; //错误时，函数会接收一个错误对象 var watchError = function(err){ console.warn(err, err.code, err.message); }; var watcherId = navigator.geolocation.watchPosition(watchSuccess, watchError); watchPosition方法的语法是：id = navigator.geolocation.watchPosition(success[, error[, options]])。所以，我们还可以针对这个方法设置参数： var options = { enableHighAccuracy: false, //默认false，为true时，则选择最高的精度获取位置 timeout: 5000, //每次获取位置信息的最长时间，默认是无限的 maximumAge: 0 // 缓存时间（毫秒），如果为0，则每次获取最新的 }; 2.3 清除监控既然我们有监控方法，那么该如何停止呢？这就要借助清除监控的方法了，代码如下： navigator.geolocation.clearWatch(watcherId); watcherId是2.2中监控时的返回值。 2.4、如何计算距离？给予两个坐标点，如何计算两者之间的距离呢？一般采用半正矢（Haversine）公式，具体代码如下： function degreesToRadians(degrees){ var radians = (degrees * Math.PI) / 180; return radians; } function computeDistince(startCoords, destCoords){ var Radius = 6371; //每度在地球上的距离（km） var startLatRads = degreesToRadians(startCoords.latitude); var startLongRads = degreesToRadians(startCoords.longitude); var destLatRads = degreesToRadians(destCoords.latitude); var destLongRads = degreesToRadians(destCoords.longitude); var distince = Math.acos( Math.sin(startLatRads) * Math.sin(destLatRads) + Math.cos(startLatRads) * Math.cos(destLatRads) * Math.cos(startLongRads - destLongRads) ) * Radius; return distince; } 3、扩展地理位置API单独使用意义不大，一般来说，结合地图就可以实现很复杂的功能了。 待续…"},{"title":"TypeScript配置文件tsconfig简析","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/前端相关/TypeScript配置文件tsconfig简析/","text":"0、前言在使用VsCode编写TypeScript时，VsCode提供了一个tsconfig.json辅助我们设置TypeScript的配置项，另外使用gulp-typescript或者是webpack编译ts文件时，都可以用到这个配置项来确定如何生成最终的js文件。 那tsconfig.json到底有哪些常用属性，它们又起到什么作用呢？下文将为你一一揭晓。 1、tsconfig.json1.1、compilerOptionstsconfig.json文件中的 compilerOptions 属性用于确定如何编译ts文件。 其中大概有如下属性： 1.1.1、module: enum module 用于指定模块的代码生成规则，可以使用 commonjs 、 amd 、 umd 、 system 、 es6 、 es2015 、 none 这些选项。 选择commonJS，会生成符合commonjs规范的文件，使用amd，会生成满足amd规范的文件，使用system会生成使用ES6的system.import的代码。使用es6或者是es2015会生产包含ES6特性的代码。 1.1.2、target: enum target 用于指定生成代码的兼容版本，可以从es3,es5,es2015,es6中选择一个，如果不设置，默认生产的代码兼容到es3。 1.1.3、sourceMap: boolean sourceMap 是是否生成SourceMap的开关，如果设置为true，则会生成.map文件。 1.1.4、 noImplicitAny: boolean noImplicitAny 当表达式和申明 类型为any时，是否需要发出警告，设置true，则不警告 1.1.5、 removeComments: boolean 用于指定是否需要输出注释，设置为true，则不输出注释。 1.1.6、 charset: string 用于指定ts文件的编码格式 1.1.7、 declaration: boolean 是否需要生成定义文件d.ts，设置为true，则生成。 1.1.8、 diagnostics: boolean 是否需要显示诊断信息，设置为true，则显示。 1.1.9、 emitBOM: boolean 是否需要在输出文件的开头发出一个UTF-8字节顺序标记，设置为true，则输出。 1.1.10、inlineSourceMap: boolean 是否需要将sourceMap文件生成到js文件中，设置为true，则生成到js文件中。 注：此选项和sourceMap、mapRoot选项冲突，会优先使用inlineSouceMap 1.1.11、inlineSources： boolean 用于指定生成的source内容是否inline，如果设置为true，则inline展示（从测试的效果来看，就是生成在js文件中的source map内容要多一些） 注：该设置项依赖inlineSouceMap设置为true 1.1.12、jsx: enum 用于指定按照何种方式生成jsx代码，可选react和preserve。 1.1.13、reactNamespace: string 配置jsx属性使用，指定生成react代码时，需要使用的命名空间。默认”” 1.1.14、listFiles: boolean 编译时是否需要打印文件列表，设置为true，则打印。默认false 1.1.15、locale: string 用于指定本地化错误信息，如果设定为en-us，那么错误信息将显示英文。默认”” 1.1.16、mapRoot: string(uri) 指定map文件的跟路径，该选项的值影响.map文件中的sources属性。默认”” 注：该选项依赖sourceMap: true 1.1.17、newLine: enum 指定换行符。可选 CRLF 和 LF 两种，前者是回车换行，后者是换行。默认是回车换行 1.1.18、noEmit: boolean 当设置为true时，将不会输出 1.1.19、noEmitHelpers: boolean 设置为true时，不会生成自定义的helper函数。 1.1.20、noEmitOnError: boolean 设置为true时，如果遇到了错误，就不再输出 1.1.21、noLib: boolean 设置为true时，将不会包含默认的库，如（lib.d.ts）,此时有可能导致找不到Array，String等对象 1.1.22、noResolve: boolean 设置为true时，不使用三斜杠引入模块，需要从编译的文件列表中添加。 12/// &lt;reference path=\"\" /&gt;import PI from './2A.ts'; 1.1.23、skipDefaultLibCheck: boolean 设置为true时，将跳过默认库检查。 1.1.24、outFile: string(uri) 设置输出文件，会将多个ts输入文件合并到该文件中 1.1.25、outDir: string(uri) 指定输出文件的根目录。 1.1.26、preserveConstEnums: boolean 设置为true时，生成代码时不会删除常量枚举声明。 1.1.27、pretty: boolean 当设置为true时，错误信息，跟踪信息将带有颜色和样式 1.1.28、noImplicitUseStrict: boolean 当设置为true时，编译输出时不会调用’use strict’指令（也就是不生成use strict） 1.1.29、rootDir: string(uri) 指定输入文件的根目录。rootDir应包含所有的源文件。 1.1.30、isolatedModules: boolean 设置为true时，无条件的触发导入未解决的文件。 1.1.31、sourceRoot: string(uri) 设置在调试时定位的目标文件根目录 1.1.32、suppressExcessPropertyErrors: boolean 设置为true时，禁止过剩的对象字面量属性检查 1.1.33、suppressImplicitAnyIndexErrors: boolean Suppress noImplicitAny errors for indexing objects lacking index signatures. 1.1.34、stripInternal: boolean 设置为true，则遇到@internal注解时，不会触发代码定义。 1.1.35、watch: boolean 设置为true时，将监视文件变化。当文件变化时，自动编译 1.1.36、experimentalDecorators: boolean 设置为true，则支持ES7的装饰器特性 1.1.37、emitDecoratorMetadata: boolean 设置为true，则使用元数据特性 1.1.38、moduleResolution: string 指定模块的解析策略，Node或者是classic，默认是classic。 1.1.39、allowUnusedLabels: boolean 设置为true时，允许没有用到的标签。 123l: do&#123; console.log(&apos;abc&apos;);&#125;while (1 !== 1); 以上代码有个未使用的标签l，默认是会报错的。 1.1.40、noImplicitReturns: boolean 设置为true时，如果不是函数中的所有路径都有返回值，则提示Error。 1234567var a = 2;function fun()&#123; if(a === 1)&#123; return 'abc'; &#125; //fun函数只有当a = 1的时候，才有确定的返回值。&#125; 1.1.41、noFallthroughCasesInSwitch: boolean 设置为true时，将严格校验switch-case语法。 1234567function fun2()&#123; let key = 'ab'; switch (key) &#123; case 'ab': console.log('abc'); &#125;&#125; 以上代码默认情况不会报错，当设置noFallthroughCasesInSwitch: true时，则会提示错误。 1.1.42、allowUnreachableCode: boolean 设置为true时，如果有无法访问的代码，也不会报错。 1234function fun()&#123; return 'abc'; return 'ccc'; //默认会报错，设置allowUnreachableCode为true时，则不报错&#125; 1.1.43、forceConsistentCasingInFileNames: boolean 设置为true时，将强制区分大小写。默认为false。 1234567//2a.tsexport const PI = 3.1415926;//1a.tsimport PI from './2A.ts';function fun()&#123; return PI;&#125; 以上代码默认可以通过，当强制区分大小写时，则提示错误 ‘2a’ !== ‘2A’ 1.1.44、allowSyntheticDefaultImports: boolean 设置为true时，则允许从没有默认导出的模块中默认导入(也就是不做检查)。 1234567//2.tsexport const PI = 3.1415926;//1.tsimport PI from './2.ts';function fun()&#123; return PI;&#125; 以上代码，默认是会报错的，当设置allowSyntheticDefaultImports时，则不会报错。 1.1.45、allowJs: boolean 当设置为true时，js文件也会被编译。 注意：编译js文件时，如果不另外设置outFile，将不会成功，因为不能够重写源代码文件 1.2、compileOnSave该属性用于启用保存时编译功能。 **注意：当前仅仅只有VS2015配置TypeScript1.8.4以后或者在atom中搭配atom-typescript插件才有效 1.3、excludeexclude用于排除不需要编译的ts文件。该属性和files属性冲突。两者只能设置其一。 1.4、files当files属性不存在时，编译器会编译当前目录和子目录中的所有文件。当files属性存在是，仅仅是编译files列表中的文件。 该属性和exclude属性冲突。如果同时指定了exclude和files，则files属性优先。 2、常用tsconfig配置12345678910111213141516&#123; \"compilerOptions\": &#123; \"target\": \"ES5\", \"module\": \"commonjs\", \"emitDecoratorMetadata\": true, \"experimentalDecorators\": true, \"sourceMap\": true, \"noEmitHelpers\": true &#125;, \"exclude\": [ \"node_modules\", \"typings/main\", \"typings/main.d.ts\" ], \"compileOnSave\": false&#125; 3、参考资料 https://www.typescriptlang.org/docs/handbook/tsconfig-json.html http://json.schemastore.org/tsconfig"},{"title":"Webpack In Angular2","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/前端相关/Webpack In Angular2/","text":"0、前言当下Angular2是比较值得关注的技术了，想要把Angular2跑起来，还是比较容易的。但 在这里，我要做的是搭建一个Angular2的开发环境，那么就一步一步来尝试下。 1、搭建开发环境1.1、创建项目新建目录 webpack-in-angular2，然后进入目录执行 npm init -f 创建好 package.json 文件。 打开package.json文件。新建属性 dependencies ，并赋值如下： 123456789101112131415161718&#123; \"dependencies\": &#123; \"@angular/common\": \"^2.0.0-rc.1\", \"@angular/compiler\": \"2.0.0-rc.1\", \"@angular/core\": \"2.0.0-rc.1\", \"@angular/http\": \"2.0.0-rc.1\", \"@angular/platform-browser\": \"2.0.0-rc.1\", \"@angular/platform-browser-dynamic\": \"2.0.0-rc.1\", \"@angular/router\": \"^2.0.0-rc.1\", \"@angular/router-deprecated\": \"2.0.0-rc.1\", \"@angular/upgrade\": \"2.0.0-rc.1\", \"es6-shim\": \"^0.35.0\", \"reflect-metadata\": \"^0.1.3\", \"rxjs\": \"5.0.0-beta.6\", \"zone.js\": \"^0.6.12\" &#125;&#125; 目录下打开控制台，执行 npm i 安装依赖。 至此，Angular2项目已经创建完成。 1.2、安装webpack首先要确保已经全局安装了 webpack 接着安装所需要包 npm install --save-dev webpack typescript ts-loader ts-helpers 1.3、配置webpack在根目录创建 webpack.config.js 文件，用于编写webpack的相关配置项。 在配置 webpack 之前，我们先在 src 目录下创建好我们需要的 polyfills.ts 和 vendor.ts，内容如下： 1234567//polyfills.tsimport 'es6-shim';import 'reflect-metadata';require('zone.js/dist/zone');import 'ts-helpers'; 12345678910111213//vendor.ts// Angular 2import '@angular/platform-browser';import '@angular/platform-browser-dynamic';import '@angular/core';import '@angular/common';import '@angular/http';import '@angular/router';import '@angular/router-deprecated';//RxJSimport 'rxjs'; 接下来，我们再配置webpack的配置项，如下： 1234567891011121314151617181920212223//webpack.config.js'use strict';let webpack = require('webpack');module.exports = &#123; debug: true, entry: &#123; polyfills: './src/polyfills.ts', vendor: './src/vendor.ts' &#125;, output: &#123; path: 'dist/assets/js', filename: '[name].js', chunkFilename: '[id].chunk.js' &#125;, module: &#123; loaders: [ &#123;test: /\\.ts$/, loader: 'ts'&#125; ] &#125;&#125;; 此时，通过控制台执行 webpack 会提示找不到路径错误。 这个时候，我们需要新建一个 tsconfig.json 文件，内容如下： 12345678//tsconfig.json&#123; \"compilerOptions\": &#123; \"module\": \"commonjs\", \"target\": \"es5\" &#125;&#125; 之后再执行 webpack，可以看到在dist/assets/js目录下，已经生成了我们需要的 polyfills.js 和 vendor.js 两个文件。 至此，简单的webpack使用，已经ok，同时也可以生成我们需要的来个库文件了。 1.4、Angular2 Hello World接下来，我们实现一个Angular2的Hello App。 在 src/ 下创建 bootstrap.ts 文件，内容如下： 1234567891011121314151617import &#123;Component&#125; from '@angular/core';import &#123;bootstrap&#125; from '@angular/platform-browser-dynamic';@Component(&#123; selector: 'demo-app', template: `&lt;h3&gt;Hello, Angular2 and Webpack.&lt;/h3&gt; `&#125;)export class AppComponent&#123; constructor()&#123; &#125;&#125;bootstrap(AppComponent); 然后在 webpack.config.js 中添加入口点： 12345entry: &#123; polyfills: './src/polyfills.ts', vendor: './src/vendor.ts', bootstrap: './src/bootstrap.ts' //新增的入口文件&#125; 再次执行 webpack 命令，就可以找到 dist/assets/js/bootstrap.js 文件了。但打开该文件一看，似乎不对，把angular都已经打包进去了。其实我们已经把angular打包到 vendor.js 中了，根本就不需要再打包到 bootstrap.js 。 此时，我们可以修改webpack的config文件，添加公共代码块引用，配置如下： 12345678910111213141516171819202122232425262728'use strict';let webpack = require('webpack');let CommonsChunkPlugin = webpack.optimize.CommonsChunkPlugin;module.exports = &#123; debug: true, entry: &#123; polyfills: './src/polyfills.ts', vendor: './src/vendor.ts', bootstrap: './src/bootstrap.ts' &#125;, output: &#123; path: 'dist/assets/js', filename: '[name].js', chunkFilename: '[id].chunk.js' &#125;, module: &#123; loaders: [ &#123;test: /\\.ts$/, loader: 'ts'&#125; ] &#125;, plugins: [ new CommonsChunkPlugin(&#123; name: ['vendor', 'polyfills'] //vendor和polyfills设置为公共代码块 &#125;) ]&#125;; 再次执行 webpack ，发现已经达到我们想要的效果了（bootstrap.js只包含了必须的代码）。 接着，我们在 src/ 创建 index.html 文件，内容如下： 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Webpack in Angular2 demo&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;demo-app&gt;&lt;/demo-app&gt; &lt;script src=\"assets/js/polyfills.js\"&gt;&lt;/script&gt; &lt;script src=\"assets/js/vendor.js\"&gt;&lt;/script&gt; &lt;script src=\"assets/js/bootstrap.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 同时，修改 webpack.config.js ，使用 copy-webpack-plugin 将 index.html 复制到 dist/ 目录下。 先通过 npm install copy-webpack-plugin --save-dev 安装该插件，然后修改配置节点如下： 123456789plugins: [ new CommonsChunkPlugin(&#123; name: ['vendor', 'polyfills'] //vendor和polyfills设置为公共代码块 &#125;), new CopyWebpackPlugin([ //将src/index.html复制到dist目录。 &#123;form: 'src/index.html', to: path.join(__dirname, 'dist')&#125; ])] 完成以上步骤之后，打开dist目录，使用 anywhere 命令打开 web server，可以在自动打开的浏览器中看到 Hello, Angular2 and Webpack. 至此，我们已经将Angular2和Webpack结合起来使用了。 1.5、使用webpack-dev-server每次都在 dist/ 目录下，通过 anywhere 来打开，并不方便。我们可以通过 webpack-dev-server 插件实现静态服务器。"},{"title":"Webpack初体验","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/前端相关/Webpack初体验/","text":"0、关于webpackWebpack是灵活的、可扩展的、开源的模块打包工具。https://webpack.github.io/。Webpack获取模块和它们之间的依赖关系，然后将这些内容打包为静态资源。 0.1、 Webpack有如下几大特点： 插件 –利用webpack提供的多功能插件接口，使得它可以被添加很多新特性，实现了webpack的高扩展性。 加载器（Loaders） – webpack通过加载器来预处理文件，所以它不仅仅只能打包javascript。同时，使用node程序可以很容易的实现自己的加载器。 代码分割 – webpack允许你将代码分块，按需加载，减少初始加载时间。 开发工具 –webpack支持SourceUrl和相关调试，同时可以通过开发中间件和开发服务器来实现自动化。 高性能 –通过异步IO和多级缓存支持，实现了webpack的高性能。 多支持 -webpack支持amd和commonjs风格的代码，并且还可以静态分析和拥有一个评价引擎来评估简单表达式。 资源优化 –webpack能够实现多层优化来减少输出大小，还能使用散列还关注请求缓存。 多目标 –webpack的主要目标是在Web上，但是它还支持WebWorks和node.js。 0.2、为什么要webpack？(webpack形成的动机) 多种模块加载的方式，AMD、CommonJS、ES6 modules，各有优点，也各有缺陷。 传输方式的两个极端，每次请求一个模块和一个请求所有模块，都并不能达到很好的效果。 资源不仅仅是JavaScript，也有可能是字体、图片，多语言，模板等。 1、Webpack功能1.1、加载器（Loaders）Loader是把资源文件进行转换的一种程序，使用资源文件做为参数，然后返回新的资源文件。比如，将CoffeeScript代码处理为JS代码。 Loader有哪些特点呢？ Loader可以链接，通过管道方式传输。 Loader可以是同步或者是异步的。 Loader使用nodeJs运行，而且能够做更多。 Loader接受查询参数，可以用来传递配置。 Loader可以在配置中绑定到扩展货正则表达式。 Loader可以使用npm发布。 普通模块可以通过package.json来转换为loader。 Loader可以访问配置。 插件可以为Loader添加更多特性。 Loader采用xxx-loader这样的名字命令。xxx就是上下文的名称。在使用loader的时候，可以忽略-loader，只需要使用上下文名称就可以了。 有如下三种方式可以使用loader， 通过require来使用 1234// 使用当前目录的loader.js处理指定的文件require(\"./loader!./dir/file.txt\");// 使用jade-loader来处理.jade模板文件require(\"jade!./template.jade\"); 通过配置 12345678910111213&#123; module: &#123; loaders: [ &#123; test: /\\.jade$/, loader: \"jade\" &#125;, // =&gt; 针对.jade文件使用jade-loader &#123; test: /\\.css$/, loader: \"style!css\" &#125;, // =&gt; 针对.css文件使用style和css两种loader // 另外的一种配置语法 &#123; test: /\\.css$/, loaders: [\"style\", \"css\"] &#125;, ] &#125;&#125; 通过cli 1webpack --module-bind jade --module-bind &apos;css=style!css&apos; 如何使用查询参数？ 在require中 1require(\"url-loader?mimetype=image/png!./file.png\"); 在配置中 123456789//方式一&#123; test: /\\.png$/, loader: \"url-loader?mimetype=image/png\" &#125;//方式二&#123; test: /\\.png$/, loader: \"url-loader\", query: &#123; mimetype: \"image/png\" &#125;&#125; 在CLI中 1webpack --module-bind \"png=url-loader?mimetype=image/png\" 1.1、插件使用插件一般都涉及到webpack的打包功能，比如使用BellOnBundlerErrorPlugin，来提示在打包过程的错误。 webpack包含部分内置插件，可以在config中进行配置： 123456789var webpack = require(\"webpack\");module.exports = &#123; plugins: [ new webpack.ResolverPlugin([ new webpack.ResolverPlugin.DirectoryDescriptionFilePlugin(\"bower.json\", [\"main\"]) ], [\"normal\", \"loader\"]) ]&#125;; 也可以通过以下代码使用外部插件： 123456var ComponentPlugin = require(\"component-webpack-plugin\");module.exports = &#123; plugins: [ new ComponentPlugin() ]&#125; 1.3 开发工具开发工具相关配置通过通过Configuration进行查看。 提供开发服务器的包：webpack-dev-server 用于高级用户的中间件：webpack-dev-middleware 2、使用Webpack我们一般采用配置文件加webpack.config的方式来使用webpack，那具体应该如何用呢？ 首先，通过 npm install webpack -g 和 npm install webpack --save-dev 全局和在项目中安装webpack。 然后通过 npm install xxx 来安装webpack所需要的插件和加载器（Loader） 接下来，就是编写webpack的配置文件： 123456789101112131415161718192021222324252627var webpack = require('webpack'); //引入webpack//webpack配置module.exports = &#123; entry: &#123; app: 'index.js' &#125;, output: &#123; path: './dist', //输出目录 filename: '[name][hash]bundle.js' //输出文件名 &#125;, resolve: &#123; root: __dirname &#125;, module: &#123; noParse: [], loaders: [ //针对不同的文件，采用不同的加载器来处理 &#123; test: /\\.js$/, exclude: /node_modules/, loader: 'babel'&#125;, //js文件除开node_modules,通过babel来处理 &#123; test: /\\.html$/, loader: 'raw' &#125;, //html文件通过raw-loader处理 &#123; test: /\\.css$/, loader: 'style!css'&#125; //css文件通过style-loader和css-loader来处理 ] &#125;, plugins: [ //Banner插件，合并时增加注释 new webpack.BannerPlugin('Hello' + new Date()) ]&#125;; 最后，执行webpack，就能够启动了，在执行webpack的时候，可以附加很多参数，这些参数可以通过 webpack -h 来查看 当前只能简单使用，等理解了webpack的核心思想，再写一篇《webpack深度解析》，敬请期待… 3、参考文档 Webpack官方文档 在一个真实的项目中使用Webpack"},{"title":"重温设计模式（一）：工厂方法","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/重温设计模式/重温设计模式（一）：工厂方法/","text":"工厂方法模式（Factory method pattern），属于创建性模式。"},{"title":"Webpack小抄","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/前端相关/Webpack小抄/","text":"0、前言此文用于记载在使用webpack打包过程中的点点滴滴！（仅适用于 webpack1.x） 1、动态指定loaderwebpack 的config文件中的loader，一般针对特定的后缀文件，当我们要对单个文件进行独立配置的时候，就不太好满足需求了，此时我们就需要在 import 或者 require 中指定文件的loader。 指定loader的时候，有如下几种场景： 需要使用自定义loader，此时的import应该按照如下方式编写：require(&#39;./loader!./xxx.js) ，使用当前目录下的 loader.js 来处理 xxx.js 。 需要在全局loader（这里指在config中配置的loader）之前做一些处理（插入loader），那我们可以如下处理：import &#39;jade!./template.jade&#39;，使用 jade-loader 来处理template.jade文件。 需要覆盖全局的loader，可以如下使用：import &#39;!style!css!less!./test.less&#39;，使用 less-loader css-loader style-loader 来处理test.less文件。 注意1：插入loader与覆盖loader，差别在于第一个字符是不是!(感叹号)。 注意2：当指定loader的时候，需要记住loader是从右往左依次执行的，一定要注意顺序。 2、打包项目为类库当我们要把项目打包为类库的时候，我们需要在entry中进行如下配置： 123456&#123; entry: &#123; libraryTarget: 'umd', //可选var：直接全局变量，amd: AMD风格的库，cmd: CMD风格的库 library: 'xxx' //挂载到window上的名称 &#125;&#125; 3、webpack-dev-server部署IP访问使用默认的选项，只能使用 localhost 访问，如果想通过 IP 访问，那么需要设定配置如下： 12345devServer: &#123; contentBase: './', port: 7410, host: '0.0.0.0' // 设定host属性，绑定到 0.0.0.0，则可允许IP访问&#125; 4、Webpack使用外部依赖1234567891011externals: &#123; '@angular/common' : 'ng.common', '@angular/compiler' : 'ng.compiler', '@angular/core' : 'ng.core', '@angular/http' : 'ng.http', '@angular/platform-browser' : 'ng.platformBrowser', '@angular/platform-browser-dynamic' : 'ng.platformBrowserDynamic', '@angular/router' : 'ng.router', '@angular/forms' : 'ng.forms', 'rxjs' : 'Rx'&#125; 5、Webpack多入口点，打包为library1234567output: &#123; path: './dist', publicPath: 'http://10.16.85.170:9999/', filename: 'newkit.[name].js', library: ['newkit', '[name]'], liabraryTarget: 'umd'&#125;, 6、和gulp配合使用尽量使用 const webpack = require(&#39;webpack&#39;) 。 用法如下： 12345678910111213141516171819202122232425262728293031const showWebpackError = (err, stats) =&gt; &#123; if (err) &#123; throw new gutil.PluginError('webpack', err); &#125; let statColor = stats.compilation.warnings.length &lt; 1 ? 'green' : 'yellow'; if (stats.compilation.warnings.length &gt; 0) &#123; stats.compilation.errors.forEach(error =&gt; &#123; statColor = 'red'; &#125;); &#125; else &#123; gutil.log(stats.toString(&#123; colors: gutil.colors.supportsColor, hash: false, timings: true, chunks: true, chunkModules: false, modules: false, children: false, version: true, cached: true, cachedAssets: true, reasons: false, source: false, errorDetails: false &#125;)); &#125;&#125;;webpack(opt).watch(200, (err, stats) =&gt; &#123; showWebpackError(err, stats);&#125;);"},{"title":"Yarn vs. Npm","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/前端相关/Yarn vs. Npm/","text":"0、什么是 Yarn ?官方解释是：FAST, RELIABLE, AND SECURE DEPENDENCY MANAGEMENT（快速，可靠和安全的依赖管理器）。 它是 facebook 开源的一个 npm 替代品。我们主要用它来进行依赖管理工作。 1、为什么需要 Yarn ?对于 Yarn，其实一开始我是拒绝的。 为啥？ 发布第二天时我就去体验，结果发现安装它自身比较麻烦，而且安装依赖还慢，还非常容易崩溃。 命令和 npm 不一样，增加了学习成本 yarn 安装依赖进度条在windows上不友好（是npm之前旧版本的样式） 觉得赶超 npm 还需要一定的时间 那为什么又开始推荐 yarn 呢？ npm 安装依赖慢，是个长久的问题 再次体验 yarn, 发现之前遇到的一些问题都不见了 使用 yarn 安装依赖，速度有很大的提升4、yarn 比 npm 提供更多更易用的功能 综上，我觉得现在可以开始尝试使用 yarn，说不定过不了多久，还真能完全替代 npm。 2、yarn-cli 使用手册（对比npm）首先，要使用 yarn-cli，需要先执行 npm install -g yarn 来全局安装 yarn（莫名的想到，IE浏览器最大的作用就是下载其他浏览器），通过 yarn --version 来查看 yarn 的版本。 如 npm 一样，yarn 也提供了较多的命令。其中最常用的命令如下： yarn init ($ npm init) yarn install ($ npm install) yarn add ($ npm install –save) yarn remove ($ npm uninstall –save) yarn publish ($ npm publish) 注意：下文中仅仅会列出本人觉得比较有代表性/常用的命令，并不是所有的命令 2.1、yarn inityarn init 用于初始化 package.json 文件，效果和 npm init 类似。 同样也支持直接创建，不询问。 12345# 初始化package.json，带交互npm init =&gt; yarn init# 初始化package.json，直接创建npm init -f/--force =&gt; yarn init -y/--yes 2.2、yarn installyarn install 该命令和 npm install 一样，用于根据 package.json 来初始化项目依赖。 和 npm 对比如下： 12345# 安装所有依赖npm install =&gt; yarn install# 安装项目依赖（对比开发依赖，上产线时的依赖）npm install --production =&gt; yarn install --production/--prod 除此之外，yarn install 还有一些新的参数设置，正是这些设置，让 yarn 比 npm 有着更强大的功能。 12345678# 强制安装所有的包，就算是已经安装过的yarn install --force# 不会读取和生成lockfileyarn install --no-lockfile# 不生成lockfileyarn install --pure-lockfile 2.3、yarn addyarn add &lt;package&gt; 等同于 npm install &lt;package&gt;，用于安装指定包，它和 npm 的区别如下： 1234567891011121314151617181920212223# 仅安装依赖包npm install &lt;package&gt; --save =&gt; N/A# 安装依赖包，并写入 dependencies 属性npm install &lt;package&gt; --save =&gt; yarn add &lt;package&gt; # 安装依赖包，并写入 devDependencies 属性npm install &lt;package&gt; --save-dev =&gt; yarn add &lt;package&gt; --dev# 安装依赖包，并写入 peerDependencies 属性N/A =&gt; yarn add &lt;package&gt; --peer# 安装依赖包，并写入 optionalDependencies 属性npm install &lt;package&gt; --save-optional =&gt; yarn add &lt;package&gt; --optional# 安装精确的版本号的依赖包# 什么意思呢？简单点说，就是在 package.json中写入的版本号规则不一样。# 默认场景下，是会写： \"xxx\":\"^1.1.0\"，允许使用同一主版本的包，如1.2.0# 当设置该参数之后，就会变成： \"xxx\": \"1.1.0\"，（只能使用该版本号的包）npm install &lt;package&gt;[@version] --save-exact =&gt; yarn add &lt;package&gt;[@version] --exact# 安装具有相同次版本号的依赖包N/A =&gt; yarn add &lt;package&gt;[@version] --tilde 除此之外，还有一个比较常见的安装包方式，那就是全局安装安装，在 yarn 中又该如何使用呢？ 12# 全局安装依赖包npm install &lt;package&gt; -g/--global =&gt; yarn global add &lt;package&gt; 2.4、yarn remove该命令和 npm uninstall 比较类似，用于删除依赖包。但和 npm uninstall 又有点不同。 因为它没法直接删除包，而不更新 package.json。 当 remove 一个包时，它会同时更新 package.json 中对它的所有引用。 1yarn remove &lt;package&gt; = npm uninstall &lt;package&gt; --save | --save-dev | save-exact | save-optional 和 yarn add 类似，如果要移除全局安装包，需要用 yarn global remove &lt;package&gt; 2.5、yarn publish用于将包发布到仓库（当前是npm仓库）上。类似于 npm publish 3、其他重要的命令3.1、yarn run该命令和 npm run 没啥区别，用户执行 package.json 中 script 节点中定义的命令。 3.2、yarn self-update用于更新自身，如果是 npm，则是： npm install -g npm 3.3、yarn outdated检查依赖版本情况，类似 npm outdated 3.4、yarn upgrade用于更新版本，类似于 npm update 3.5、yarn config该命令用于管理 yarn 的配置数据。 1234567891011# 查看配置数据npm config list =&gt; yarn config list # 查看指定的key值npm config get &lt;key&gt; =&gt; yarn config get &lt;key&gt;# 删除指定的Keynpm config delete &lt;key&gt; =&gt; yarn config delete &lt;key&gt;# 设置指定的key - valuenpm config set &lt;key&gt; &lt;value&gt; =&gt; yarn config set &lt;key&gt; &lt;value&gt; 由于国内的环境，强烈建议将 registry设置为： https://registry.npm.taobao.org/，命令如下： 1yarn config set registry https://registry.npm.taobao.org/ -g 4、参考资料 yarn 文档 npm 文档"},{"title":"Web API接口之FileReader","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/前端相关/Web API接口之FileReader/","text":"0、导言在给网站编写 JavaScript 代码时，也有很多可用的 API。 WEB API 参考。 1、FileReader使用FileReader对象,web应用程序可以异步的读取存储在用户计算机上的文件(或者原始数据缓冲)内容。兼容IE10+，FF和Chrome。Safari和Opera不支持。 2、如何读取文件？var readFile = function(file, callback) { var fileReader = new FileReader(); //实例化FileReader fileReader.onloadend = function() { //加载完成后执行 var result = null; if (fileReader.readyState === FileReader.DONE) { //判断操作是否完成 result = fileReader.result; //获取结果 } if (callback) { callback(result); } }; fileReader.readAsBinaryString(file); //以二进制的方式读取文件 }; 调用的话，就可以通过如下代码调用 readFile(file, function(result){ // do something }); 其中file既可以是blob对象也可以是一个File对象。一般我们常用的是File对象，如何来获取一个简单的File对象呢？ &lt;input type=&quot;file&quot; id=&quot;file_input&quot;&gt; JS: var fileEl = document.getElementById(&apos;#file_input&apos;); var file = fileEl.files[0]; //files是数组对象 3、FileReader API方法 void abort(); void readAsArrayBuffer(in Blob blob); void readAsBinaryString(in Blob blob); void readAsDataURL(in Blob blob); void readAsText(in Blob blob, [optional] in DOMString encoding); 其中1是终止读取操作，2~4是将数据读取为不同的格式。 状态常量 EMPTY 还没有加载任何数据 LOADING 数据正在被加载 DONE 已完成全部的读取请求 属性（属性全部都是只读的） error 读取文件时发生的错误 readyState FileReader对象的当前状态 result 读取到的文件内容 4、用途 客户端校验文件内容 预览图片 客户端导出 5、参考文档 MDN - Blob MDN - FileReader 6、后续补充2016-2-17日追加FileReader的API方法readAsBinaryString在IE11中无法使用，为了兼容IE11，我们需要使用另外的API或者使用猴子补丁的方式实现该API。 参考http://stackoverflow.com/questions/31391207/javascript-readasbinarystring-function-on-e11 补丁代码如下： 1234567891011121314151617if(!FileReader.prototype.readAsBinaryString)&#123; FileReader.prototype.readAsBinaryString = function (blob) &#123; var binary = ''; var self = this; var reader = new FileReader(); reader.onload = function(e)&#123; var bytes = new Uint8Array(reader.result); var length = bytes.byteLength; for (var i = 0; i &lt; length; i++) &#123; binary += String.fromCharCode(bytes[i]); &#125; self.result = binary; $(pt).trigger('onload'); &#125;; reader.readAsArrayBuffer(blob); &#125;&#125;"},{"title":"Google JavaScript Style Guide（上）","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/前端相关/Google JavaScript Style Guide（上）/","text":"引言JavaScript是一套灵活的语言，所以我们可以用各种风格来编写代码。但为了更好的编写JavaScript代码，有些共同的规范是需要我们去遵循的。以下是Google提供的JavaScript代码风格指南，值得我们学习。可以到 原文链接 查看原文英文版。 JavaScript 语言规则1、 var 总是使用 var 来定义变量，如果你没这样做，那么定义的变量很可能会污染全局变量，导致不必要的问题。 注：在ES6中，我们还可以使用let来定义变量，该方式定义的变量具有词法作用域，没有变量提升的风险。 2、Constants（常量） 使用NANES_LIKE _THIS这种全大写，下划线分割风格来定义常量 使用@const来注释你的常量 不要使用 const 关键字来定义常量，IE不支持 注：在支持ES6的环境下，建议直接通过 const 关键字来定义常量 3、Semicolons（分号） 由于JavaScript的自动补全分号机制，可能会导致意料之外的结果，所以建议总是使用分号。 错误实例： 123456789101112// Error 1var fun1 = function()&#123; return 1;&#125; //此处缺少分号，由于JavaScript的优先级，会导致优先和后面的括号结果，当成函数调用。(function()&#123; console.log('abc');&#125;)();// Error 2var arr = [1, 2, 3]-1 == 0 || 1;console.log(arr); //输出1 注：函数和分号，函数申明不需要分号，函数表达式需要使用分号1234567var foo = function() &#123; return true;&#125;; //函数表达式需要分号function foo2() &#123; return true;&#125; //函数申明不需要分号 4、嵌套函数 嵌套函数在大多数时候是非常有用的，可以随意的使用给它们。12345678function f() &#123; var x = 'local'; function g() &#123; console.log(x); &#125; g(); //可以在函数内部访问到，但没有对外公开&#125;f(); 5、在块中定义函数 不要在块中定义函数，JavaScript是函数作用域。 注：我们可以在块中使用函数表达式 123456789101112131415//就算if为false，foo函数同样会被申明if(false)&#123; function foo()&#123; console.log('foo'); &#125;&#125;foo &amp;&amp; foo(); //此处满足需求，if为false，则bar未定义if(false)&#123; var bar = function()&#123; console.log('bar'); &#125;&#125;bar &amp;&amp; bar(); 6、异常 异常基本上是无法避免的，可以考虑使用完善的开发框架。 7、自定义异常 建议使用自定义异常，如果没这样做，函数返回的异常信息可能是很不友好的。同时会暴露原始异常信息，所以建议使用自定义异常来屏蔽技术细节。 8、标准功能 标准功能总是由于非标准功能，为了最大的可移植性和兼容性，尽量使用标准功能。 9、基本类型的包装对象 没必要对基本类型进行包装，而且很容易产生错误。 1234var x = new Boolean(false);if (x) &#123; //此处x为真，所以会执行到内部的代码 alert('hi');&#125; 10、多级层次原型 多级原型继承不是首选，建议使用 Closure 或者类似的库。 11、方法和属性定义 虽然有很多种方式可以创建函数，但是优先选择使用函数表达式，以属性或者变量的方式存在。如果是要定义类，那么还是采用方法申明的方式。 注：ES6可以使用 class 关键字定义类 1234567891011121314//常规使用函数var bar = function()&#123; &#125;;//类函数定义function Foo()&#123; &#125;//使用class申明类class Foo2&#123; constructor()&#123; &#125;&#125; 11、delete（关键字） 优先将无用的属性设置为null，而不是delete。因为在JavaScript引擎中，改变一个对象的属性数目要比重新设置属性值慢得多。 12、闭包 可以使用，但是要当心。闭包使用不当，容易导致内存泄露。实例如下： 12345678910111213141516// 内存泄露，每次点击将使用到a和b，导致循环引用（ERROR）function foo(element, a, b) &#123; element.onclick = function() &#123; /* uses a and b */ &#125;;&#125;// 内存泄露修复function foo(element, a, b) &#123; element.onclick = bar(a, b);&#125;//通过函数隔离，onclick事件不在对原始的a和b引用，所以避免的循环引用。function bar(a, b) &#123; return function() &#123; /* uses a and b */ &#125;;&#125; 13、eval() 尽量避免使用eval，一个是性能低下，二个是很容易被攻击 14、with(){} 不要使用with，with会让你的代码难以理解，而且结果具有不确定性。 123456//foo是否包含x属性，将会导致不同的结果var foo = &#123;x1: 1&#125;; // &#123;x: 1&#125;var x = 3;with (foo) &#123; console.log(x);&#125; 15、this 建议仅在对象构造函数，方法和配置闭包中使用 this 。因为this在不同的地方，指向的对象不一样，这些很容易引发错误。 16、for-in 循环 建议在object/map/hash这种key-value结构中使用 for-in 循环，其他地方还是用for吧。另外for-in循环并不能保证key的顺序，所以在要顺序要求的地方也不要使用for-in。 注：ES5中新增了Object.keys可以用来替代for-in，在ES6中可以用for of遍历可迭代对象 17、关联数组 不要使用数组作为 map/hash/关联数组 。关联数组不允许使用非数字索引。 123456789//关联数组var arr = &#123;&#125;;//添加元素arr['one'] = 'abc';arr['two'] = 'def';//删除元素delete arr['one'];//访问元素console.log(arr['two']); 18、多行字符（行尾\\反斜杠） 应避免使用多行字符，在每行开始处的空白无法被编译，反斜杠也可能会导致错误的空白，另外，它不是ECMAScript的一部分。我们可以使用字符串连接来替代 1234567891011var str1 = 'AA \\ BB';var str2 = 'AA ' + 'BB';//ES6用法var str3 = `AABB`;console.log(str1);console.log(str2);console.log(str3); 19、数组和对象字面量 总是使用数组和对象字面量。数组构造是很容易出错的，new Array(‘a’)表示一个长度的数组，new Array(5)表示5个长度的数组。具体如何返回结果，取决于第一个参数的类型。 20、不要修改内置对象的原型 对于Object和Array原型的修改是严格禁止的。修改其他内置对象的原型虽然不那么危险，但仍然会导致难以调试，应当避免。 21、IE条件注释 不要使用IE条件注释。会阻碍自动化工具处理js代码，也有可能会在运行时改变语法树。 1234var f = function () &#123; /*@cc_on if (@_jscript) &#123; return 2* @*/ 3; /*@ &#125; @*/&#125;;console.log(f()); 未完，待续"},{"title":"Web前端基础测试题","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/前端相关/Web前端基础测试题/","text":"1、HTML篇1、HTML是一种（）。A、标记语言 B、编程语言 C、自然语言 D、描述语言 2、HTML的后缀名是（）。A、 .h B、.ht C、.htm D、.html 3、HTML5新增的元素有（）。A、 p B、 ruby C、 canvas D、 span 4、HTML5中，使用（）可以播放视频？A、 audio B、 mark C、 video D、 source 2、CSS篇####5、以下html代码中，用（）可设置Home的颜色的元素。 &lt;div class=&quot;container&quot;&gt; &lt;p class=&quot;about&quot;&gt; &lt;a href=&quot;#&quot; id=&quot;home-link&quot;&gt;Home&lt;/a&gt; &lt;/p&gt; &lt;/div&gt; A、 #home-link{} B、 .container .about{} C、 .container &gt; a{} D、 .about a{} 6、要对Me设置样式，应该使用（）。&lt;div&gt; &lt;span id=&quot;id&quot;&gt;&lt;/span&gt; &lt;span&gt;Me&lt;/span&gt; &lt;/div&gt; A、 #id &gt; span{} B、 #id + span{} C、 #id span{} D、 #id ~ span{} 7、如果对文本的第一个字符进行设置样式？()A、 :after{} B、 :before{} C、 :first-letter{} D、 :first-line{} 8、在CSS的border-box盒子模型中，border-width: 2px; width: 100px; padding: 5px; margin: 1px;那么，该元素占用的宽度为（）A、 100px B、 102px C、 108px D、 116px 9、如何对span设置width？（）A、 span{width: 100px; display: inline-block;} B、 span{width: 100px; display: inline;} C、 span{width: 100px; display: block;} D、 span{width: 100px;} 10、当position设置为（）时，可以让元素钉在浏览器窗口上，不随滚动条滚动而滚动。A、 absolute B、 static C、 relative D、 fixed 11、以下哪些是CSS的预处理器（）A、 Less B、 Sass C、 Stylus D、 Dart 3、JavaScript篇12、以下变量定义不正确的是（）。A、 var a, var b; B、 var a = b = 1; C、 var a, b, c; D、 var class = 1; 13、假定今天是2015年11月1日，如下代码的输出结果是（）new Date().getMonth() A、 111 B、 10 C、 11 D、 2015 14、当表单填写完毕，鼠标单击提交按钮时，触发的是（）事件A、onblur B、onmouseleave C、onmouseenter D、onsubmit 15、以下哪些是JavaScript的中间语言？A、 TypeScript B、 CoffeeScript C、 JScript D、 ActionScript 16、typeof undefined 输出（）A、 “undefined” B、 “object” C、 “null” D、 Error 17、 typeof Array.prototype 输出 （）A、 “undefined” B、 “object” C、 “null” D、 Error 18、[undefined == null, NaN == NaN] 输出（）A、 [true, true] B、 [false false] C、 [true, false] D、 [false, true] 19、以下代码输出（）(function() { var a = b = 5; })(); console.log(b); A、 Error B、 null C、 undefined D、 5 20、以下代码输出（）function test() { console.log(a); console.log(foo()); var a = 1; function foo() { return 2; } } test(); A、 1 和 undefined B、 1 和 2 C、 undefined 和 2 D、 undefined 和 undefined 4、编程篇21、请补全代码function sortArr(arr){ //Your code here... } console.log(sortArr([1, 3, 0, 9, 7])); // Result: [9, 7, 3, 1, 0] 22、请补全代码function distinctArr(arr){ //Your code here... } console.log(distinctArr([1, 5, 7, 3, 7, 5])); // Result: [1, 5, 7, 3] 附参考答案： ACDBCCABDBDCBACDABCADBDABABCDC 21、function sortArr(arr){ var arrCopy = arr.slice(0); // 使用sort时，需要先复制一次arr，避免修改原本的数组。 arrCopy.sort(function(a1, a2){ return a2 - a1; }); return arrCopy;} 22、function distinctArr(arr){ var resultArr = []; arr.forEach(function(item, i){ if(resultArr.indexOf(item) === -1){ resultArr.push(item); } }); return resultArr;} function distinctArr(arr){ var tempArr = arr.filter(function(item, index, inputArray){ return inputArray.indexOf(item) === index; }); return tempArr;}"},{"title":"那些年我们认识的iframe","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/前端相关/那些年我们认识的iframe/","text":""},{"title":"一个元素实现3个回图形","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/前端相关/一个元素实现3个回图形/","text":"题目如何用一个html元素实现三个回子类似的图形？ 解题方案方案一，利用outline和outline-offset结合伪元素来实现。123456789101112131415161718.test, .test::before, .test:after&#123; height: 100px; width: 100px; border: 1px solid blue; outline: 1px solid red; outline-offset: 10px;&#125;.test::before, .test::after&#123; content: ''; display: block;&#125;.test::before&#123; margin-left: 150px; &#125;.test::after&#123; margin-top: -100px; margin-left: 300px;&#125; 方案二，利用box-shadow来模拟边框实现12345678910111213141516171819202122232425262728.test&#123; position:relative; border: 1px solid red; height: 150px; width: 120px; box-shadow: 275px 0px 0 0px white, 275px 0px 0 1px red;;&#125;.test::before&#123; content: ''; position: absolute; display: block; width: 100px; height: 100px; left: 10px; top: 25px; border: 1px solid blue; box-shadow:135px 0 0px 0px white, 135px 0 0px 1px blue, 275px 0px 0 0px white, 275px 0px 0 1px blue;;&#125;.test::after&#123; content: ''; display: block; position:absolute; width: 120px; height: 150px; left: 135px; top: 0; border: 1px solid red;&#125;"},{"title":"探索Decorator","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/前端相关/探索Decorator/","text":"0、前言1、啥是Decorator？2、"},{"title":"前端模块化：RequireJS","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/前端相关/前端模块化：RequireJS/","text":"前言前端模块化能解决什么问题？ 模块的版本管理 提高可维护性 – 通过模块化，可以让每个文件职责单一，非常有利于代码的维护 按需加载 – 提高显示效率 更好的依赖处理 – 传统的开发模式，如果B依赖A，那么必须在B文件前面先加载好A。如果使用了模块化，只需要在模块内部申明依赖即可。 AMD规范 &amp; CMD规范说到前端模块化，就不得不提AMD规范（中文版)、英文版）和CMD规范（英文版） 它们的区别： http://www.zhihu.com/question/20351507 http://www.cnblogs.com/tugenhua0707/p/3507957.html AMD规范是 RequireJS 在推广过程中对模块定义的规范化产出，所以我在这里重点介绍下 AMD规范。 AMD规范全名异步模块定义（Asynchronous Module Definition）规范，让模块和依赖可以异步加载。 主要API： define(id?, dependencies?, factory); id,字符串，定义中模块的名字，可选参数（没有提供，则默认为模块加载器请求的指定脚本的名字），如果提供，那么模块名必须是顶级和绝对的（不允许相对名字） dependencies，数组，模块的依赖，可选参数 factory，函数或对象，必选参数。 RequireJSRequireJS是一个JS的文件和模块加载器。专门为浏览器优化，同时也支持其他JS环境。 使用RequireJS要想使用requireJS，首先需要在页面引入脚本： &lt;script src=&quot;assets/vendor/require/require.js&quot;&gt;&lt;/script&gt; 接下来，书写脚本： &lt;script&gt; requirejs([&apos;js/a&apos;], function(a){ alert(a.test); }); &lt;/script&gt; 再来看看a.js: define({ test: &apos;aa&apos; }); html代码如下： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;RequireJS Demo&lt;/title&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;chrome=1&quot;&gt; &lt;script src=&quot;assets/vendor/require/require.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; requirejs([&apos;assets/js/a&apos;], function(a){ alert(a.test); }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 在浏览器中打开后，弹出aa。 在实践这个简单示例的时候，需要注意requireJS的baseUrl 设置： 细节之处 1、RequireJS 加载文件/模块都是相对于baseUrl的 2、baseUrl默认使用data-main属性指定的脚本目录 //baseUrl=&quot;assets/&quot; &lt;script data-main=&quot;assets/main&quot; src=&quot;assets/vendor/require/require.js&quot;&gt;&lt;/script&gt; //baseUrl=&quot;assets/js/&quot; &lt;script data-main=&quot;assets/js/main&quot; src=&quot;assets/vendor/require/require.js&quot;&gt;&lt;/script&gt; 3、如果没有data-main属性，那么baseUrl等于该html所在的目录 4、baseUrl可以通过RequireJS config进行设置 5、优先级：config &gt; data-main属性 -&gt; html目录 6、RequireJS加载JS时，可以不写js后缀 7、加载文件/模块时，会自动包含前缀http或者https 8、可以在config中使用paths配置，指定相对目录 //这是我的项目目录结构 www/ index.html assets/ js/ a.js vendor/ require/ require.js main.js //配置文件 requirejs.config({ baseUrl: &apos;assets&apos;, paths: { js: &apos;js&apos; } }); //可以直接使用js来映射目录，进行文件引用 requirejs([&apos;js/a&apos;], function(a){ alert(a.test); }); 注意：一定要保证使用paths的时候，一定要放在config之后。通过在配置paths时，如果是直接子目录，不需要斜杠。 9、data-main指定的文件，是requirejs的入口点 定义模块在requirejs中，我们可以采用多种方式定义模块，如下： 1、简单的键值对: define({ color: &apos;black&apos;, size: &apos;18px&apos; }); 2、定义函数： define(function(){ return { color: &apos;black&apos;, size: &apos;18px&apos; }; }); 3、定义函数并使用依赖： define([&apos;a&apos;, &apos;b&apos;], function(a, b){ return { color: &apos;black&apos;, size: &apos;18px&apos;, alert: function(){ return a.num + b.num; } }; }); 4、将函数定义为模块： define([&apos;a&apos;, &apos;b&apos;], function(a, b){ return function(title){ return title ? title : a.title + b.title; }; }); 5、通过简单的CommonJs包装器定义模块： define(function(require, exports, module){ var a = require(&apos;a&apos;), b = require(&apos;b&apos;); return function(){}; }); 6、定义包含名字的模块： define(&apos;moduleA&apos;, [&apos;a&apos;, &apos;b&apos;], function(a, b){ //do something... }); 配置项requirejs.config({ baseUrl: &apos;&apos;, //基地址 paths: { //路径映射 &apos;js&apos;: &apos;../js&apos; }, bundles: { // primary: [&apos;main&apos;, &apos;util&apos;], secondary: [&apos;text!secondary.html&apos;] }, shim: { //从非模块的js中，导出模块 jquery: { deps: [], exports: &apos;jQuery&apos; } }, map: { //方便版本控制 &apos;some/newmodule&apos;: { &apos;foo&apos;: &apos;foo1.2&apos; }, &apos;some/oldmodule&apos;: { &apos;foo&apos;: &apos;foo1.0&apos; } }, config: { //配置module bar: { size: &apos;large&apos; } }, packages: [], //需要从CommonJS packages中加载的模块 nodeIdCompat: true, waitSeconds: 15, // 加载脚本超时时间（秒） context: &apos;&apos;, //设置上下文名称 deps:[], //需要加载的依赖 callback: function(){}, //当deps加载完时执行 enforceDefine: false, // 是否当脚本没有define时抛出错误 xhtml: false, //是否使用xhtml创建脚本元素 urlArgs: &apos;test=&apos; + (new Date()).getTime(), //配置url参数 scriptType: &apos;text/javascript&apos;, //设置加载脚本的脚本类型 skipDataMain: false //是否使用data-main属性 });"},{"title":"再说Promise","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/前端相关/再说Promise/","text":"0、导言在JavaScript，由于天生的回调机制，当业务逻辑嵌套较多的时候，就很容易产生回调地狱。 为了避免回调地狱，在JS中可以使用 co, Promise, async await 等等方式。 在当前ES6开始流行的情况下，Promise 则是主流，就算是 async await ，也需要和Promise搭配，那我们就来看下 Promise 到底是怎么工作的！ 1、原生Promise打开Chrome控制台，输入 Promise. 然后可以看到Promise的一些静态方法如下： 123456Promise.accept(); // 【非标准】等价于Promise.resolve()Promise.all(); // 同时执行多个Promise，所有Promise都执行完毕（resolve, reject都算）之后，才会调用then方法。Promise.defer(); // 【非标准】返回一个Deferred对象Promise.race(); // 通过执行多个Promise，有一个成功就继续下一步。Promise.reject(); // 返回一个rejected的PromisePromise.resolve(); // 返回一个resolved的Promise 通过 let p = Promise.defer().promise 之后，使用 p.，可以看到 Promise 实例可用的一些方法（实际是原型方法） 123catch(); // 是onRejected的语法糖，注册onRejected方法。chain(); // 【非标准】then(); // 注册onFulfilled和onRejected方法。 至于具体如何用，看 Promise Book。 2、Promise原理浅析光用还不够，在这里我们来分解一下Promise背后的原理。 要去分析Promise的原理，首先就不得不提到两个规范。一个是 Promise A+ 规范（ES6 Promise的前身，是一个社区规范）和 ECMA Promise规范（标准化之后的规范）。它们约定了Promise的规则。 在这里，我们就不按部就班的来对应该问题，我们就通过TDD的方式来实现一个Promise-polyfills。 测试工具采用了 ava。 为了避免浏览器干扰，我们把Promise取别名为Promise2。目录结构如下： 123Promise2.jstest/ promise.test.js 我们先完成第一个测试，验证Promise应该有的静态方法和原型方法。 1234567891011121314151617181920212223242526272829303132//promise.test.js&apos;use strict&apos;;let test = require(&apos;ava&apos;);let Promise2 = require(&apos;./../Promise2&apos;);// Promise2 is a function. test(t =&gt; t.is(&apos;function&apos;, typeof Promise2));// Promise2 has static function resolvetest(t =&gt; t.is(&apos;function&apos;, typeof Promise2.resolve));// Promise2 has static function rejecttest(t =&gt; t.is(&apos;function&apos;, typeof Promise2.reject));// Promise2 has static function racetest(t =&gt; t.is(&apos;function&apos;, typeof Promise2.race));// Promise2 has static function alltest(t =&gt; t.is(&apos;function&apos;, typeof Promise2.all));let p1 = new Promise2();// new Promise2 is a Promise2 instancetest(t =&gt; t.is(true, p1 instanceof Promise2));// Promise2 instace muse has function catchtest(t =&gt; t.is(&apos;function&apos;, typeof p1.catch));// Promise2 instace muse has function thentest(t =&gt; t.is(&apos;function&apos;, typeof p1.then)); 要让这些测试用例通过，编写了如下代码： 1234567891011121314151617181920212223242526272829303132class Promise2 &#123; constructor() &#123; &#125; static all() &#123; &#125; static race() &#123; &#125; static reject() &#123; &#125; static resolve() &#123; &#125; then() &#123; &#125; catch() &#123; &#125;&#125;module.exports = Promise2; 至此，我们的一个程序基架已经ok了。接下来我们一步步的来继续完善测试和实现代码。 接下来，我们看一下Promise的常规用法： 1234567let p = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log('before resolve'); resolve(); console.log('after resolve'); &#125;, 1000);&#125;); 参考资料 MDN Promise Promise Book Promise A+ 规范 ECMA262 Promise"},{"title":"如何用Node编写命令行工具","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/前端相关/如何用Node编写命令行工具/","text":"0、 命令行工具当全局安装模块之后，我们可以在控制台下执行指定的命令来运行操作，如果npm一样。我把这样的模块称之为命令行工具模块（如理解有偏颇，欢迎指正） 1、用Node编写命令行工具在Node中，我们很容易就能实现一个命令行工具。通过借助npm install -g安装，就能直接调用命令行工具了。 1.1、创建项目首先，命令行也是一个node程序，那么首先通过npm init初始化一个Node项目。 123456789101112// package.json&#123; \"name\": \"newkit-cli\", \"version\": \"0.0.1\", \"description\": \"Newkit Management Tools\", \"main\": \"index.js\", \"scripts\": &#123; \"test\": \"test\" &#125;, \"author\": \"Jay\", \"license\": \"MIT\"&#125; 1.2、创建可执行代码在项目目录下，创建src目录，并在其中创建index.js文件 12//src/index.js文件内容console.log('cli'); 通过node src/index就可以执行到段代码了，那如何用自定义命令来执行呢？ 1.3、在package.json中配置自定义命令在package.json中可以配置bin节点，当全局安装的时候，该节点内容将会被注册为自定义命令。1234567891011121314&#123; \"name\": \"newkit-cli\", \"version\": \"0.0.1\", \"description\": \"Newkit Management Tools\", \"main\": \"index.js\", \"bin\": &#123; \"nc\": \"./src/index.js\" &#125;, \"scripts\": &#123; \"test\": \"test\" &#125;, \"author\": \"Jay\", \"license\": \"MIT\"&#125; 1.4、测试命令假设我们已经写好了命令行工具了，那我们应该如何测试呢？ 我们可以通过npm install -g将当前模块安装到全局模块中。然后再执行nc命令来测试。 通过如上步骤，我们发现并不能执行我们的index.js，这是为什么呢？ 因为我们并没有指定用什么工具来执行这条命令，所以应该怎么做呢？打开index.js，然后加上一句代码： 123#!/usr/bin/env node console.log('cli'); 这句代码什么意思呢？这句代码告诉系统，使用node来启动我们的命令。此时再安装，然后执行nc，你会发现，控制台会打印出cli。也就是我们index中代码的执行结果。 至此，我们的一个最简单的命令行执行就开发成功了。 2、处理命令行参数单纯的执行一个命令，似乎不满足我们的实际运用场景，大部分时候我们会使用nc version、nc xxx -a --b之类的方式来使用命令。那应该如何获取这些命令呢？ 2.1、使用process来获取控制台参数将index.js代码修改一下，如下：1234#!/usr/bin/env node console.log('cli');console.log(process.argv); 安装之后，再次执行nc xxx -a --b true,会看到如下的输出： 1234567cli[ &apos;C:\\\\Program Files\\\\nodejs\\\\node.exe&apos;, &apos;C:\\\\Users\\\\jh3r\\\\AppData\\\\Roaming\\\\npm\\\\node_modules\\\\newkit-cli\\\\src\\\\index.js&apos;, &apos;xxx&apos;, &apos;-a&apos;, &apos;--b&apos;, &apos;true&apos; ] 从结果可以看到，我们所使用所有参数都会传递到程序中去，这个时候，我们就可以解析这些参数，来实现不同的输出了。 2.2、使用Commander来开发命令行工具从上面的输出也可以看到，我们要手动去解析参数的话，还是一个比较复杂的操作。既然身处Node社区，那么完全使用社区流行的包来帮我们简化代码。 Commander 是一款重量轻，表现力和强大的命令行框架。提供了用户命令行输入和参数解析强大功能。 Commander的方便之处在于：自记录代码、自动生成帮助、合并短参数（“ABC”==“-A-B-C”）、默认选项、强制选项​​、命令解析、提示符 我们可以在https://github.com/tj/commander.js/找到Commander。 继续改造index.js文件，修改内容为：123456789101112131415#!/usr/bin/env node var program = require('commander');program .version('0.0.2') //提供命令行工具的版本号，可以通过-V获取到 // 使用option方法注册命令 .option('-i, --init [type]', 'Initial Newkit in current folder', (type) =&gt; &#123; console.log('process', type, program.init); &#125;, true) .option('-u| --update &lt;module&gt;', 'Update module.', (moduleName) =&gt; &#123; //使用program.update 来获取默认值，如果有命令行参数，那么会作为回调函数的参数 console.log(moduleName, program.update); &#125;, 'app-common') .parse(process.argv); 注意：以上代码有较多注意的点 option方法参数是四个，第一个是命令，第二个是描述，第三个是回调，第四个是命令的默认值 第一个参数中的-i和-u是短命令，–init和–update是长命令。长短命令之间的分隔符可以是|和,，如果使用逗号分隔，那么可以通过program.init来获取默认值。 在代码中我们在命令中，注意到有[type]和&lt;module&gt;两种，前者是可选参数，后者的必选参数。 除此之外，还可以使用command方法来实现Git风格的子命令，代码如下： 12345program .command('update &lt;module&gt;') .action((module, options) =&gt; &#123; console.log(module); &#125;); 更多功能，请自行测试 2.3、使用yargs来开发命令行工具具体代码如下： 1234567891011121314151617#!/usr/bin/env node var argv = require('yargs') .option('i', &#123; alias : 'init', demand: true, default: '', describe: 'Project Init', type: 'string' &#125;) .usage('Usage: nc init') .example('nc init', 'Initial newkit project') .help('h') .alias('h', 'help') .epilog('copyright 2015') .argv;//根据不同的参数来做处理 yargs更多信息请参阅：https://github.com/yargs/yargs 3、注意事项 根据Unix的传统，程序执行成功返回0，否则返回1 1234if(err)&#123; return process.exit(1);&#125;process.exit(0); 系统信号 12345process.on('SIGINT', function () &#123; console.log('Got a SIGINT'); process.exit(0);&#125;);//发送系统信号：$ kill -s SIGINT [process_id]"},{"title":"浏览器内容安全策略解析","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/前端相关/浏览器内容安全策略解析/","text":""},{"title":"浏览器 Pointer Events","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/前端相关/浏览器 Pointer Events/","text":"前言Pointer Events是一套触控输入处理规格，支持Pointer Events的浏览器包括了IE和Firefox，最近Chrome也宣布即将支持该处理规则。 PointerEventPointEvent对象继承自MouseEvent，使用上也比较类似。 mousedown -&gt; pointerdown mouseenter -&gt; pointerenter mouseleave -&gt; pointerleave mousemove -&gt; pointermove mouseout -&gt; pointerout mouseover -&gt; pointerover mouseup -&gt; pointerup PointerEvent提供了多有预期的鼠标事件属性，并添加了通用的附加属性，来帮助您区分输入类型和特点。 height isPrimary pointerId pointerType pressure tiltX tiltY width 在现在的JS编码中，推荐使用特性检测（以前是浏览器检测）来编写代码，我们可以用以下代码检测浏览器是否支持该特性： if (window.PointerEvent) { // Pointer events are supported. } 那接下来看一下具体的事件代码： window.addEventListener(&apos;pointerdown&apos;, pointerdownHandler, false); function pointerdownHandler (evt) { console.log(evt) } 通过输出，可以更直观的看到PointerEvent的各个属性。 通过浏览器的navigator对象的maxTouthPoints，可以拿到当前设备支持的最大多点触控的数量： navigator.maxTouchPoints 从win8开始，IE提供了默认的触摸事件处理，如果想全部由js代码控制触摸事件，那么可以使用： touch-action: none; 来禁用默认值。 参考资料https://msdn.microsoft.com/en-us/library/ie/dn433244(v=vs.85).aspx.aspx) http://www.w3.org/TR/pointerevents/"},{"title":"浏览器历史history对象","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/前端相关/浏览器历史history对象/","text":"0、导言在单页应用时代，有一个非常重要的概念，那就是前端路由。那它到底是怎么实现的呢？ 路由一般有如下两种方式： HASH路由（控制浏览器hash变化） URL路由（URL直接变化） 本文主要关注URL变化这种路由实现。 1、History对象当我们浏览网页时，我们会点击其中的一个链接进行跳转，其中一部分是直接替换掉当前页面，此时就产生了历史记录。 在浏览器中，历史记录的存储我们无法直接控制，但是对于历史记录的使用，是可以通过 window.history 对象操作的。 比如我们可以查看当前访问了多少个页面： 1console.log(window.history.length); 可以后退和前进： 12window.history.back();window.history.forward(); 也可以以当前页面为基准，跳转到前N个或者后N个页面： 12window.history.go(2); // 前进两页window.history.go(-1); //后退1页 注意：如果前进或者后退的索引上没有相对应的历史记录，那么将不会跳转，如 go(555) 2、HTML5 history在HTML5， history 有了新的方法，允许我们逐条的添加和修改历史记录条目。 这些方法协同 window.onpopstate 事件，就构成了我们URL路由的基石。 以下，我们就来看看有哪些新增的方法。 2.1、pushState()使用该方法，可以推送一个状态到历史记录中去。函数使用方式如下： 1window.history.pushState(&#123;a:1, b:2&#125;, '', '/abc.html'); 其中参数一是一个JS对象，关联在历史条目中；参数二是标题字符串；（当前会被忽略，建议传递’’）参数三是可选的页面地址（改变URL） 注意：参数三是一个字符串，但不能带有http://， 可以直接写 xx.html，也可以传入 /xx.html。 注意2：虽然看起来效果有点类似 window.location = &#39;#abc&#39; ，但pushState()方法永远不会触发hashchange事件，即便新的地址只变更了hash 2.2、replaceState()replaceState 和 pushState 非常类似，前者是修改，后者是新增。 2.3、history.state 属性当我们正处在一个 state 状态下的时候，我们可以通过 history.state 来查看当前的 state 对象。 如上例中的 {a:1, b:2} 2.4、window.onpopstate 事件如果仅仅只能推送状态到 history 中，那我们可实现的操作非常有效。但当结合 onpopstate 事件，我们就能够实现一个可控制URL变化的前端路由器。 12345window.addEventListener('popstate', function(evt)&#123; console.log(evt);&#125;, false);window.history.pushState(&#123;key: 'k1'&#125;, '', 'abc.html'); 先执行以上代码，我们发现事件并没有触发，此时点击浏览器后退按钮，可以发现事件被触发。 注意：调用history.pushState()或者history.replaceState()不会触发popstate事件. popstate事件只会在其他浏览器操作时触发, 比如点击后退按钮(或者在JavaScript中调用history.back()方法)。 注意2：当网页加载时,各浏览器对popstate事件是否触发有不同的表现,Chrome 和 Safari会触发popstate事件, 而Firefox不会。 注意3：就算是进入非state页面（不是pushState或者replaceState作用过的），也会触发popstate事件。 3、URL-Router有了之前的这些基础，我们来看看，实现一个简单的前端路由需要多少代码？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960;(() =&gt; &#123; let urlRouter = &#123;&#125;; let container; let routeMapCache; let getPage = (url, callback) =&gt; &#123; let xhr = new XMLHttpRequest(); xhr.open('GET', url, true); xhr.setRequestHeader('Accept', 'text/plain'); xhr.onreadystatechange = () =&gt; &#123; if (xhr.readyState === XMLHttpRequest.DONE) &#123; callback &amp;&amp; callback(xhr.responseText); &#125; &#125; xhr.send(); &#125;; urlRouter.init = (routeMap, options) =&gt; &#123; routeMapCache = routeMap; if (options.container instanceof HTMLElement) &#123; container = options.container; &#125; else &#123; container = document.querySelector(options.container); &#125; // 处理状态变化 window.addEventListener('popstate', function (evt) &#123; let stateObj = history.state || evt.state; console.log(evt, stateObj); if (stateObj) &#123; urlRouter.go(stateObj.state); &#125; &#125;, false); // 初始化时，处理默认状态 let path = window.location.pathname; let stateKeys = Object.keys(routeMapCache); for (let i = 0; i &lt; stateKeys.length; i++) &#123; let stateObj = routeMapCache[stateKeys[i]]; if (stateObj.url === path) &#123; urlRouter.go(stateKeys[i]); return; &#125; &#125; &#125;; urlRouter.go = (state) =&gt; &#123; let stateObj = routeMapCache[state]; if (!stateObj) &#123; throw new Error('state not found.'); &#125; stateObj.state = state; window.history.pushState(stateObj, '', stateObj.url); getPage(stateObj.path, (content) =&gt; &#123; container.innerHTML = content; &#125;); &#125;; window.urlRouter = urlRouter;&#125;)(); 如何使用？ 12345678910111213141516171819let routeMap = &#123; 'page1': &#123; url: '/page1', path: 'page1.html' &#125;, 'page2': &#123; url: '/page2', path: 'page2.html' &#125;, 'page3': &#123; url: '/page3', path: 'page3.html' &#125;,&#125;;// 初始化路由window.urlRouter.init(routeMap, &#123; container: '#page-content' &#125;);//路由跳转let links = [].slice.call(document.querySelectorAll('#page-menu li a'));links.forEach(link =&gt; &#123; link.addEventListener('click', function (evt) &#123; evt.stopPropagation(); evt.preventDefault(); window.urlRouter.go(evt.target.getAttribute('href')); &#125;, false);&#125;); 具体Demo地址：URL-Router Demo"},{"title":"浏览器关闭事件分析","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/前端相关/浏览器关闭事件分析/","text":"0、导言很多时候，我们可能会遇到这样一类需求： 浏览器关闭时，弹出一个新页面 浏览器关闭时，发送统计信息（如页面浏览时长） 浏览器关闭时，让用户二次确认 这个时候，我们就需要考虑如何判断浏览器关闭，如何阻止浏览器关闭，如何在浏览器关闭时，还是执行特定操作。 1、浏览器关闭与刷新判断对于关闭与刷新判断，一般有以下几种做法： 首先基础都是通过监听 onbeforeunload、onunload 等相关事件。 然后判断刷新与关闭： 判断鼠标坐标 判断键盘操作 判断事件间隔时长 其中，1和2一般是合起来使用。但也并不保险。关闭和刷新的快捷操作是可以自定义的。而且实现逻辑复杂。 在这里，我就重点来测试线通过判断事件间隔的方式来处理关闭与刷新的判断。 我们编写了如下测试代码 123456789window.onbeforeunload = function () &#123; console.log('onbeforeunload', Date.now()); debugger&#125;;window.onunload = function()&#123; console.log('onunload', Date.now()); debugger&#125; 分别在浏览器上刷新和关闭，得到如下结果： 浏览器 关闭/刷新 onbeforeunload onunload Chrome 关闭 [x] [x] Chrome 刷新 [x] [x] Firefox 关闭 [x] [x] Firefox 刷洗 [x] [x] Edge 关闭 [x] [] Edge 刷新 [x] [x] IE11 关闭 [x] [x] IE11 刷新 [x] [x] Edge关闭时，unload是否触发，还并不太确定（不太好验证）。 接下来，我们来验证两个时间的触发时间，测试代码如下： 123456789101112131415window.onbeforeunload = function (evt) &#123; console.log('onbeforeunload', Date.now()); if (navigator.sendBeacon) &#123; navigator.sendBeacon('http://localhost:9999/?t=onbeforeunload', 'onbeforeunload'); &#125; window.start = Date.now();&#125;;window.onunload = function () &#123; console.log('onunload', Date.now()); if (navigator.sendBeacon) &#123; navigator.sendBeacon(`http://localhost:9999/?t=onunload&amp;ts=$&#123;Date.now() - window.start&#125;`, 'onunload'); &#125; window.open('http://10.16.85.170:8000/');&#125; 通过 navigator.sendBeacon 将间隔时间发送到后台进行查看。遗憾的是，IE和Edge并不支持该方法。 测试得出如下表格： 浏览器 关闭/刷新 onbeforeunload onunload 时间间隔 Chrome52 关闭 [x] [x] &lt; 5ms Chrome52 刷新 [x] [x] &gt; 20ms Firefox46 关闭 [x] [x] &gt; 200ms Firefox46 刷洗 [x] [x] 10~100ms Edge13 关闭 [x] [] N/A Edge13 刷新 [x] [x] &lt; 5ms IE11 关闭 [x] [x] &gt; 10ms IE11 刷新 [x] [x] &lt; 5ms 根据这个表格，然后在按照自己的需要，就可以选择一个分割点来判断是刷新还是关闭。 当前未发现100%能判断清楚的方法，以上请酌情使用。 2、阻止浏览器关闭有一些场景，要求在浏览器关闭的时候，再次弹出一个确认框，那这个又应该如何实现呢？ 关闭时询问，是一个比较标准化的处理了，只需要我们对 unbeforeunload 事件的 event 参数设置返回值，即可达到再次确认的效果。实现代码如下： 123window.addEventListener('beforeunload', function(evt)&#123; evt.returnValue = '您确定要离开了么？';&#125;, false); 注意：火狐为了避免不必要的弹窗，如果页面没有交互，是不会进行二次确认的，通过不会显示returnValue给用户。相关链接： https://developer.mozilla.org/zh-TW/docs/Web/API/WindowEventHandlers/onbeforeunload 3、浏览器关闭/刷新时发送统计数据很多时候，我们想在浏览器关闭/刷新时发送一些统计数据，之前的话，我们可以采用如下一些做法： 在 onbeforeunload 中使用同步Ajax 发送Ajax，然后使用死循环，阻塞一个该事件。 这个功能作为一个比较大众化的需求，W3C中也有了一个针对性的草案，那就是浏览器对象的 sendBeacon 方法。 函数签名如下： 1navigator.sendBeacon(url, data); 有了这个方法，我们就可以在合适的地方（诸如onbeforeunload）发送我们的统计数据，日志数据等等。 注意：该方法还是草案阶段，当前IE和EDGE暂不可用。 4、相关资料 MDN WindowEventHandlers.onbeforeunload MDN Navigator.sendBeacon()"},{"title":"简单学ES6","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/前端相关/简单学ES6/","text":"##前言##随着ES6标准的定稿，众多的特性也趋于稳定，各大浏览器也在逐步实现这些特性，那么对ES6有更多的了解就无可厚非了。 ##准备##在学习ES6之前，我们需要有一个环境来测试ES6代码。在这里我推荐使用node的分支io.js。 如何安装？ 下载地址：https://iojs.org/en/index.html，如果各位小伙伴不习惯英文，可以把url中的en修改为cn。 然后根据自己的操作系统版本，下载合适的安装包（主要指Windows系统）进行安装。 安装过程就不一一赘述了，和一般软件一样。 如何验证安装成功？ 打开cmd，然后输入iojs -v,如果输出一个版本号，那么就代表io.js安装成功。（PS：我现在使用的是v1.2.0） 也可以输入iojs -p process.versions.v8查看iojs所使用的V8（PS：不是V8发动机）的版本。（PS:我这儿显示4.1.0.14） ##小窥ES6##在测试ES6代码前，我们可以先看下io.js对ES6的支持：https://iojs.org/cn/es6.html。 接下来，开始我们的ES6-Class之旅： ###1、class 基础 ### 大家应该知道，在大部分面向对象的语言中，都有class的说法，那么在早期的Js中，面向对象的实现比较特殊，我们必须要用function来模拟。如： //ES5及以下 function Point(x, y){ this.x = x; this.y = y; } var p1 = new Point(100, 100); 然而在ES6中，我们可以直接使用class关键字，如： //ES6 &apos;use strict&apos; //不能去掉，要不然iojs会提示不认识class。 class Point{ constructor(x, y){ this.x = x; this.y = y; } } var p1 = new Point(100, 100); console.log(p1); 将以上代码保存为1.js,那么执行如下命令：iojs --es_staging 1.js 就可以看到”{x:100, y: 100}”这个结果了。（PS:注意要在1.js的目录打开cmd）。 接下来，看一个复杂点的，继承： //ES6 &apos;use strict&apos; class Point{ constructor(x, y){ this.x = x; this.y = y; } } var p1 = new Point(100, 100); console.log(p1); class ColorPoint extends Point{ constructor(x, y, color){ super(x, y); this.color = color; } } var cp = new ColorPoint(50, 50, &apos;red&apos;); console.log(cp); //输出继承关系 console.log(cp instanceof ColorPoint); //true console.log(cp instanceof Point); //true 可以看到，和大部分语言的继承都很类似，如果你有其他面向对象语言的基础，那么很容易就能理解。 对Point和ColorPoint进行typeof，结果很明显也能看到是function。 console.log(typeof Point); // function console.log(typeof ColorPoint); // function 那如果对class进行函数调用呢？ Point(100, 100); //Error 如上，必须通过new调用class，直接使用函数调用则会报错。 再来对比以下代码： //标准的函数可以先写调用语句，后写申明语句。因为会定义前置 foo(); function foo(){} //如果是class呢? new Foo(); //Error,Foo is not defined class Foo{} 如上，如果是定义的class，那么必须要定义语句在前，调用在后。 再来看以下的情形： function funThatUseBar(){ new Bar(); } //funThatUseBar(); //Error,Bar is not defined class Bar{} funThatUseBar(); //ok 如上，如果先使用了Bar，那么也是会报错的。必须要优先定义class。 附上以上所有的js，会报错的语句，进行了注释。 //ES6 &apos;use strict&apos; class Point{ constructor(x, y){ this.x = x; this.y = y; } } var p1 = new Point(100, 100); console.log(p1); class ColorPoint extends Point{ constructor(x, y, color){ super(x, y); this.color = color; } } var cp = new ColorPoint(50, 50, &apos;red&apos;); console.log(cp); //********************************************* //输出继承关系 console.log(cp instanceof ColorPoint); //true console.log(cp instanceof Point); //true console.log(typeof Point); // function console.log(typeof ColorPoint); // function //Point(100, 100); //Error //************************************ //标准的函数可以先写调用语句，后写申明语句。因为会定义前置 foo(); function foo(){} //如果是class呢? //new Foo(); //Error,Foo is not defined class Foo{} //******************************************* function funThatUseBar(){ new Bar(); } //funThatUseBar(); //Error,Bar is not defined class Bar{} funThatUseBar(); //ok ###2、类中的主体 ES6中、class的主体只能包含方法，不能包含数据属性。如果在类中包含变量定义，则会报错。class中的方法有三种类型：构造函数、静态方法、原型方法，如： class Class1{ //构造 constructor(options){ } // 静态方法，静态方法用static修饰 static staticMethod(){ return &apos;static method&apos;; } prototypeMethod(){ return &apos;prototype method&apos;; } } 其中，每个class和class原型的constructor都是相等的，同时class本质也是function console.log(Class1 === Class1.prototype.constructor) // true console.log(typeof Class1) // function 然后我们对类中的方法做测试 var p = console.log; p(typeof Class1.prototype.prototypeMethod); Class1.prototype.prototypeMethod() // 原型方法调用方式 p(typeof Class1.staticMethod); Class1.staticMethod() //静态方法调用方式 Getters 和 Setters 的用法 class Class2{ get name(){ return &apos;jay&apos;; } set name(value){ console.log(&apos;set name = &apos; + value); } } var c2 = new Class2(); c2.name = &apos;hu&apos;; // &quot;set name = hu&quot; console.log(c2.name); // &quot;jay&quot; 当使用了get和set时，那么针对属性的get和set会自动调用class中相关的方法。 贴出所有Js代码： &apos;use strict&apos; class Class1{ //构造 constructor(options){ } // 静态方法 static staticMethod(){ return &apos;static method&apos;; } prototypeMethod(){ return &apos;prototype method&apos;; } } console.log(Class1 === Class1.prototype.constructor); console.log(typeof Class1); var p = console.log; p(typeof Class1.prototype.prototypeMethod); p(typeof Class1.staticMethod); class Class2{ get name(){ return &apos;jay&apos;; } set name(value){ console.log(&apos;set name = &apos; + value); } } var c2 = new Class2(); c2.name = &apos;hu&apos;; console.log(c2.name); ###3、类的继承 简单的继承关系，如下： &apos;use strict&apos; class Class1{ toString(){ return &apos;parent class.&apos;; } } class SubClass extends Class1{ toString(){ return &apos;sub class.&apos;; } } var sc = new SubClass(); console.log(sc.toString()); // &quot;sub class&quot; 其中，sc是Class1的实例，也是SubClass的实例： console.log(sc instanceof Class1); //true console.log(sc instanceof SubClass); //true 如果要调用父类的方法，怎么办呢？ class SubClass2 extends Class1{ toString(){ return super.toString(); } } var sc2 = new SubClass2(); console.log(sc2.toString()); 在继承关系中，子类的原型等于父类： console.log(Object.getPrototypeOf(SubClass2) === Class1); //true 在子类中访问父类构造，使用super即可。 ##其他## 如果想一览所有的ES6新特性，可以参考https://github.com/lukehoban/es6features 如果想系统的学习ES6，那么推荐http://es6.ruanyifeng.com/ 想了解更多Classes in ECMAScript 6，可参考http://www.2ality.com/2015/02/es6-classes-final.html"},{"title":"记一次Bug排查（Spider）","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/前端相关/记一次Bug排查（Spider）/","text":"0、写在之前Spider是什么？Spider是基于Express框架结合socket.io（现已切换为ws）和Echarts2实现的即时性能监视工具。整体结构为前后端分离，通过express的static中间件来处理静态请求，Express本身则处理api请求。 用法上，只需要按照指定的格式post数据给Spider，那么当请求Spider展示时，将会自动将数据展示为图表。 项目地址：http://trgit2/backend_framework/spider 展示地址：http://developer.newegg.org/spider Spider能做什么？Spider可以提供一段时间（最大30分钟）内特定操作的消耗时间统计图（散点图）。大概展示效果如下图： 1、问题初现该项目从15年3月发布，由于用户量较少，一直稳定运行。 近期，MPS团队使用它来监控业务请求各个阶段的耗时情况，用于定位性能问题。此时，问题出现，spider运行一段时间（10~30分钟）后将会消耗大量服务器内存，导致内存不足而崩溃。 此时，用户使用场景： 在c#程序中，收集各种类型操作的耗时数据，累计起来。 每隔1s将数据提交到spider后端。 打开监控页面，查看数据（可能会有多个监控端） spider处理过程： 接收到请求数据之后，将数据进行处理，并存入内存； 如果发现有监控端运行，那么推送数据给监控端（每次收到请求数据都会触发一次推送） 监控端根据最新的数据绘制图表展示。 2、问题分析猜想1：Node代码写法问题，导致内存泄露因为JS的闭包容易内存泄露，首先怀疑代码写法问题。 验证：经过仔细排查代码，并对有可能有泄露代码进行改写 结果：问题未解决，未缓解 猜想2：缓存数据的代码有内存泄露由于客户端提交的数据是直接写入内存的，而刚好又是消耗内存，那么开始怀疑缓存数据的代码。 验证：重写了数据缓存代码（参考正常运行的缓存代码实现） 结果：问题未解决，未缓解 此时，把最常见的情况都验证了，无解。思绪中断，接着做了哪些事情呢？ 查找有可能导致JS内存泄露的情况，一一确认。 安装JS的内存分析工具（条件苛刻，未安装成功）。 安装Node程序的监控包，进行大量本地测试（很难复现问题）。 此时陷入困境… 再次想方设法安装内存分析工具，在本地测试，未果（问题很难复现）。 线上测试，问题依旧，根据结果，发现大量字符串占用内存，导致内存不足。 分析代码，查找该字符串初现的位置。 开始新的猜测 ###猜想3：socket.io内存泄露 从内存分析的结果来看，大量字符串占用了内存，该格式的字符串，是由socket.io分发到客户端的时候产生的。所以怀疑到了socket.io头上。 通过查资料，发现socket.io确实有内存泄露的前科，一度认为这就是原因。 验证1：升级socket.io到最新的版本 结果1：有一定的好转，但不明显（坚持的时间稍微久一点，内存偶尔能回收一下） 再次各种查资料，发现有提到强制node使用gc回收，可以处理非托管内存。 验证2：增加gc回收代码，定时执行 结果2：基本上看起来无效，和结果1并没有太大区别 此时，有点穷途末路了。问题还在，继续探索 验证3：考虑到项目本身不大，重新使用了一个新的WebSocket(ws)包来推送数据 结果3：有明显好转，坚持的时间更长了（一度认为解决了问题） 可是好景不长，较长时间（几小时）后，问题再次出现 猜想4：再度怀疑缓存代码此时未直接验证，切换到业界一个比较流行的缓存库(lru-cache)。 猜想5：每次提交数据都会触发一次推送，推送频率较高，导致数据阻塞这个猜想，算来后面总结的。一开始怀疑过这个问题，想过降低推送频率，但没有实施。经@James分析也猜测问题可能会出现在此处，因为大量字符串占用内存，也满足这个猜想。想到就做： 验证：将每次收到数据触发推送，修改为间隔一定时间（5s）推送一次。 结果：内存趋于平稳，及时性在接收范围内。 至此，问题基本上算是解决了。 3、Bug分析此次问题，是由于服务端推送数据量较大，而且频率较高，上次推送未完成，就触发了下一次推送。导致消息阻塞，越积越多，所以就耗尽内存而亡。 4、后续之后，spider运行一天多之后死掉过一次，但没有看到具体原因。重启之后，稳定运行至今。暂时性怀疑中途死掉的一次为意外（或者瞬时流量大增） 5、总结从发现该问题，到解决该问题，耗时大概在一周。虽然期间还处理了其他任务，但整体来说解决这个问题还是消耗了很长的时间。 究其原因： 对TCP底层传输数据不太熟悉 没有处理大量数据高频率推送的经验 发布时，只对程序进行了简单的本地测试，没有进行压力测试。 学到了什么： 对代码负责，以更严谨的态度来对待，减少出问题 对WebSocket的负载和相关设计有了更深刻的理解 多做一些测试，更稳定的保持代码质量"},{"title":"说说如何部署node程序","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/前端相关/说说如何部署node程序/","text":"0、前言Node作为时下流行的服务端运行时，我们就不得不接触另外一个方面的内容，那就是部署。此文就来说一下node的部署问题。 1、开发时部署在开发阶段，我们可以随意部署，直接通过 node xxx.js 就能很方便的启动项目。 123这种方式有一个弊端，每次代码变更之后，我们需要手动去重启。这个时候，我们可以借助一些第三方工具来实现监控代码变更。如： gulp-develop-server、nodeman、node-supervisor等等。 2、上线时如何部署？2.1、原始做法既然开发时，可以用 node xxx.js，那上线时也一样。妥妥的。 12345678弊端：会启动一个黑窗口，不能关闭，登录不能被注销``` ### 2.1、原始做法，升级版在Windows下，通过 ``start /b node xxx.js`` ，让程序后台运行。在Linux下，通过 ``node xxx.js &amp;`` 或者 ``nohup node xxx.js &gt; xxx.log &amp;`` 来实现后台运行。 该方式，避免了阻塞当前控制台，但是其他弊端与2.1一致。123456789101112131415161718### 2.2、使用进程管理器工具Node社区中，有比较多进程管理工具。如 [forever](https://github.com/foreverjs/forever) , [pm2](https://github.com/Unitech/pm2), [strongloop](https://github.com/strongloop/strongloop) 等等。我这里推荐 ``pm2``，功能强大，操作简单，监控，自动重启，多进程都能支持。以下以 ``pm2`` 为例，演示一下部署方式：通过 ``npm install pm2 -g`` 安装 ``pm2``通过 ``pm2 start xxx.js`` 启动程序通过 ``pm2 stop|restart|delete`` 来停止，重启，删除程序。通过 ``pm2 list`` 可以查看部署的程序。更多操作，请参考：[http://pm2.keymetrics.io/](http://pm2.keymetrics.io/) 这种部署方式，还有一个问题，服务器重启后，无法自动启动。``` 2.3、使用进程管理器工具，升级版在Linux上，通过 pm2 startup [platform] 就能默认生成一个开机启动项。 如果是Windows，我们可以通过 pm2-windows-service 或者是 pm2-windows-startup 来把 pm2 做成Windows服务。 了解更多：http://pm2.keymetrics.io/docs/usage/startup/ 2.4、Docker部署借助Docker提供的独立环境，以上方式均可以在docker中实现，而且就算直接用 node xxx.js 来启动应用，在docker中也是没问题的。 自动开机启动，则成了docker的问题，而不是部署程序的问题。 2.5、更多部署方式待探索…"},{"title":"TypeScript札记：特性总览","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/TypeScript札记/TypeScript札记：特性总览/","text":""},{"title":"JavaScript之糟粕","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/JS札记/JavaScript之糟粕/","text":"0、导言在上篇《JavaScript之毒瘤》中，列举了一些在JavaScript中难以避免的问题特性。本篇将会展示JavaScript中有问题的特性，但我们很容易就能便面它们。通过这些简单的做法，让JavaScript称为一门更好的语言。 1、==JavaScript有两组相等运算符。 === 和 !==，以及 == 和 !==。 === 和 !== 不会进行类型转换，一般会按照你期望的方式工作。由于JavaScript的类型转换系统相当复杂，如果要确保==和 != 不出错，就必须要牢记转换规则。另外==运算符缺乏传递性。 //关于传递性 if a === b, b === c then a === c; if a == b, b == c then a 不一定等于 c，破坏了传递性 小测验： &apos;&apos; == &apos;0&apos; 0 == &apos;&apos; 0 == &apos;0&apos; false == &apos;false&apos; false == &apos;0&apos; false == undefined false == null null == undefined &apos;\\t\\t\\n&apos; == 0 总结：推荐使用===和!==，尽量避免使用==和!=。 2、with语句JavaScript提供了一个with语句，本意是用它来快速访问对象，不幸的是，它的结果可能有时不可预料。 小测验： window.a = 1; var obj={}; with(obj){ console.log(a); } obj.a = 2; with(obj){ console.log(a); } 结论：避免使用with。 3、evaleval函数传递一个字符串给JavaScript编译器，并且执行结果。有问题问题呢？首先是代码难以阅读，另外需要运行编译器，导致性能低下；同时，还减弱了程序的安全性。注：Function构造函数，setTimeout、setInterval的字符串参数形式和eval是执行方式一致。 结论：避免使用eval，setTimeout、setInterval的字符串参数和Function构造函数。 4、continuecontinue语句跳到循环顶部，性能比较低下。 小测验： var counter = 10; console.time(&apos;t1&apos;); var sum = 0; for(var i = 0; i &lt; counter; i++){ if(i % 3 !== 0){ continue; } sum = sum + i; } console.log(sum); console.timeEnd(&apos;t1&apos;); console.time(&apos;t2&apos;); var sum = 0; for(var i = 0; i &lt; counter; i++){ if(i % 3 === 0){ sum = sum + i; } } console.log(sum); console.timeEnd(&apos;t2&apos;); 结论：尽量优化代码，减少continue的使用。 5、switchswitch语句中，除非明确的中断流程，否则每次条件判断后，都可以穿越到下一个case条件。这很容易造成bug。 小测验： var a = 15; switch(a){ case a * 1 : console.log(&apos;a*1&apos;); case a / 1: console.log(&apos;a/1&apos;); default: console.log(&apos;a&apos;); } 结论：不要刻意的使用case条件穿越。 6、缺少块的语句if、while、do或for可以接受代码块，也可以接受单行语句。单行语句的形式是一种带刺的玫瑰。虽然它可以节约2个字节，但它模糊了程序的结构。 小测验： if(1 == &apos;0&apos;) console.log(&apos;1 == 0&apos;); console.log(&apos;my god&apos;); // VS if(1 == &apos;0&apos;){ console.log(&apos;1 == 0&apos;); } console.log(&apos;my god&apos;); 结论：避免使用模糊程序结构的单行语句。 7、++ –递增和递减使得可以用非常简洁的风格去编码。但是它可能造成缓冲区溢出、同时往往让代码变得拥挤也不易于理解。 小测验： var a = 1; a = a++ + ++a; console.log(a); a = 1; a = a++ + a++; console.log(a); 结论：避免使用++ –。 8、位运算符JavaScript有着和Java相同的一套位运算符。Java中位运算符处理整数，非常快。在JavaScript中，只有双精度浮点数，所以位运算非常慢。另外，&amp;非常容易误写为&amp;&amp;，使得bug容易被隐藏起来。 小测验： var counter = 10000; var a = 5; var sum = 0; console.time(&apos;t1&apos;); for(var i = 0; i &lt; counter; i++){ sum += a &lt;&lt; 1; } console.log(sum); console.timeEnd(&apos;t1&apos;); sum = 0; console.time(&apos;t2&apos;); for(var i = 0; i &lt; counter; i++){ sum += a * 2; } console.log(sum); console.timeEnd(&apos;t2&apos;); 结论：避免使用位运算符。 9、function语句 与 function表达式JavaScript中既有function语句，也有function表达式，这令人困惑，似乎看起来也差不多。function语句在解析时会产生变量提升，放宽了函数必须先申明后使用的的要求。同时，JS在if语句中使用function语句也是被禁止的，但实际上大多数浏览器允许在if中使用function语句，这有可能会导致兼容性问题。 由于一个语句不能以一个函数表达式开头，如下如下写法，可以改写为另外一种形式。 function (){}(); //Error (function(){}()); // Right 小测验： // function语句 function fun(){} // function表达式 var fun = function(){}; 结论：合理使用function语句和function表达式。 10、类型的包装对象JavaScript有一种类型的包装对象，如 new Number(1);这很容易令人困惑。 小测验: var num1 = new Number(1); var num2 = 1; console.log(typeof num1); console.log(num1 === num2); 结论：避免使用包装对象，如new Boolean(),new String(),new Number()等 11、newnew运算符创建一个继承于其原型的新对象，并将新创建的对象绑定给this。但是，如果忘记使用new，那么就得到一个普通的函数调用，对象属性也会被绑定到全局对象上。这不会导致什么编译警告，也没有运行警告。 根据惯例，需要用new的函数，以首字母大写命名。这能部分程度上便于我们发现错误。 小测验： function Person(){ this.name = &apos;Default&apos;; this.sex = undefiend; } Person(); new Person(); //更好的实现 function Person(){ if(this === window){ return new Person(); } this.name = &apos;Default&apos;; this.sex = undefiend; } 结论：合理的避免使用new。另外可以先判断this，再做对应处理。 12、void大部分语言中，void是一种类型，在Js中，void是一种运算符，接收一个运算数，并返回undefined 小测验： void 0 void true 结论：有限的使用void"},{"title":"ES6入门系列四（测试题分析）","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/ES6入门/ES6入门系列四（测试题分析）/","text":"0、导言ES6中新增了不少的新特性，来点测试题热热身。具体题目来源请看：http://perfectionkills.com/javascript-quiz-es6/。 以下将一题一题来解析what和why。 1、题目一(function(x, f = () =&gt; x) { var x; var y = x; x = 2; return [x, y, f()]; })(1) A、 [2, 1, 1] B、 [2, undefined, 1] C、 [2, 1, 2] D、 [2, undefined, 2] 解析：本题主要考察的知识点是1、参数值与函数体内定义的重名变量的优先级；2、ES6的默认参数；3、箭头函数。在本题中，先执行x的定义，然后函数参数x=1，接着是y = x = 1,接着再x = 2，第三个是执行f函数，箭头函数如果只是表达式，那么等价于return 表达式，由于箭头函数的作用域等于定义时的作用域，那么函数定义时x=1，所以最后的return x 等价于 return 1 2、题目二(function() { return [ (() =&gt; this.x).bind({ x: &apos;inner&apos; })(), (() =&gt; this.x)() ] }).call({ x: &apos;outer&apos; }); A、 [&apos;inner&apos;, &apos;outer&apos;] B、 [&apos;outer&apos;, &apos;outer&apos;] C、 [undefined, undefined] D、 Error 解析：本题主要考察的是箭头函数的作用域问题，箭头函数的作用域等于定义时的作用域，所以通过bind设置的this是无效的。那么结果就显而易见了。 3、题目三let x, { x: y = 1 } = { x }; y; A、 undefined B、 1 C、 { x: 1 } D、 Error 解析：本题主要考察的是对象赋值，先定义x，然后在赋值的时候会执行一次y=1，最后返回y的值。 4、题目四(function() { let f = this ? class g { } : class h { }; return [ typeof f, typeof h ]; })(); A、 [&quot;function&quot;, &quot;undefined&quot;] B、 [&quot;function&quot;, &quot;function&quot;] C、 [&quot;undefined&quot;, &quot;undefined&quot;] D、 Error 解析：本题主要考察定义函数变量时，命名函数的名称作用域问题。在定义函数变量时，函数名称只能在函数体中生效。 5、题目五(typeof (new (class { class () {} }))) A、 &quot;function&quot; B、 &quot;object&quot; C、 &quot;undefined&quot; D、 Error 解析：本题主要考察对象的类型，和原型方法。该提可以分解如下： // 定义包含class原型方法的类。 var Test = class{ class(){} }; var test = new Test(); //定义类的实例 typeof test; //出结果 6、题目六typeof (new (class F extends (String, Array) { })).substring A、 &quot;function&quot; B、 &quot;object&quot; C、 &quot;undefined&quot; D、 Error 解析：本题主要考察ES6中class的继承，以及表达式的返回值和undefined的类型。题目其实可以按照如下方式分解： //由于JS的class没有多继承的概念，所以括号被当做表达式来看 (String, Array) //Array,返回最后一个值 (class F extends Array); //class F继承成Array (new (class F extends Array)); //创建一个F的实例 (new (class F extends (String, Array) { })).substring; //取实例的substring方法，由于没有继承String，Array没有substring方法，那么返回值为undefined typeof (new (class F extends (String, Array) { })).substring; //对undefined取typeof 7、题目七[...[...&apos;...&apos;]].length A、 1 B、 3 C、 6 D、 Error 解析：本题主要考察的是扩展运算符…的作用。扩展运算符是将后面的对象转换为数组，具体用法是： [...&lt;数据&gt;] 比如 [...&apos;abc&apos;]等价于[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;] 8、题目八typeof (function* f() { yield f })().next().next() A、 &quot;function&quot; B、 &quot;generator&quot; C、 &quot;object&quot; D、 Error 解析：本题主要考察ES6的生成器。题目可以如下分解： function* f() { yield f }; //定义一个生成器 var g = f(); //执行生成器 var temp = g.next(); //返回第一次yield的值 console.log(temp); //测试，查看temp，其实是一个object temp.next()；//对对象调用next方法，无效 9、题目九typeof (new class f() { [f]() { }, f: { } })[`${f}`] A、 &quot;function&quot; B、 &quot;undefined&quot; C、 &quot;object&quot; D、 Error 解析：本题主要考察ES6的class，以及动态属性和模板字符串等。 实际上这个题动态属性和模板字符串都是烟雾弹，在执行new class f()的时候，就已经有语法错误了。 10、题目十typeof `${{Object}}`.prototype A、 &quot;function&quot; B、 &quot;undefined&quot; C、 &quot;object&quot; D、 Error 解析：本题考察的知识点相对单一，就是模板字符串。分解如下： var o = {Object}, str = `${o}`; typeof str.prototype; 11、题目十一((...x, xs)=&gt;x)(1,2,3) A、 1 B、 3 C、 [1,2,3] D、 Error 解析：本题主要考察的是Rest参数的用法，在ES6中，Rest参数只能放在末尾，所以该用法的错误的。 12、题目十二let arr = [ ]; for (let { x = 2, y } of [{ x: 1 }, 2, { y }]) { arr.push(x, y); } arr; A、 [2, { x: 1 }, 2, 2, 2, { y }] B、 [{ x: 1 }, 2, { y }] C、 [1, undefined, 2, undefined, 2, undefined] D、 Error 解析：本题看起来是考察let的作用域和of迭代的用法。实则是考察let的语法，let之后是一个参数名称。所以，语法错误 13、题目十三(function() { if (false) { let f = { g() =&gt; 1 }; } return typeof f; })() A、 &quot;function&quot; B、 &quot;undefined&quot; C、 &quot;object&quot; D、 Error 解析：本题非常有迷惑性，看似考察的let的作用域问题，实则考察了箭头函数的语法问题。 14、题目答案相信大家看过题目的解析，对题目答案已经了然。为了完善本文，还是在最后贴出所有题目的答案： ABBAB CBDDB DDD"},{"title":"03-基础结构","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/jQuery拆解/03-基础结构/","text":"0、jQuery() 与 new jQuery();在 jQuery 中,我们一般都是用 $(&#39;body&#39;)，实际上 new $(&#39;body&#39;) 也是可以用的。这是如何实现的呢？ 要能使用 new，那 jQuery 一定是一个 function，又要让直接调用也返回一个实例，那我们就可以考虑返回另外一个全新 function 的实例。 123var jQuery = function (selector, context) &#123; return new jQuery.fn.init(selector, context);&#125;; 通过以上这段代码，不管是用 new jQuery() 还是 jQuery() 返回的都是 init 方法的实例。 在定义 jQuery 这个方法的时候，实际上 fn 和 init 都还不存在。 1、jQuery.fn = jQuery.prototype12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061jQuery.fn = jQuery.prototype = &#123; // The current version of jQuery being used jquery: version, constructor: jQuery, // The default length of a jQuery object is 0 length: 0, toArray: function () &#123; return slice.call(this); &#125;, // Get the Nth element in the matched element set OR // Get the whole matched element set as a clean array get: function (num) &#123; // Return all the elements in a clean array if (num == null) &#123; return slice.call(this); &#125; // Return just the one element from the set return num &lt; 0 ? this[num + this.length] : this[num]; &#125;, // Take an array of elements and push it onto the stack // (returning the new matched element set) pushStack: function (elems) &#123; // Build a new jQuery matched element set var ret = jQuery.merge(this.constructor(), elems); // Add the old object onto the stack (as a reference) ret.prevObject = this; // Return the newly-formed element set return ret; &#125;, // Execute a callback for every element in the matched set. each: function (callback) &#123; return jQuery.each(this, callback); &#125;, map: function (callback) &#123; return this.pushStack(jQuery.map(this, function (elem, i) &#123; return callback.call(elem, i, elem); &#125;)); &#125;, slice: function () &#123; return this.pushStack(slice.apply(this, arguments)); &#125;, first: function () &#123; return this.eq(0); &#125;, last: function () &#123; return this.eq(-1); &#125;, eq: function (i) &#123; var len = this.length, j = +i + (i &lt; 0 ? len : 0); return this.pushStack(j &gt;= 0 &amp;&amp; j &lt; len ? [this[j]] : []); &#125;, end: function () &#123; return this.prevObject || this.constructor(); &#125;, // For internal use only. // Behaves like an Array's method, not like a jQuery method. push: push, // push = [].push sort: arr.sort, // arr = [] splice: arr.splice // arr = []&#125;; 通过以上方法指定了 jQuery 的原型对象，也可以看到它默认的原型方法。 2、jQuery.fn.init.prototype?看到了 jQuery 的构造和 jQuery.prototype 的申明，可能会有这样一个疑惑，在 jQuery() 中返回的明明是 jQuery.fn.init 的实例，为什么可以使用 jQuery.protptype 呢？ 我们先看看 init 函数的实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697var init = jQuery.fn.init = function (selector, context, root) &#123; var match, elem; // HANDLE: $(\"\"), $(null), $(undefined), $(false) // 没有给选择器还玩个毛啊 if (!selector) &#123; return this; &#125; // Method init() accepts an alternate rootjQuery // so migrate can support jQuery.sub (gh-2101) root = root || rootjQuery; // Handle HTML strings if (typeof selector === \"string\") &#123; if (selector[0] === \"&lt;\" &amp;&amp; selector[selector.length - 1] === \"&gt;\" &amp;&amp; selector.length &gt;= 3) &#123; // Assume that strings that start and end with &lt;&gt; are HTML and skip the regex check match = [null, selector, null]; &#125; else &#123; match = rquickExpr.exec(selector); &#125; // Match html or make sure no context is specified for #id if (match &amp;&amp; (match[1] || !context)) &#123; // HANDLE: $(html) -&gt; $(array) if (match[1]) &#123; context = context instanceof jQuery ? context[0] : context; // Option to run scripts is true for back-compat // Intentionally let the error be thrown if parseHTML is not present jQuery.merge(this, jQuery.parseHTML( match[1], context &amp;&amp; context.nodeType ? context.ownerDocument || context : document, true )); // HANDLE: $(html, props) if (rsingleTag.test(match[1]) &amp;&amp; jQuery.isPlainObject(context)) &#123; for (match in context) &#123; // Properties of context are called as methods if possible if (jQuery.isFunction(this[match])) &#123; this[match](context[match]); // ...and otherwise set as attributes &#125; else &#123; this.attr(match, context[match]); &#125; &#125; &#125; return this; // HANDLE: $(#id) &#125; else &#123; elem = document.getElementById(match[2]); if (elem) &#123; // Inject the element directly into the jQuery object this[0] = elem; this.length = 1; &#125; return this; &#125; // HANDLE: $(expr, $(...)) &#125; else if (!context || context.jquery) &#123; return (context || root).find(selector); // HANDLE: $(expr, context) // (which is just equivalent to: $(context).find(expr) &#125; else &#123; return this.constructor(context).find(selector); &#125; // HANDLE: $(DOMElement) &#125; else if (selector.nodeType) &#123; this[0] = selector; this.length = 1; return this; // HANDLE: $(function) // Shortcut for document ready &#125; else if (jQuery.isFunction(selector)) &#123; return root.ready !== undefined ? root.ready(selector) : // Execute immediately if ready is not present selector(jQuery); &#125; return jQuery.makeArray(selector, this);&#125;; 这个不多说，就是根据选择器查找元素。接下来，关键来了： 123456// 把jQuery.fn设置为init的原型init.prototype = jQuery.fn;// Initialize central reference// 从document开始查找rootjQuery = jQuery(document); 3、jQuery.extend = jQuery.fn.extend有了以上的基础，那么就该扩展 jQuery 的功能了。它的核心就是以下的扩展函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455jQuery.extend = jQuery.fn.extend = function () &#123; var options, name, src, copy, copyIsArray, clone, target = arguments[0] || &#123;&#125;, i = 1, length = arguments.length, deep = false; // Handle a deep copy situation if (typeof target === \"boolean\") &#123; deep = target; // Skip the boolean and the target target = arguments[i] || &#123;&#125;; i++; &#125; // Handle case when target is a string or something (possible in deep copy) if (typeof target !== \"object\" &amp;&amp; !jQuery.isFunction(target)) &#123; target = &#123;&#125;; &#125; // Extend jQuery itself if only one argument is passed if (i === length) &#123; target = this; i--; &#125; // 将属性扩展到指定的对象上。 for (; i &lt; length; i++) &#123; // Only deal with non-null/undefined values if ((options = arguments[i]) != null) &#123; // Extend the base object for (name in options) &#123; src = target[name]; copy = options[name]; // Prevent never-ending loop if (target === copy) &#123; continue; &#125; // Recurse if we're merging plain objects or arrays if (deep &amp;&amp; copy &amp;&amp; (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) &#123; if (copyIsArray) &#123; copyIsArray = false; clone = src &amp;&amp; jQuery.isArray(src) ? src : []; &#125; else &#123; clone = src &amp;&amp; jQuery.isPlainObject(src) ? src : &#123;&#125;; &#125; // Never move original objects, clone them target[name] = jQuery.extend(deep, clone, copy); // Don't bring in undefined values &#125; else if (copy !== undefined) &#123; target[name] = copy; &#125; &#125; &#125; &#125; // Return the modified object return target;&#125;; 为什么同一个 extend 函数可以扩展 jQuery，也可以扩展 jQuery.fn？这就涉及到另外一个JS的知识点了。 函数中this的指向是谁调用谁就是this。 4、小结以上就是 jQuery 的核心基础结构，如果我们自己要编写一个 Lib or Framework，也可以参考这样的方式来实现。 之后所有的功能，都是从这里进行扩展。"},{"title":"那些不常见的JavaScript题目（上）","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/JS札记/那些不常见的JavaScript题目（上）/","text":"0、导言JavaScript超乎寻常的灵活性，让JavaScript可以有很多特殊的用法，让我们来领略一下它们的风采吧。 此为上篇，下篇请查阅：下篇 1、那些不常见（好玩）的题目 1.1、1[\"1\", \"2\", \"3\"].map(parseInt) 解析： 该题考察数组的 Array.map() 函数和 parseInt()的用法。 Array.map()，接受两个两个，第一个是回调函数 function(currentValue, index, array)，第二个是可选参数 thisArg，用来指定回调函数的 this 对象，默认是 window。 1234['1', '2', '3'].map(function(currentValue, index, array)&#123; console.log(currentValue, index, array, this); return '1';&#125;, &#123;&#125;); 通过上面的代码可以验证 Array.map() 的用法，想更详细了解，请参考 MDN Array.map。 接着看 parseInt，parseInt 默认接受两个函数，第一个要是要转化的元素，第二个是进制，默认2~36，0的话，就当成10进制处理。如果超过则会返回 NaN。把它作为map的回调函数时，相当于给parseInt传递了三个参数。多余的参数对结果不影响，所以问题可以变形为：[parseInt(&#39;1&#39;, 0), parseInt(&#39;2&#39;, 2), parseInt(&#39;3&#39;,2)]，所以就能得出答案了。 答案： [1, NaN, NaN] 1.2、1[typeof null, null instanceof Object] 解析： 该题考察了对null的认识。 null 本身是一个类型（并不是Object的实例），但对它进行 typeof 会返回 object。 答案： [&#39;object&#39;, false] 1.3、1[ [3,2,1].reduce(Math.pow), [].reduce(Math.pow)] ] 解析：此题和1.1比较类似，考察 Array.reduce() 和 Math.pow() 方法的使用。 Array.reduce() 用于将数组的多个值根据指定的处理函数，合并为一个值。它的回调函数定义为 function(previousValue, currentValue, currentIndex, array){}，其中： previousValue // 上一次的运算结果（注意：该变量的初始值为数组的第一个元素） currentValue // 当前数组元素 currentIndex // 当前数组索引 array //数组本身 另外，需要注意，由于默认 previousValue 的初始值是第一个数组元素，那么实际的回调函数调用次数为：arr.length - 1。如果数组元素小于1，就会因为无法提供初始值，而导致方法异常（报错）。想了解更多，参考：MDN Array.reduce()。 Math.pow() 用于计算指定值的次方，接受两个参数，前者为基数，后者为几次方，如：Math.pow(2, 3) // 8。 答案： [9, error] 1.4、12var val = 'smtg';console.log('Value is ' + (val === 'smtg') ? 'Something' : 'Nothing'); 解析： 此题比较简单，考察+号运算符和?号运算符的优先级问题，+优先级大于?。 答案： &#39;Something&#39; 1.5、123456789var name = 'World!';(function () &#123; if (typeof name === 'undefined') &#123; var name = 'Jack'; console.log('Goodbye ' + name); &#125; else &#123; console.log('Hello ' + name); &#125;&#125;)(); 解析： 此题考察函数作用域、变量提前、全局变量和局部变量相关的知识点。JS默认是函数作用域，并且函数申明，变量申明会提前到函数体开头。所以题目代码等价于： 12345678910var name = 'World!';(function () &#123; var name; if (typeof name === 'undefined') &#123; name = 'Jack'; console.log('Goodbye ' + name); &#125; else &#123; console.log('Hello ' + name); &#125;&#125;)(); 再结合局部变量，会隐藏全局变量，所以答案就出来。 答案： Goodbye Jack 1.6、1234567var END = Math.pow(2, 53);var START = END - 100;var count = 0;for (var i = START; i &lt;= END; i++) &#123; count++;&#125;console.log(count); 解析： 此题考察的知识比较偏门，考察了JS中能正确计算且不失精度的最大整数，当达到这个数之后，++（自加）操作将不会产生变化了。所以&lt;=将永远满足条件。 答案： 死循环 1.7、123var ary = [0,1,2];ary[10] = 10;ary.filter(function(x) &#123; return x === undefined;&#125;); 解析： 此题考察了数组自动补齐元素和 Array.filter() 的用法。 数组自动补齐的元素为 undefined，示例如下： 123var arr = [];arr[9] = 1;console.log(arr); // [undefined * 9, 1] Array.filter() 用于筛选满足条件的数组元素，接受回调函数 function(currentValue, currentIndex, array){}。但是一定要注意：它会忽略自动填充的undefined的元素 再次警告：是仅仅忽略自动填充的undefined元素，如果不是自动填充的undefined，是不会被忽略的。 123456var arr = [1, 'str', undefined, null];arr.filter(function(item)&#123;console.log(item)&#125;); //执行四次，没有忽略var arr = [];arr[9] = 1;arr.filter(function(item)&#123;console.log(item)&#125;); //执行1次，忽略了自动填充的9个元素 为什么有这种现象呢？ 因为filter在判断的时候，是通过key来进行的，对比一下一下两种方式的key： 123456var arr = [1, 'str', undefined, null];Object.keys(arr); //一共有四个。var arr = [];arr[9] = 1;Object.keys(arr); //一共只有一个。 引申：该判断逻辑也适合大多数数组方法，如reduce，map等等。 答案： [] 1.8、12345var two = 0.2var one = 0.1var eight = 0.8var six = 0.6[two - one == one, eight - six == two] 解析： 该题考察了JS中的浮点数运算有误差的知识点。这个到底规则是什么，I don’t know. 答案： [true, false] 1.9、12345678910111213141516function showCase(value) &#123; switch(value) &#123; case 'A': console.log('Case A'); break; case 'B': console.log('Case B'); break; case undefined: console.log('undefined'); break; default: console.log('Do not know!'); &#125;&#125;showCase(new String('A')); 解析： 此题考察 new String(&#39;A&#39;) 产生的结果为 object，另外switch判断分支是使用 ===，所以只能到default分支。 答案： &#39;Do not know!&#39; 1.10、12345678910111213141516function showCase2(value) &#123; switch(value) &#123; case 'A': console.log('Case A'); break; case 'B': console.log('Case B'); break; case undefined: console.log('undefined'); break; default: console.log('Do not know!'); &#125;&#125;showCase(String('A')); 解析： 此题和1.9考察点类似，不过不适用new的 String(&#39;A&#39;)，返回的是字符串的 &#39;A&#39;。 注意，以此类推，Number(1), 也返回数字 1 。 答案： &#39;Case A&#39; 1.11、1234567891011function isOdd(num) &#123; return num % 2 == 1;&#125;function isEven(num) &#123; return num % 2 == 0;&#125;function isSane(num) &#123; return isEven(num) || isOdd(num);&#125;var values = [7, 4, '13', -9, Infinity];values.map(isSane); 解析： 此题没有什么难点，只需要记得 Infinity % 2 //NaN就可以了。其他直接根据传入的值，运算即可。 答案： [true, true, true, false, false] 1.12、123parseInt(3, 8)parseInt(3, 2)parseInt(3, 0) 解析： 此题的考察点，在1.1就考察过了。 答案： 3, NaN, 3 1.13、1Array.isArray(Array.prototype) 解析： 此题考察Array的原型。 1Array.prototype // [] 答案： true 1.14、123456var a = [0];if ([0]) &#123; console.log(a == true);&#125; else &#123; console.log(\"wut\");&#125; 解析： 死记硬背吧。参考图 答案： false 1.15、1[]==[] 解析： 此题如上，也可以理解没有类型转换，引用不同。 答案： false 1.16、12'5' + 3 '5' - 3 解析： 此题考察类型转换，和 + 号的作用。当有字符串操作数时，+ 表示字符串连接。 答案： &#39;53&#39;, 2 1.17、11 + - + + + - + 1 解析： 此题，个人根据结果归纳了一套规则： 首先，忽略所有的+号， 得到： 1 - - 1 然后 - - 得正，成为 + 号，得到：1 1 把最后的操作数相加，即为结果 测试代码： 1235 + 1 - 1 + 2 + 3 + 1 // 115 - 1 - 1 - 1 - 1 - 10 - 5 - 20 // -341 - - - - - - 1 // 2 答案： 2 1.18、123var ary = Array(3);ary[0]=2ary.map(function(elem) &#123; return '1'; &#125;); 解析： 此题的考察点在1.7就考察过了。但是需要注意，map函数，并不改变结果数组的长度。 答案： [&#39;1&#39;, undefined*2] 1.19、123456789function sidEffecting(ary) &#123; ary[0] = ary[2];&#125;function bar(a,b,c) &#123; c = 10 sidEffecting(arguments); return a + b + c;&#125;bar(1,1,1) 解析： 此题考察改变 arguments的属性值，会不会影响该对象。由于 arguments 是个对象，实际上是会影响的。注意：使用 use strict 可以避免此种情况。 答案： 21 注意：当使用ES6语法，参数有rest parameters的时候，结果就不在一样了。 123456789function sidEffecting(ary) &#123; ary[0] = ary[2];&#125;function bar(a, b, c=3) &#123; c = 10; sidEffecting(arguments); return a + b + c;&#125;bar(1,1,1); // 12 1.20、123var a = 111111111111111110000,b = 1111;a + b; 解析： 当数值超过JS能正确计算且不失精度的最大整数时，会产生缺少精度问题。导致结果不太可预料。 基本上，超过16位数的整数都有这个问题了。很多时候，超过16位之后的数字会被补0。如下： 1234567// 一共20个2，超过16位之后的，将会为0。22222222222222222222 // 2222222222222222000098765432109876543210 // 98765432109876540000//当从1开始时，超过17位才为0。12345678901234567890 // 12345678901234567000 答案： 111111111111111110000"},{"title":"JavaScript的深拷贝的实现","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/JS札记/JavaScript的深拷贝的实现/","text":"JavaScript的数据类型简单数据类型 string number boolean function null undefined 复杂数据类型 String Number Boolean Function Date Array RegExp Object 各种类型的深复制方式：先来看看简单类型的复制方式： //string var s1 = &apos;abc&apos;; var s2 = s1; s2 = &apos;ccc&apos;; console.log(s1); //number var n1 = 12.1; var n2 = n1; n2 = 7410; console.log(n1); //boolean var b1 = true; var b2 = b1; b2 = false; console.log(b1); //null var nu1 = null; var nu2 = nu1; nu2 = &apos;abc&apos;; console.log(nu1); //undefined var u1 = undefined; var u2 = u1; u2 = &apos;abc&apos;; console.log(u1); 从以上的代码可以看出，简单类型，只需要直接赋值就是深复制了。但是也有一个例外，那就是function。 接着来看看String、Number、Boolean、Date的深复制： //String var s1 = new String(&apos;s1&apos;); var s2 = new String(s1); console.log(s2); //Number var n1 = new Number(&apos;1&apos;); var n2 = new Number(n1); console.log(n2); //Boolean var b1 = new Boolean(1); var b2 = new Boolean(b1); console.log(b2); //Date var d1 = new Date(); var d2 = new Date(d1); console.log(d2); 除以上的做法之外，还需要对实例属性进行拷贝。那么剩下的Function、function、RegExp和Array还有Object又该怎么拷贝呢？这几个比较特殊，我们一个一个来： 对于Function和function的深拷贝，我们可以按照如下的方式来做： var f1 = new Function(&apos;a&apos;, &apos;console.log(&quot;f1&quot; + a);&apos;); var f2 = function(b){console.log(&apos;f2&apos; + b);}; //通过toString获取源代码(有浏览器兼容问题) var code = f1.toString(); //利用eval进行复制 var f1_copy = (function(functionCode){ eval(&apos;var f = &apos; + functionCode); return f; })(code); f1_copy(&apos;abc&apos;); //当然f2也可以用同样的方式来复制。 接着，我们来看下RegExp，可以同样同时eval来执行拷贝，也可以使用如下方式： var reg1 = /abc/g; var reg2 = new RegExp(&apos;abc&apos;, &apos;gmi&apos;); var reg1_copy = (function(reg){ var pattern = reg.valueOf(); var flags = (pattern.global ? &apos;g&apos; : &apos;&apos;) + (pattern.ignorecase ? &apos;i&apos; : &apos;&apos;) + (pattern.multiline ? &apos;m&apos; : &apos;&apos;); return new RegExp(pattern.source, flags); })(reg1); 最后，我们来说一说Array的复制，有的人可以说，直接用slice复制一份出来就是了，那我们来看看，是否真的达到效果的呢？ var o = {name: &apos;Jay&apos;}; var arr1 = [o, &apos;22&apos;, 1]; var arr2 = arr1.slice(0); arr2[0].name = &apos;Arr2&apos;; console.log(arr1[0].name); 很简短的代码，直接就把slice抛弃了，slice只能保证Array是新的，并不意味着内部的元素是深拷贝的，那么如何做呢？就是遍历元素，对每个元素进行深拷贝了。代码如下： var o = {name: &apos;Jay&apos;}; var arr1 = [o, &apos;22&apos;, 1]; var arr2 = []; for(var i = 0, len = arr1.length; i &lt; len; i++){ //注意，deepClone还未实现 arr2.push(deepClone(arr1[i])); } 以上对针对不同的类型，特殊的代码，那么如何来拷贝实例属性呢？代码如下： var o = {p1: &apos;1&apos;, p2: 2, p3: function(){}}; var copy = {}; for(var p in o){ //注意deepClone还未实现 copy[p] = deepClone(o[p]); } 注意：针对复杂类型，还需要同时copy.constructor = source.constructor来保证构造函数一致。 最终的深复制代码通过以上的分析与代码示例，那么我们最终的代码又是怎样的呢？详细代码如下： //自调用函数，防御性编程 ; (function (window) { &apos;use strict&apos;; function getCustomType(obj) { var type = typeof obj, resultType = &apos;object&apos;; //简单类型 if (type !== &apos;object&apos; || obj === null) { resultType = &apos;simple&apos;; } else if (obj instanceof String || obj instanceof Number || obj instanceof Boolean || obj instanceof Date) { resultType = &apos;complex&apos;; } else if (obj instanceof Function) { resultType = &apos;function&apos;; } else if (obj instanceof RegExp) { resultType = &apos;regexp&apos;; } else if (obj instanceof Array) { resultType = &apos;array&apos;; } return resultType; } function cloneProperties(dest, source) { dest.constructor = source.constructor; for (var p in source) { dest[p] = deepClone(source[p]); } return dest; } function cloneSimple(obj) { return obj; } function cloneComplex(obj) { var result = new obj.constructor(obj); return cloneProperties(result); } function cloneFunction(obj) { var funCopy = (function (f) { eval(&apos;var abcdefg_$$$$ = &apos; + obj.toString()); return abcdefg_$$$$; })(obj); return cloneProperties(funCopy); } function cloneRegExp(obj) { var pattern = obj.valueOf(); var flags = (pattern.global ? &apos;g&apos; : &apos;&apos;) + (pattern.ignorecase ? &apos;i&apos; : &apos;&apos;) + (pattern.multiline ? &apos;m&apos; : &apos;&apos;); var reg = new RegExp(pattern.source, flags); return cloneProperties(reg); } function cloneArray(obj) { var resultArr = []; for (var i = 0, len = obj.length; i &lt; len; i++) { resultArr.push(deepClone(obj[i])); } for (var p in obj) { if (typeof p === &apos;number&apos; &amp;&amp; p &lt; len) { continue; } resultArr[p] = deepClone(obj[p]); } return resultArr; } function cloneObject(obj) { var result = {}; result.constructor = obj.constructor; for (var p in obj) { result[p] = deepClone(obj[p]); } return result; } function deepClone(obj) { var f = undefined; switch (getCustomType(obj)) { case &apos;simple&apos;: f = cloneSimple; break; case &apos;complex&apos;: f = cloneComplex; break; case &apos;function&apos;: f = cloneFunction; break; case &apos;regexp&apos;: f = cloneRegExp; break; case &apos;array&apos;: f = cloneArray; break; case &apos;object&apos;: f = cloneObject; break; } return f.call(undefined, obj); } //挂载到window对象上 window.deepClone = deepClone; })(window);"},{"title":"Go Go","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/Other/Go Go/","text":"题记 学习是进步的源泉 在这个云计算、多核盛行的时代，学习一门与之相配合的语言也就无可厚非了。那么对多核与并行计算原生支持的Go就是我的选择了… 关于GO的好坏，我不会去深究，在每个人眼中，这都是主观的。喜欢就会觉得好，不喜欢好也是坏。当然，它本身的优势与劣势是值得我们关注了，这决定了它的适用性。 工欲善其事必先利其器，本人学习一门语言之前，喜欢先寻找趁手的兵器。搜索之，继而找到了LiteIDE。由于偏爱集成开发环境，那么Sublime也就不是我的首选了。 以上全是废话，下面开始搭建开发环境。 1、准备工作 PC + Windows操作系统（我承认我只会玩Windows…） 你得下载Go语言：https://golang.org/ BTW：我下载的文件名是：go1.4.1.windows-amd64.msi LiteIDE：https://github.com/visualfc/liteide 2、搭建环境首先，你需要安装Go语言。什么？你不会？双击msi(或者exe)，Next到手软就可以了。当然，最后应该是Finish。经过这个步骤，go就安装上了，什么环境变量啥的都给你配置好了。当然，安装成功不成功不是你说了算，那么打开cmd，输入一个go试试？如果报错，那么狠抱歉，请重试该步骤，或者检查环境变量。如果提示Go is a tool for managing Go source code ,那么恭喜你，安装已成功！ 接下面，安装LiteIDE，这货的下载地址在http://sourceforge.net/projects/liteide/files，如果你爱折腾，那么直接下载源码编译也是OK的，请参考https://github.com/visualfc/liteide/blob/master/liteidex/deploy/welcome/en/install.md。此处熊出没！liteide下载下来可不是exe或者msi文件哦。我下载的文件名是：liteidex27-1.windows.7z。既然这样，那么解压缩，找个地儿一扔就搞定，是不是更简单？ 3、永远的经典：Hello World既然到了这里，想必以上两个小玩意已经安装好了。那么就应该开始写代码。据说程序员爱代码不爱妹子，这是真的么？ 找到liteIDE的安装目录，进行/bin目录，双击“liteide.exe”（PS：一看到这个丑丑的太极图标，我就在想，这货应该是一个国人开发的吧，呵呵，果真是！）。和一般IDE无异，File-&gt;New-&gt;Go1 Command Project(Not Use GOPATH)，当然其他也是可以选的，惊喜在等着你。输入必要的信息，那么一个项目就创建好了。 打开main.go文件，输入代码（这段代码我是借鉴的，肯定不是copy的）： // demo1 project main.go package main import ( &quot;fmt&quot; ) func main() { fmt.Println(&quot;Hello World!&quot;) } 然后点击工具栏上的FR(File Run),这坑爹的按钮，简直反人类。。我点了N次Go按钮之后，才发现这货才是运行。。在右下方区域就能看到输出了。。Hello World~ 后记： 至此，一个简单的Go开发环境已经搭建好了。 或许你还有疑问 如果生成可执行文件呢？ 可以利用LiteIDE的Build按钮，或者是控制台命令 go build 如果我是64位系统，如何生成32位可执行程序呢？ 我也不知道，只能给你关键字“交叉编译” 更多，就留给你慢慢发掘吧。Over！"},{"title":"NPM使用详解（上）","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/Other/NPM使用详解（上）/","text":"1、NPM是什么？NPM是JavaScript的包管理工具，在安装NodeJS（什么？你不知道node？来，我们合计合计：https://nodejs.org/）的时候,会自动安装上npm。 要查看安装的npm版本，只需要打开cmd控制台，输入npm -v NPM使得JavaScript开发者分享和重用代码非常容易，同时也让你能否非常方便的更新你分享的代码。 NPM能够自己升级自己，使用命令如下： npm install npm -g 2、NPM的使用以下代码示例中：&lt;&gt;表示必选参数，[]表示可选参数 #最常用命令2.1、 init：用于初始化项目/* * npm init [-f|--force|-y|--yes] */ //在文件夹中打开cmd，然后输入npm init，打开项目初始化向导 npm init //如果文件夹名称满足npm的module name, //那么使用如下方式，可以直接生成一个默认的package.json //如果文件夹名称不满足要求，那么会出错 npm init -f npm init --force npm init --force=true npm init -y npm init --yes npm init --yes=true 2.2、install：用于安装模块/* * npm install (with no args in a package dir) * npm install &lt;tarball file&gt; * npm install &lt;tarball url&gt; * npm install &lt;folder&gt; * npm install [@&lt;scope&gt;/]&lt;name&gt; [--save|--save-dev|--save-optional] [--save-exact] * npm install [@&lt;scope&gt;/]&lt;name&gt;@&lt;tag&gt; * npm install [@&lt;scope&gt;/]&lt;name&gt;@&lt;version&gt; * npm install [@&lt;scope&gt;/]&lt;name&gt;@&lt;version range&gt; * npm i (with any of the previous argument usage) */ //直接使用npm install 或者是npm i，表示根据package.json，安装所有依赖 npm install npm i //如果加上--production参数，那么只会安装dependencies的模块， //而不会安装devDependencies的内模块 npm install --production npm i --production //使用全局上下文来初始化 npm install -g npm i -g //安装指定模块 npm install &lt;packageName&gt; npm install &lt;packageName&gt; -g //全局安装 npm install &lt;packageName&gt;@&lt;version&gt; //指定要安装的模块版本 npm install &lt;packageName&gt;@&lt;version_start-version_end&gt; //指定要安装的模块版本 npm install &lt;packageName&gt; --registry=&lt;url&gt; //指定零食的仓库地址 npm install &lt;packageName&gt; --msvs_version=&lt;vs_version&gt; //指定编译使用的VS版本 npm install &lt;packageName&gt; --save // 安装模块并修改package.json的dependencies npm install &lt;packageName&gt; --save-dev //安装模块并修改package.json的devDependencies npm install &lt;tarball url&gt; //从指定的压缩包地址安装，示例如下： npm install https://github.com/indexzero/forever/tarball/v0.5.6 npm install &lt;tarball file&gt; //从指定的压缩包安装，如下(注意压缩包格式)： npm install del-1.2.0.tar.gz //使用.tgz和.tar.gz格式 npm install @&lt;scope&gt;/&lt;packageName&gt; //安装私有包 2.3、uninstall：用于卸载模块/* * npm uninstall [@&lt;scope&gt;/]&lt;package&gt; [--save|--save-dev|--save-optional] */ //直接卸载模块，加上-g参数，表示卸载全局的模块 npm uninstall &lt;packageName&gt; npm uninstall &lt;packageName&gt; -g //卸载时同时修改package.json文件 npm uninstall &lt;packageName&gt; --save-dev npm uninstall &lt;packageName&gt; --save 2.4、update：用于更新模块/* * npm update [-g] [&lt;name&gt; [&lt;name&gt; ...]] */ //更新一个或多个模块，加上-g参数，表示更新全局的模块 npm update &lt;packageName&gt; [packageName2...] npm update &lt;packageName&gt; [packageName2...] -g //更新时同时修改package.json文件 npm update &lt;packageName&gt; [packageName2...] --save-dev npm update &lt;packageName&gt; [packageName2...] --save 2.5、config：用于设置npm参数//设置指定参数 npm config set &lt;key&gt; &lt;value&gt; [--global] npm set &lt;key&gt; &lt;value&gt; [--global] //可以省略config //获取现有参数值 npm config get &lt;key&gt; npm get &lt;key&gt; //可以省略config //删除指定参数，此时参数值会变为默认值 npm config delete &lt;key&gt; //查看npm信息；注意：此命令不是查看所有参数配置 npm config list //编辑全量的npm配置文件（.npmrc） npm config edit //可以将config使用c代替，执行以上所有命令 npm c [set|get|delete|list] 2.6、cache：管理包缓存//将指定的包加入npm缓存 npm cache add &lt;tarball file&gt; npm cache add &lt;folder&gt; npm cache add &lt;tarball url&gt; npm cache add &lt;name&gt;@&lt;version&gt; //查看现有的npm包缓存，如果加上path参数，则查看该路径下的文件 npm cache ls [&lt;path&gt;] eg: npm cache ls gulp //清空缓存。如果加上path，则清理指定路径下的包缓存 npm cache clean [&lt;path&gt;] eg: npm cache clean gulp"},{"title":"01_开始GO","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/GoLang学习笔记/01_开始GO/","text":"0、前言Go是啥？看这里。简而言之，就是一门系统级的编程语言。 为嘛要学/用它？ 追个潮流，体验下不同风格的语言设计思想 跨平台部署，单文件部署 强大的功能（系统级） 对分布式的友好支持 上手有啥问题？ 不友好的语法（也有一部分人觉得语法很优雅，对我来说，这语法可算不上友好） 和大多数语言不一样的设计风格（需要慢慢消化） 没有趁手的IDE（LiteIDE, Sublime Text, VsCode这几个可以自己优化得比较好用） 1、开干虽然比较恶心语法，但是其他优秀的点，也是比较吸引人的，再加上项目需要，那就开干。 因为有其他前/后端语言的经验，就跳过常规学习过程，直接上手做项目。 注意：虽然跳过了不少步骤，但是语法还是要学习的，书还是要看的，先来一本《Go语言编程》 1.1、创建项目基架Go 是一个有很多规范的语法，就连创建目录结构也有一定的约束。之前的版本略过，我本地安装的是 go1.7.3 版本，通过 go version 可查看。 接下来就为该版本，创建一个相对较为标准的项目结构。"},{"title":"开发者讨厌你API的十个原因","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/Other/开发者讨厌你API的十个原因/","text":"##1、文档的吸引力太弱## ###解决之道### 采用大图片：示例站点 文档清晰度：示例站点 文档易于查找：示例站点 生动的文档： Swagger I/O Docs 采用RAML(RESTful API 模型语言) RAML官网 ##2、您的沟通技能需要工作（你不能保证开发者始终被通知到） ###解决之道### 使用变更日志：http://developer.github.com/changes/ 使用路线图：https://developers.facebook.com/roadmap/ 采用发布日志：http://techblog.constantcontact.com/api/release-updates 使用博客（Blog）：http://aws.typepad.com/ 使用论坛（Forum）：http://stackoverflow.com/questions/tagged/soundcloud 邮件通知 ##3、你不能使API使用简单## ###解决之道### 说明你是做什么的：https://www.twilio.com/voice/api 支持快速注册：https://manage.stripe.com/register 使用step1-step2-step3说明使用步骤：示例站点 提供快速入门手册：https://www.twilio.com/docs/quickstart 提供免费版或者免费试用版：https://parse.com/plans 提供丰富的SDK（支持多种开发语言） 使用GitHub ：https://github.com/OneNoteDev ##4、没有提供法律申明## ###解决之道### 要明确权利与义务：http://500px.com/terms 编写使用协议：https://www.etsy.com/developers/terms-of-use 申明越短越好：http://googledevelopers.blogspot.com 申明要想长远：https://developers.google.com/youtube/terms 分享你的财富：http://slideshare.net/jmusser ##5、你的API不可靠（慢、错误、不可靠）##API会被停运(Outage)、Bug、速率(Rate limit)、变更(包含有计划的变更和未被文档跟踪的变更)、ToS违规、Provider biz change、网络等原因影响。 不要让API返回未知的错误信息，让用户迷惑。 ###解决之道### 使用状态页：http://status.aws.amazon.com/ 监控API：http://www.apiscience.com 不要隐藏API的变化，如停运：http://blog.akismet.com ##6、没有提供能帮助我调用成功的工具## ###解决之道### 提供开发者仪表板：https://manage.stripe.com/test/dashboard 提供 Debug/Log 等日志：示例站点 提供用于测试的沙盒环境：https://www.twilio.com/user/account 提供Playground：https://developers.google.com/oauthplayground 提供测试控制台：https://apigee.com/providers ##7、只管销售，但不提供售后服务## ###解决之道### Evangelists：http://sendgrid.com/developers Events：https://www.twilio.com/conference Hackathons PS：不知道如何翻译，so总结一点，就是提供售后支持。 ##8、API太复杂了（你使用你自己定制的授权、协议、格式）## ###解决之道### 使用REST（当前最流行的风格） 使用JSON格式（XML也还好） 保持务实：http://apigee.com/about/content/web-api-design ##9、你的TTFHW（Time to (your) First Hello World）太长## ###解决之道### 极好的开发者体验：http://developerexperience.org 在所有问题修正前，先说“Sorry” ##10、你还没有从最好的学习到的## 学习榜样的做法（Twilio,Stripe,GitHub.SendGrid） 保持进步 记住一句话：API是旅程，不是目的地"},{"title":"浅析12306前端优化点","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/Other/浅析12306前端优化点/","text":"关于12306中国铁路客户服务中心(12306.cn)，相信大家都不陌生。作为一个超大型的类电商网站，具体业务不予置评，但从前端设计来看，却有诸多的不足。 12306订票首页分析12306首页(https://kyfw.12306.cn/otn/)请求达到32个，累计文件大小近800k。 其中有一半是图片资源，大小达到444kb。 另外有6个css文件请求，特别的是有2次css请求完全指向同一个css文件。 还有8个js请求 这就是首页初次打开所需要的内容，当然还有两个html页面，就不计算了。可以看到，打开整个页面文件大小达到800k，和taobao，jd之类的比起来，这个大小是很小的，但是为什么给用户的体验就是卡顿、加载中、加载中呢？ 接下来，就从前端的角度来看下，有没有可以优化的地方呢？ 优化1、使用浏览器缓存在页面加载中，12306请求了如此多的资源，很多资源看起来，根本就是不太容易变化的，应在HTTP标头中设置有效期，尽可能多的使用浏览器缓存。 优化2、图片优化数据传输时间，在访问网站的过程中，是一个耗时比较大的过程，其中又以图片传输为最，如果网站上有较多的图片，那么就要想办法减少体积，延迟加载等等。在12306的页面上，logo（https://kyfw.12306.cn/otn/resources/images/logo.png ），icon（https://kyfw.12306.cn/otn/resources/images/logo.png ）等等图片都是可以优化的。 优化3、图片组合为CSS贴图浏览器一般都有并发连接数限制，也就是同时请求的资源数量是有效的，前端优化点之一就是减少请求数量，那么12306中的诸多小图片完全可以合并到一个大图之中，采用贴图定位的方式，降低请求数量。 优化4、暂缓JS解析由于JS是阻塞加载的，一般来说，把js放在head中会影响页面的渲染速度，很多时候，我们都推荐把js放在body结束标记之前。但12306偏偏没有这么做，把大把的js放在head中。 优化5、使用css而不是图片控制背景这个似乎是大家都知道的常识，就算为了兼容老版本的浏览器，也可以考虑做优雅降级。但12306偏偏就大量使用背景图。 优化6、CSS合并同样为了减少请求数，应该尽量将CSS压缩合并。分析12306的站点css，发现部分合并了，部分没有，而且有些css连压缩都没做，很难想象是怎么打算的。另外，外部控件的样式（不会变的样式）完全可以打包放到cdn上。 优化7、JS合并JS同上，该打包就打包，不要搞一堆js出来，加载还慢。。 总结抢票还是每年的一个老大难的问题。12306，你可以推说你的核心逻辑复杂，这个我接受。但你完全可以把前端的一些基本优化点做到吧。就算我买不到票，至少我抢票的时候心情不至于太差。。 以上，抢票之余作为一个伪前端的发泄。"},{"title":"程序集强签名","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/Other/程序集强签名/","text":"1、特点1.1、强签名的程序集可以注册到GAC（全局应用程序集缓存）,不同的应用程序可以共享同一个dll。 1.2、强签名的库（应用程序）只能引用强签名的库。非强签名的库（应用程序）没有限制，既可以引用强签名的库，也可以引用非强签名的库。（实际测试，强签名的应用只引用非强签名的程序集但不使用是可以的，只要使用了引入库的东西，那就会报：引用的程序集没有强签名） 1.3、强签名无法保护源代码，但能防止dll被第三方篡改。 1.4、能防止dll冲突。 2、方法–如果有源代码 项目 -&gt; 右键 -&gt; 属性 -&gt; 签名： 勾选 Sign the assembly（签名程序集） 填写 key file name，如果勾选了密码保护key file，那么就输入密码。点击OK就创建好了签名文件。 将属性保存，然后再次编译，程序集就是强签名程序集了。 –如果没有源代码 1、首先创建一个签名key file，可以通过有源代码的方式，创建key file备用；也可以通过VS 控制台执行sn.exe -k D:\\sn.snk 生成key。 2、将无源代码的dll，通过 ILDASM.exe MagicOrm.dll /OUTPUT=D:\\MagicOrm.il进行反汇编 注意：如果dll有资源文件，同时会生成MagicOrm.res文件 3、带上签名文件重新汇编为dll，如果有资源文件生成，也需要带上，命令：ILASM.exe MagicOrm.il /dll /output=D:\\MagicOrm.dll /Key=sn.snk /Resource=MagicOrm.res Over"},{"title":"NPM使用详解（下）","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/Other/NPM使用详解（下）/","text":"在浏览本文之前，建议您先浏览《NPM使用详解（上）》 在上一文中，罗列出了最常用的NPM命令，那么本文将继续分解剩下的NPM命令 1、access2、adduser//用于启动在指定的git仓库添加用户的向导 npm adduser [--registry=url] [--scope=@orgname] [--always-auth] //eg: npm adduser --registry=http://registry.npmjs.org 3、bin//打印出npm执行安装的文件夹 npm bin 4、bugs//查看某个包的issue列表 npm bugs &lt;pkgname&gt; //eg:（将会用浏览器打开https://github.com/sindresorhus/del/issues） npm bugs del // 可以直接在一个包的文件夹中执行无参数的命令，将自动打开该包的issue列表 //eg:(在del文件夹下执行cmd) npm bugs 5、build6、bundle(已过期)7、completion8、dedupe// npm dedupe [package names...] //可简化为如下调用 npm ddp [package names...] 9、deprecate//为指定版本的包添加过期警告 npm deprecate &lt;name&gt;[@&lt;version&gt;] &lt;message&gt; // eg: npm deprecate my-thing@&quot;&lt; 0.2.3&quot; &quot;critical bug fixed in v0.2.3&quot; 10、dist-tagnpm dist-tag add &lt;pkg&gt;@&lt;version&gt; [&lt;tag&gt;] npm dist-tag rm &lt;pkg&gt; &lt;tag&gt; npm dist-tag ls [&lt;pkg&gt;] 11、docs//打开包的文档页面 npm docs [&lt;pkgname&gt; [&lt;pkgname&gt; ...]] npm docs (with no args in a package dir) // 打开包的首页readme npm home [&lt;pkgname&gt; [&lt;pkgname&gt; ...]] npm home (with no args in a package dir) 12、editnpm edit &lt;name&gt;[@&lt;version&gt;] 13、explorenpm explore &lt;name&gt; [ -- &lt;cmd&gt;] 14、help//打开本地npm的帮助文件 npm help &lt;topic&gt; npm help some search terms //eg:(打开config的本地帮助) npm help config 15、help-search//从npm的markdown文档中查询所有的term，并展示 npm help-search some search terms 16、linknpm link (in package folder) npm link [@&lt;scope&gt;/]&lt;pkgname&gt; npm ln (with any of the previous argument usage) 17、logout//从指定的仓库登出 npm logout [--registry=url] [--scope=@orgname] 18、ls//列举当前文件夹下的所有包 npm list [[@&lt;scope&gt;/]&lt;pkg&gt; ...] npm ls [[@&lt;scope&gt;/]&lt;pkg&gt; ...] npm la [[@&lt;scope&gt;/]&lt;pkg&gt; ...] npm ll [[@&lt;scope&gt;/]&lt;pkg&gt; ...] 19、npmnpm &lt;command&gt; [args] 20、outdated(☆☆☆☆☆)//检查当前文件夹中的包版本（当前，需要，最新） npm outdated [&lt;name&gt; [&lt;name&gt; ...]] 21、owner//管理包的拥有者 npm owner ls &lt;package name&gt; npm owner add &lt;user&gt; &lt;package name&gt; npm owner rm &lt;user&gt; &lt;package name&gt; 22、pack(☆☆☆☆☆)//压缩包文件夹 npm pack [&lt;pkg&gt; [&lt;pkg&gt; ...]] //eg：在del目录中直接执行 npm pack //或者在项目目录中，执行 npm pack del 23、prefix//打印本地前缀到控制台，如果-g，则打印全局的前缀 24、prune(☆☆☆☆☆)//删除多余的包(如果指定包名，则删除指定的包) npm prune [&lt;name&gt; [&lt;name ...]] npm prune [&lt;name&gt; [&lt;name ...]] [--production] 25、publish//发布包 npm publish &lt;tarball&gt; [--tag &lt;tag&gt;] [--access &lt;public|restricted&gt;] npm publish &lt;folder&gt; [--tag &lt;tag&gt;] [--access &lt;public|restricted&gt;] 26、rebuild//重新编译包 npm rebuild [&lt;name&gt; [&lt;name&gt; ...]] npm rb [&lt;name&gt; [&lt;name&gt; ...]] 27、repo//在浏览器中打开包的仓库地址 npm repo &lt;pkgname&gt; npm repo (with no args in a package dir) 28、restart//重新启动包 npm restart [-- &lt;args&gt;] 29、rm//移除包 npm rm &lt;name&gt; npm r &lt;name&gt; npm uninstall &lt;name&gt; npm un &lt;name&gt; 30、root//打印node_modules文件夹到控制台 npm root 31、run-script//运行任意的包脚本 npm run-script [command] [-- &lt;args&gt;] npm run [command] [-- &lt;args&gt;] 32、search33、shrinkwrap34、star//给指定的包加star npm star &lt;pkgname&gt; [&lt;pkg&gt;, ...] npm unstar &lt;pkgname&gt; [&lt;pkg&gt;, ...] 35、stars//查看指定用户的stars npm stars npm stars [username] 36、start37、stop38、tag39、test40、unpublish41、versionnpm version [&lt;newversion&gt; | major | minor | patch | premajor | preminor | prepatch | prerelease] //查看项目相关信息 npm version npm version major 42、view43、whoami"},{"title":"OWIN 中文版","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/OWIN/OWIN 中文版/","text":"OWIN：Open Web Server Interface for .NETVersion：1.0 原文地址：http://owin.org/html/spec/owin-1.0.html 0、Table Intro Overview Definitions Request Execution 环境 协议头 协议体 响应体 请求生命周期 应用启动 URI Re URI 结构 主机名 路径 URI 预编码 错误处理 应用错误 服务器错误 版本"},{"title":"02-PHP基础语法（上）","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/PHP学习之路/02-PHP基础语法（上）/","text":"0、导言学习一门语言，首先要了解它能做什么？其次，就应该去学习应该如何做。那这个的前提就是语法的学习。 语法决定了代码应该如何写（仅仅是可运行），接着我们就来看看PHP它的语法吧。 注意：本文测试代码全部运行在PHP7上。 1、基础中的基础1.1、 PHP文件以 .php 结尾，对于渲染HTML的PHP文件，其本质还是一个HTML页面，只要可以嵌入PHP逻辑代码。 1.2、 在前端 .php 文件中，要嵌入PHP代码，需要使用 &lt;?php 你的代码 ?&gt;。 1.3、PHP的每个语句以分号结束（部分场景省略分号也不报错）。 1.4、 PHP中，有两种注释方式。 12345// 我是单行注释/* 我是多行注释*/ 1.5、PHP的输出，也有两种方式 一是 echo 12echo &apos;abc&apos;, &apos;aaaa&apos;;echo(&apos;abc&apos;, &apos;aaaa&apos;); 二是 print 123print &apos;abc&apos;;print(&apos;abc&apos;);$result = print(&apos;abc&apos;); 注意：echo、print即是语言结构，也算是函数，所以可以不加括号调用，也可加括号调用。 注意2：echo 输出没有返回值，print 有返回值1。 注意3：echo 输出比 print 快！ 1.6、数据的格式化输出，在输入时，我们可以用更简单的方法拼接字符串 12345$name = 'Jay';echo 'My name is &#123;$name&#125;';echo \"My name is &#123;$name&#125;\";print 'My name is &#123;$name&#125;';print \"My name is &#123;$name&#125;\"; 会输出： 1234My name is &#123;$name&#125;My name is JayMy name is &#123;$name&#125;My name is Jay ！！！注意：只有当使用双引号（””）包裹字符串的时候，才可以使用简易字符串拼接。 2、数据类型PHP有个和大多数语言雷同的类型系统，系统提供了如下类型： String（字符串） Integer（整型） Float（浮点型） Boolean（布尔型） Array（数组） Object（对象） NULL（空值）。 PHP中的变量命名以$为标记，之后跟变量名称（变量名字只能包含数字字母和下划线），变量区分大小写。 PHP是弱类型语言，所以同一个变量，可以存储多种类型数据。 123456789101112131415$a = '我是字符串'; //定义字符串（单引号，双引号皆可）echo $a, '&lt;br&gt;';$a = 10; // 我的整数echo $a, '&lt;br&gt;';$a = 0x10; // 定义16进制整数echo $a, '&lt;br&gt;';$a = 010; // 定义8进制整数echo $a, '&lt;br&gt;';$a = 0.1; // 浮点数echo $a, '&lt;br&gt;';$a = 8E-5; // 指数形式定义浮点数echo $a, '&lt;br&gt;';$a = true; // Bool类型，只有true,false，注意不区分大小写，写成True，TrUe都没问题。echo $a, '&lt;br&gt;';$a = NuLL; // NULL类型只有一个null值，同样不区分大小写。 输出如下： 12345678我是字符串&lt;br&gt;10&lt;br&gt;16&lt;br&gt;8&lt;br&gt;0.1&lt;br&gt;8.0E-5&lt;br&gt;1&lt;br&gt; // 注意，Bool类型，true会输出1，false会输出0&lt;br&gt; // NULL类型，无任何输出 以上演示了PHP中的简单类型，还剩下Array和Object两个复杂类型。 Array 类型 数组又分为以下几种： 简单数组（数值数组，下标为数字） 123456$arr = ['item1', 'item2'];// 等价于$arr = array('item1', 'item2');// 仅能通过下标访问元素echo $arr[0]; 关联数组 123456$arr = ['key1' =&gt; 'value1', 'key2' =&gt; 'value2'];//等价于$arr = array('key1' =&gt; 'value1', 'key2' =&gt; 'value2');// 仅能通过key访问echo $arr['key1']; 多维数组（数组包含数组） 123456$arr = ['key1' =&gt; ['a', 'b'], 'key2' =&gt; ['c', 'd']];//等价于$arr = array('key1' =&gt; array('a', 'b'), 'key2' =&gt; array('c', 'd'));// 根据数组类型，通过key或者是下标访问echo $arr['key1'][0]; 数组Demo合集： 1234567891011121314151617181920212223242526$arr = ['item1', 'item2'];print_r($arr);echo '&lt;br&gt;'; $arr = array('item1', 'item2');print_r($arr);echo '&lt;br&gt;'; //仅能通过下标访问echo '$arr第一个元素是：', $arr[0], '&lt;br&gt;&lt;br&gt;';$arr = ['key1' =&gt; 'value1', 'key2' =&gt; 'value2'];print_r($arr);echo '&lt;br&gt;';$arr = array('key1' =&gt; 'value1', 'key2' =&gt; 'value2');print_r($arr);echo '&lt;br&gt;';// 通过key访问echo '$arr的key1值是：', $arr['key1'], 'key2值是：', $arr['key2'], '&lt;br&gt;&lt;br&gt;';$arr = ['key1' =&gt; ['a', 'b'], 'key2' =&gt; ['c', 'd']];print_r($arr);echo '&lt;br&gt;';$arr = array('key1' =&gt; array('a', 'b'), 'key2' =&gt; array('c', 'd'));print_r($arr);echo '&lt;br&gt;';// 根据数组类型，通过key或者是下标访问echo $arr['key1'][0], $arr['key2'][1]; Object 类型 PHP中的Object类型，和编译性语言比较类似，是通过new class得到的。 123456789101112class User&#123; var $userName; function setName($name)&#123; $this-&gt;userName = $name; &#125; function getName()&#123; return $this-&gt;userName; &#125;&#125;$user = new User();$user-&gt;setName('Jay');echo $user-&gt;getName(); 以上代码会输出：Jay 4、常量与变量4.1、常量PHP中的常量必须使用 define 函数来定义。语法如下： 1234define(常量名称:string, 常量值, 是否区分大小写:bool-默认为false);//定义一个常量define('PI', 3.1415926, true); 常量值被定义后，在脚本的其他任何地方都不能被改变，且常量是全局可用的。 4.2、变量PHP的变量有如下几类： local - 局部变量 global - 全局变量 static - 静态变量 parameter - 参数变量 4.2.1、局部变量定义在函数中的变量，被称之为局部变量，只在当前函数有效。 123456function fun()&#123; $funName = 'fun1'; echo $funName;&#125;fun();echo $funName; // 出现警告：Undefined variable: funName 4.2.2、全局变量定义在函数外部的变量则是全局变量，如果要在函数内部使用，则需要使用global关键字。示例如下： 123456789$appName = 'test';function fun1()&#123; // 需要指定，当访问$appName时，是访问全局的$appName，否则会出现一个警告，未定义的变量。 global $appName; echo $appName;&#125;fun1(); 4.2.3、静态变量局部变量，一般是执行完函数，即被释放。如果想保留该变量，那么就可以使用静态变量。 123456789function funs()&#123; $id = 1; static $static_id = 1; echo '$id = ', $id, ', $static_id=', $static_id, '&lt;br&gt;'; $id++; $static_id++;&#125;funs();funs(); 输出结果为： 12$id = 1, $static_id=1$id = 1, $static_id=2 我们可以看到 $static_id 并没有被释放，一直有效。 注意：静态变量本质上还是局部变量。 4.2.4 参数变量这个没啥好说的，函数参数中的变量，类似于局部变量。 4.2.5 超级全局变量什么是超级全局变量呢？ 不需要特别定义，可直接在全局任何地方使用,是PHP预定义的全局变量。它们是： $GLOBALS $_SERVER $_REQUEST $_POST $_GET $_FILES $_ENV $_COOKIE $_SESSION 5、其他完整Demo地址：PHP语法演示Demo01 更多内容，请看下回分解。"},{"title":"01_记一次MongoDB裸奔","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/MongoDB入门基础/01_记一次MongoDB裸奔/","text":"导言大意失荆州，裸奔的 MongoDB 被黑了。虽然并不是什么非常重要的数据，但也给自己敲响的一个警钟。虽然我们平时不容易接触到数据安全，但我们在开发，部署项目的时候，一定要养成良好的安全意识。 根据木桶原理，整个系统的安全性，取决于整个系统最薄弱的环节。所以，我们要尽可能多的考虑更多组成部分的安全性。 事件发现本月初，发生了大家所熟知的 MondoDB赎金事件。当时本人也保持了一定的关注，并去 https://www.shodan.io/ 溜达了一圈，顺便连了几个裸奔的MongoDB（当然，绝未做任何更改）。 直到昨天下午，发现我应用的管理员账户登录不上了。多次检查密码，发现还是无法解决，此时有点怀疑被黑了。由于应用有新建用户功能，新建一个和管理员账户同名的账户，居然成功了。这个时候，我想多半是遭了，只等晚上回去确认了。 回到家，远程到服务器，一连接，果然遭了（可怜我那几十个代码片段 + 几个Gist），需要赎金0.1BTC。 原因分析此时可能就要问了，都知道了裸奔不安全，为嘛还不修复？ 我能说我懒么？心大么？ 因为当时我部署的版本的3.2，据说3.2默认没有开启外网访问。我心大到直接未经尝试就认为这是对的。 实际这句话也没错，Linux版本的 3.x 确实是默认绑定到 127.0.0.1 上的。可TM我是运行在 Windows 上的，由于安装的时候，默认没有创建配置文件，导致一运行就绑定到所有host上了。 当上，以上都是外因！根本原因还是自己疏忽大意，安全意识薄弱。 解决（重头再来）没有备份，直接无法恢复。 另外，0.1个BTC我是拿不出来的（我也不相信他会好心给你恢复），再加上数据也不是太重要，就直接把安全设置配置上，重头开始。 那现在是如何配置安全性的呢？ 以下操作，均在未开启授权访问时执行 首先是添加用户并设置角色： 12345678# 切换到admin库use admin# 创建Userdb.createUser(&#123;user: '&lt;name&gt;', pwd: '&lt;password&gt;', roles: [ &#123;role: 'readWrite', db: '&lt;dbname&gt;'&#125;, &#123;role: 'dbAdmin', db: '&lt;dbname&gt;'&#125;]&#125;) 接下来就是创建一个配置文件（2.6之后，配置文件是yaml格式），内容如下： 12345678systemLog: destination: file path: c:\\data\\log\\mongod.logstorage: dbPath: c:\\data\\dbnet: bindIp: 127.0.0.1 port: 27017 注意：配置文件中一定要设定 log path 和 db path 注意2：如果要限制外网访问，就可以配置 net -&gt; bindIp，另外也可以调整端口 此时如何运行呢？ 1mongod --config \"D:\\MongoDB\\mongod.conf\" --auth 带上 --auth 就是开启授权访问。 最后客户端访问也需要稍微修改下，只需要修改 mongoAddress 配置即可： 12345# MongoDB Connection String Formatmongodb://[username:password@]host1[:port1][,host2[:port2],...[,hostN[:portN]]][/[database][?options]]# 实例地址const mongoAddress = 'mongodb://admin:Pwd0603@127.0.0.1:27017/dojo' 就这么一点简单的步骤，就能实现 MongoDB 较高的安全性，可这却是非常容易忽略的点。希望大家引以为戒。总结 一定不能疏忽大意，安全意识要加强。 一定要结果实际验证，才能下结论。不能不清楚外置条件，人云亦云。 不要有我的应用小，就不会被黑这种想法。批量攻击，才不会放过你。 定期做好数据备份，被攻击是一回事，能否恢复又是另外一回事了。"},{"title":"那些不常见的JavaScript题目（下）","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/JS札记/那些不常见的JavaScript题目（下）/","text":"0、导言JavaScript超乎寻常的灵活性，让JavaScript可以有很多特殊的用法，让我们来领略一下它们的风采吧。 此为下篇，上篇请查阅：上篇 1、那些不常见（好玩）的题目（下） 1.21、1Number.MIN_VALUE &gt; 0 解析： 此题考察数字的最小值，它的最小值是大于0的浮点数。 答案： true 1.22、1[1 &lt; 2 &lt; 3, 3 &lt; 2 &lt; 1] 解析： 此题考察运算顺序。直接从左往右计算，即可。等价于： 123[true &lt; 3, false &lt; 1]=&gt;[1 &lt; 3, 0 &lt; 1] 答案： [true, true] 1.23、12 == [[[2]]] 解析： 此题考察类型转化，全部调用toString(),转换为了&#39;2&#39; 答案： true 1.24、1233.toString();3..toString();3...toString(); 解析： 此题考察.的结合性问题，对于到底属于数字还是函数调用呢，其实只能是数字。三个点是什么语法？ 注意：这也导致了整数字面量无法直接调用toString() 答案： error, &#39;3&#39;, error 1.25、12345(function()&#123; var x = y = 1;&#125;)();console.log(y);console.log(x); 解析： 此题考察作用域问题和var定义变量问题。当没有用var定义变量时，变量会成为全局变量。 答案： 1, error 1.26、123var a = /123/, b = /123/;a == ba === b 解析： 此题考察正则表达式比较，即使字面量相等，它们也不相等。 答案： false, false 1.27、1234567var a = [1, 2, 3], b = [1, 2, 3], c = [1, 2, 4];a == b;a === b;a &gt; c;a &lt; c; 解析： 此题同样考察对象比较。当比较相等时，引用不同，所以皆不等。当比较大小时，会按照数组元素，依次比较字典序。 答案： false, false, false, true 1.28、12var a = &#123;&#125;, b = Object.prototype;[a.prototype === b, Object.getPrototypeOf(a) === b] 解析： 此题比较有误导性，对于一个对象实例来说，获取原型的方法是：a.constructor.prototype 或者是 Object.getPrototypeOf(a)，对于 a.prototype，直接当成一个属性访问，由于未定义，所以会产生 undefined。 答案： false, true 1.29、123function f() &#123;&#125;var a = f.prototype, b = Object.getPrototypeOf(f);a === b 解析： 此题同样考察原型相关知识，前者是f的原型，后者是f的构造函数（Function）的原型。 答案： false 1.30、1234function foo() &#123; &#125;var oldName = foo.name;foo.name = \"bar\";[oldName, foo.name] 解析： 函数的名称为常量，但需要注意，赋值不会报错。 答案： [&#39;foo&#39;, &#39;foo&#39;] 1.31、1\"1 2 3\".replace(/\\d/g, parseInt) 解析： 此题考察 String.replace() 的回调函数，它的回调函数定义是 funcation(matchValue, group, valueIndex, sourceStr){}，依次为匹配到的值、正则分组，该值在字符串中的index，字符串本身。由于在该题中，正则没有分组，所以，调用了三次 parseInt 如下: 123parseInt('1', 0, '1 2 3');parseInt('2', 2, '1 2 3');parseInt('3', 4, '1 2 3'); 答案： &#39;1 NaN 3&#39; 1.32、123456function f() &#123;&#125;var parent = Object.getPrototypeOf(f);f.name // ?parent.name // ?typeof eval(f.name) // ?typeof eval(parent.name) // ? 解析： 通过 Object.getPrototypeOf() 获取原型，参数是实例，当f为实例的时候，获取实例f的原型就等于 Function.prototype，由于Function的原型还是一个function。所以 parent = Function.prototype 是一个没有名字的function。 因此:12f.name // fparent.name // '' 使用 eval，执行f，会返回f这个函数，执行’’,会返回 undefined。 答案： &#39;f&#39;, &#39;&#39;, &#39;function&#39;, &#39;undefined&#39; 1.33、12var lowerCaseOnly = /^[a-z]+$/;[lowerCaseOnly.test(null), lowerCaseOnly.test()] 解析： 正则 test() 方法，会把参数当成字符串来使用，但要注意，null 会被当成 &#39;null&#39;来使用，无参则为 undefined。 答案： [true, true] 1.34、1[,,,].join(\", \") 解析： 由于JS的Array本质也是对象，所以具有对象的一个特点，会忽略最后一个单引号，[,,,].length // 3。 另外，这种方式定义，实际上是没有产生真正的key的。[,,,] // [undefined * 3] 答案： [, , ] 1.35、12var a = &#123;class: \"Animal\", name: 'Fido'&#125;;a.class 解析： 此题理应考察 class 为JS中的保留字，由于JS版本升级，此种写法已经可以正常返回属性值了。 注意：在IE8-的浏览器中，会有语法错误，使用了保留字 答案： &#39;Animal&#39; 1.36、1var a = new Date(\"epoch\") 解析： 日期通过new返回的一定是一个Date对象，如果参数格式不合理，则会返回 Invalid Date 的日期对象。 答案： Invalid Date 1.37、123var a = Function.length, b = new Function().lengtha === b 解析： Function.length 默认为1，Function 实例的 length 属性等于 function的参数个数。 答案： false 1.38、1234var a = Date(0);var b = new Date(0);var c = new Date();[a === b, b === c, a === c] 解析： 直接函数调用，不关心参数是啥，都会返回当前日期字符串。 通过 new Date()，如果无参数，返回当前日期对象。 通过 new Date(0)，就有一个参数，并且是数字，则参数含义为long类型的UTC时间。 答案： [false, false, false] 1.39、12var min = Math.min(), max = Math.max()min &lt; max 解析： 此题考察 Math.min() 和 Math.max() 的用法。 当 Math.min() 无参数时，返回 Infinity，参考：MDN Math.min 当 Math.max() 无参数时，返回 -Infinity，参考：MDN Math.min 答案： false 1.40、123var a = new Date(\"2014-03-19\"), b = new Date(2014, 03, 19);[a.getDay() === b.getDay(), a.getMonth() === b.getMonth()] 解析： 此题考察使用年月日构造函数时，月份是从0开始计算的。 答案： [false, false] 2、参考资料MDN – Mozilla 开发者网络 MDN Javascrpt –MDN JavaScript目录"},{"title":"02_Mongo权限探索","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/MongoDB入门基础/02_Mongo权限探索/","text":"0x0、导言经过一次 MongoDB 被黑之后，就想把 MongoDB 的权限仔细的了解一遍。安全第一！安全第一！ 为了避免版本不一致导致的差异，特此说明：以下命令均在 Mongo3.4 中测试，理论上支持所有 3.x 版本 0x1、MongoDB权限系统MongoDB 的权限管理也是符合 RBAC 的权限系统。 既然是 RBAC 的权限管理，那么就一定会有 actions 和 resources 的概念。 在 MongoDB 中，每一种操作都对应一种 action，在 Action List 可以查看所有的 Action 列表 同理，Collection/Database/Cluster 都是 Resrouce, resource 列表也可以在 Resource Document 找到。 1.1、如何授权启动在 MongoDB 中，默认是无授权启动的。如果我们要开启授权，那么需要在启动 MongoDB 的时候，加上 --auth 参数： 1mongod --config \"&lt;config path&gt;\" --auth 如果使用配置文件，那么也可以直接配置 12security authorization: enabled 注意：如果没有添加账户，就算设置 --auth 参数也无效，需要先添加用户，在添加用户的时候，必须要指定用户角色。 1.2、MongoDB角色管理在 MongoDB 中，具有两种类型的角色，一类是系统角色，一类是自定义角色。 一般来说，我们只需要关注系统角色。自定义角色需要通过角色相关的Shell来进行CRUD。 1.2.1、系统角色MongoDB 按照分类，具有较多的角色，列举如下，也可在 security-built-in-roles 查看所有内建角色明细。 数据库用户相关角色 read –只能查看单个数据库 readWrite – 可读写单个数据库 数据库管理员相关角色 dbAdmin – 数据库管理员，能进行差不多各种操作 dbOwner – 等于dbAdmin、readWrite、userAdmin的并集，数据库拥有者 userAdmin – 能够管理各种用户，角色等（如果是admin集合的，则能管理所有db） 集群管理员相关角色 clusterAdmin – 是clusterManager，clusterMonitor，clusterMonitor权限的集合，还多了个删除数据库操作。 clusterManager – 主要是配置集群 clusterMonitor – 主要是监控集群 hostManager – 主要是配置主机 备份还原相关角色 backup – 备份操作 restore – 还原操作 针对所有DB的角色 readAnyDatabase – 可读取所有的数据库 readWriteAnyDatabase – 可读写所有的数据库 userAdminAnyDatabase – 所有db的用户管理员 dbAdminAnyDatabase – 所有db的DB管理员 超级管理员角色 root – 超级超级管理员，最大权限了 内部角色 __system – 既然是内部角色，我们就不要去用了 1.2.2、自定义角色除了系统角色之外，还可以自定义角色，能够更灵活的控制权限。 详细，请参考：role-management 1.2、MongoDB用户管理有了Role的知识，我们来看User，就很easy了。 和一般的系统权限类似，MongoDB 也提供了诸多和用户相关的操作 db.auth() – 用于登录 123456db.auth( &#123; user: &lt;username&gt;, -- 用户 pwd: &lt;password&gt;, -- 密码 mechanism: &lt;authentication mechanism&gt;, -- 可选，认证机制 digestPassword: &lt;boolean&gt; &#125; ) db.createUser() – 创建用户 12345678&#123; user: &quot;&lt;name&gt;&quot;, -- 用户名 pwd: &quot;&lt;cleartext password&gt;&quot;, -- 密码 customData: &#123; &lt;any information&gt; &#125;, -- 自定义的数据 roles: [ -- 配置角色，db角色，设置数据库， 否则直接写角色名 &#123; role: &quot;&lt;role&gt;&quot;, db: &quot;&lt;database&gt;&quot; &#125; | &quot;&lt;role&gt;&quot;, ... ]&#125; db.updateUser() – 更新用户 123456789101112db.updateUser( &quot;&lt;username&gt;&quot;, -- 要更新的用户名 &#123; -- 要更新的用户对象 customData : &#123; &lt;any information&gt; &#125;, roles : [ &#123; role: &quot;&lt;role&gt;&quot;, db: &quot;&lt;database&gt;&quot; &#125; | &quot;&lt;role&gt;&quot;, ... ], pwd: &quot;&lt;cleartext password&gt;&quot; &#125;, writeConcern: &#123; &lt;write concern&gt; &#125;) 注：仅仅只需要更新role的话，考虑使用grantRolesToUser，revokeRolesFromUser db.removeUser() db.dropAllUsers() db.dropUser() db.grantRolesToUser() db.revokeRolesFromUser() db.getUser() db.getUsers() 其他用户方法都比较类似，查看详细： user-management 0x2、使用授权的MongoDB如果在 MongoDB 中配置了授权，那么连接到带授权的 MongoDB 也会有些许区别。 1234567891011# 简单的MongoDB Connection Stringmongodb://127.0.0.1/testdb# 带端口的MongoDBmongodb://127.0.0.1:27018/testdb# 带授权的MongoDBmongodb://user1:password1@127.0.0.1:27017/testdb# 带授权，且User是admin的场景mongodb://user1:password1@127.0.0.1:27017/testdb/?authSource=admin 如果是 shell，则需要先执行 db.auth(&#39;name&#39;, &#39;pwd&#39;)，之后才能执行其他命令。 0x3、总结加强安全意识，人为预防常规安全风险。 2017-1-21 16:09:48"},{"title":"Angular从0到1：function（上）","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/Angular相关/Angular从0到1：function（上）/","text":"1、前言Angular作为最流行的前端MV*框架，在WEB开发中占据了重要的地位。接下来，我们就一步一步从官方api结合实践过程，来学习一下这个强大的框架吧。 Note：每个function描述标题之后的★标明了该function的重要程度（1~5星）。 2、function（上）Angular封装了一系列公共方法，帮助我们更简单的使用JS。这些就是Angular的function。 2.1、angular.bind(★)angular.bind类似于Function.prototype.bind，实现函数柯里化，返回一个函数代理。eg: 函数原型 angular.bind(/*this对象*/self, /*要封装的function*/fn, /*参数列表*/args); //原始函数 function fun(arg1, arg2, arg3) { console.log(this); console.log(arg1); console.log(arg2); console.log(arg3); } fun(&apos;arg1&apos;, &apos;arg2&apos;, &apos;arg3&apos;); //如果几个常用参数都是固定的，而且该函数被调用频繁，那么就可以包装一下 var fun2 = angular.bind(window, fun, &apos;arg1&apos;, &apos;arg2&apos;); //新的调用方式 fun2(&apos;arg3&apos;); 2.2、angular.bootstrap(★★★★)用于使用angular执行渲染元素。也是angular的启动方法，如果没有在页面上指定ng-app,必须要手动调用该函数进行启动。 angular.bootstrap(/*Dom元素*/element, /*Array/String/Function*/[modules], /*Object*/[config]); //常规用法 angular.bootstrap(document, [&apos;app&apos;]) //带配置项 angular.bootstrap(document, [&apos;app&apos;], {strictDi: true/*Defaults: false*/}) 2.3、angular.copy(★★★★★)Angular.copy用于复制对象，由于angular的双向绑定特点，那么如果直接操作$scope对象，那么很容易就会改变ui的显示，这个时候就需要借助angular.copy来创建一个对象副本，并进行操作。 //原型 angular.copy(source, [destination]); var obj = {a: 1}; var obj2 = angular.copy(obj); var obj3; angular.copy(obj, obj3); console.log(obj2 === obj) //false console.log(obj3 === obj) //false var obj4; //第二个和参数和返回值是相等的，而且第二个参数不管以前是什么，都会被重新赋值 var obj5 = angular.copy(obj, obj4); console.log(obj4 === obj5); //true 2.4、angular.element(★★★★)等价与jQuery的选择器，如果在angular之前没有引入jQuery，那么就使用jqLite包装. angular.element(&apos;body&apos;); //等价于 $(&apos;body&apos;); //用法 var $body = angular.element(&apos;body&apos;); 2.5、angular.equals(★★)用于比较两个对象是否相等，如下示例的规则和JS有区别，注意识别。 var obj1 = {a: 1}; var obj2 = obj1; //引用一致，则相等 console.log(angular.equals(obj1, obj2)); // true obj2 = {a: 1}; //引用不一致，对象表现一致，则相等 console.log(angular.equals(obj1, obj2)); // true obj2 = {a: 1,$a: 2}; //对象比较时，忽略以$开头的属性 console.log(angular.equals(obj1, obj2)); // true obj1 = /aa/; obj2 = /aa/; //正则表达式表现相等，则相等 console.log(angular.equals(obj1, obj2)); // true //NaN与NaN比较，则相等 console.log(angular.equals(NaN, NaN)); // true 2.6、angular.extend(★★)功能上和jQuery.extend没多大差异 //原型-第一个参数为目标，之后的参数为源，同时返回dst angular.extend(dst, src); //示例 var obj1 = {a: 1}; var obj2 = angular.extend(obj1, {a: 2}, {b: 3}); console.log(obj1) console.log(obj1 === obj2); //true 2.7、angular.forEach(★★★★★)angular.forEach用于遍历对象或者数组，类似于ES5的Array.prototype.forEach //原型 angular.forEach(obj, iterator, [context]); var values = {name: &apos;misko&apos;, gender: &apos;male&apos;}; var arr = [&apos;misko&apos;, &apos;male&apos;]; angular.forEach(values, function (value, key) { console.log(key + &apos; = &apos; + value); }); angular.forEach(arr, function (value, i) { console.log(i + &apos; = &apos; + value); }); //还可以传递this var obj = {}; angular.forEach(values, function (value, key) { obj[key] = value; }, obj); console.log(obj); 2.8、angular.fromJson(★★★)angular.fromJson将JSON字符串转换为JSON对象，注意，必须严格满足JSON格式，比如属性必须双引号，该函数内部实现是利用JSON.parse()。 //原型 angular.fromJson(/*string*/ jsonString) var jsonString = &apos;{&quot;p1&quot;: &quot;xx&quot;, &quot;p2&quot;: 1, &quot;p3&quot;: true}&apos;; var jsonObj = angular.fromJson(jsonString); console.log(jsonObj); 2.9、angular.toJson(★★★)angular.toJson可以将对象，数组，日期，字符串，数字转换为json字符串 //原型 angular.toJson(obj, pretty); var obj = {p1: 1, p2: true, p3: &apos;2&apos;}; var jsonString = angular.toJson(obj); console.log(jsonString); //美化输出格式（设置为true，默认采用2个字符缩进） jsonString = angular.toJson(obj, true); console.log(jsonString); //还可以设置缩进字符数 jsonString = angular.toJson(obj, 10); console.log(jsonString); 2.10、angular.identity(★)angular.identity返回该函数参数的第一个值。编写函数式代码时，非常有用（待使用）。 //官方示例 function transformer(transformationFn, value) { return (transformationFn || angular.identity)(value); }; //简单演示 var value = angular.identity(&apos;a&apos;, 1, true); console.log(value); // &apos;a&apos; 2.11、angular.injector(★★)angular.injector能够创建一个injector对象，可以用于检索services以及用于依赖注入。 //原型，[strictDi]默认false，如果true，表示执行严格依赖模式， //angular则不会根据参数名称自动推断类型，必须使用[&apos;xx&apos;, function(xx){}]这种形式。 angular.injector(modules, [strictDi]); //定义模块A var moduleA = angular.module(&apos;moduleA&apos;, []) .factory(&apos;F1&apos;, [function () { return { print: function () { console.log(&apos;I\\&apos;m F1 factory&apos;); } } }]); var $injector = angular.injector([&apos;moduleA&apos;]) $injector.invoke(function (F1) { console.log(F1.print()); }); //此种写法会报错，因为是严格模式 var $injector2 = angular.injector([&apos;moduleA&apos;], true) $injector2.invoke(function (F1) { console.log(F1.print()); }); //可以采用如下写法 $injector2.invoke([&apos;F1&apos;, function (F1) { console.log(F1.print()); }]); 2.12、angular.module(★★★★★)angular.module可以说是最常用的function了。通过它，可以实现模块的定义，模块的获取。 //定义模块A var moduleA = angular.module(&apos;moduleA&apos;, []); //定义模块B，模块B依赖moduleA var moduleB = angular.module(&apos;moduleB&apos;, [&apos;moduleB&apos;]); //可以在第三个参数上设置配置函数 var moduleB = angular.module(&apos;moduleB&apos;, [&apos;moduleB&apos;], [&apos;$locationProvider&apos;, function ($locationProvider) { console.log($locationProvider); }]); //等价于 var moduleB = angular.module(&apos;moduleB&apos;, [&apos;moduleB&apos;]) .config([&apos;$locationProvider&apos;, function ($locationProvider) { console.log($locationProvider); }]); //获取模块 angular.bootstrap(document, [&apos;moduleB&apos;]);"},{"title":"说说你所熟知的MSSQL中的substring函数","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/SQL SERVER/说说你所熟知的MSSQL中的substring函数/","text":"说说你所熟知的MSSQL中的substring函数 ###函数签名： substring --expression (varchar,nvarchar,text,ntext,varbinary,or image) --Starting position (bigint) --Length (bigint) 从函数名称来看，是截取字符串内容。 从函数签名来看，不仅能截取字符串内容，还能截取二进制内容 ###那么，你觉得如下应该sql语句应该是什么结果呢？ select subString(&apos;123456&apos;,0,1) select subString(&apos;123456&apos;,1,1) select subString(&apos;123456&apos;,-1,2) select subString(&apos;123456&apos;,-1,3) ###如果想好了，但不确定，那赶紧打开工具执行看看吧 你答对了吗？为什么会是那些结果，能解释吗？ ###三大知识点： 1. MSSQL中，下标从1开始，注意：不是大多数编程语言采用的1。 2. substring函数的调用substring(str,startIndex,length) 效果上是转换为substring(str,startIndex,endIndex)来运算的， endIndex=startIndex+length。 3. 对于区间取值，采取的是前闭后开的策略，也有是说包含开始下标，但是不包含结束下标。 那么能解释上面的代码了吗？"},{"title":"Thrift简单实践","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/Other/Thrift简单实践/","text":"0、什么是RPCRPC（Remote Procedure Call - 远程过程调用）,是通过网络从远程计算机上请求服务，而不需要了解底层网路技术的细节。简单点说，就是像调用本地服务（方法）一样调用远端的服务（方法）。 RPC与REST的区别RPC是一种协议，REST是一种架构风格。 RPC以行为为中心，REST以资源为中心。当加入新功能时，RPC需要增加更多的行为，并进行调用。REST的话，调用方法基本不变。 RPC可以不基于HTTP协议，因此在后端语言调用中，可以采用RPC获得更好的性能。REST一般是基于HTTP协议。 1、RPC框架Thrift（0.9.3）Thrift是一种开源的高效的、支持多种编程语言的远程服务调用框架。支持C++, Java, Python, PHP, Ruby, Erlang, Perl, Haskell, C#, Cocoa, JavaScript, Node.js, Smalltalk, OCaml 和 Delphi等诸多语言，能够很好的进行跨语言调用。 Thrift官网： https://thrift.apache.org/ 2、Thrift的简单实践（Windows）2.1 安装Thrift在http://www.apache.org/dyn/closer.cgi?path=/thrift/0.9.3/thrift-0.9.3.exe这里可以下载Thrift的windows系统编译版本。 该文件是一个绿色文件，可以放置在目录中，进入该目录的cmd，就可以直接使用thrift。输入thrift -version可以查看当前Thrift的版本。 至此，Thrift已完成安装 2.2 编写接口定义文件在安装好Thrift之后，需要我们编写接口定义文件，用来约定服务和thrift类型的接口定义。 Thrift主要有一下这些类型： bool –简单类型，true or false byte –简单类型，单字符 i16 –简单类型，16位整数 i32 –简单类型，32位整数 i64 –简单类型，64位整数 double –简单类型，双精度浮点型 string –简单类型，utf-8编码字符串 binary –二进制，未编码的字符序列 struct –结构体，对应结构体、类等对象类型 list –list容器 set –set容器 map –map容器 enum –枚举类型 接下来，利用这些类型，编写一个简单的.thrift接口定义文件。 /* 1.thrift file content */ namespace js ThriftTest namespace csharp ThriftTest service ThriftTest{ double plus(1:double num1, 2:double num2) } 更复杂的案例： https://git-wip-us.apache.org/repos/asf?p=thrift.git;a=blob_plain;f=test/ThriftTest.thrift;hb=HEAD 在利用thrift --gen js:node --gen js 1.thrift来生成好客户端代码和服务端代码。可以跟多个–gen 参数，来实现一次性生成多个语言的代码。 2.3 利用Thrift实现nodeJS服务端var thrift = require(&apos;thrift&apos;); var ThriftTest = require(&quot;./gen-nodejs/ThriftTest&quot;); var ttypes = require(&quot;./gen-nodejs/1_types&quot;); var nodeServer = thrift.createServer(ThriftTest, { //完成具体的事情 plus: function(n1, n2, callback){ console.log(`server request, n1 = ${n1}, n2 = ${n2}.`); callback(null, n1 + n2); } }); //处理错误，假设不处理，如果客户端强制断开连接，会导致后端程序挂掉 nodeServer.on(&apos;error&apos;, function(err){ console.log(err); }); nodeServer.listen(7410); console.log(&apos;node server started... port: 7410&apos;); //如果client的浏览器，通信采用http的时候，需要创建http server var httpServer = thrift.createWebServer({ cors: {&apos;*&apos;: true}, //配置跨域访问 services: { &apos;/thrift&apos;: { //配置路径映射 transport: thrift.TBufferedTransport, protocol: thrift.TJSONProtocol, processor: ThriftTest, handler: { //具体的处理对象 plus: function(n1, n2, callback) { console.log(`http request, n1 = ${n1}, n2 = ${n2}.`); callback(null, n1 + n2); } } } } }); httpServer.on(&apos;error&apos;, function(err) { console.log(err); }); httpServer.listen(7411); console.log(&apos;http server started... port: 7411&apos;); 2.4 Node Client 调用var thrift = require(&apos;thrift&apos;); var ThriftTest = require(&apos;./gen-nodejs/ThriftTest&apos;); var ttypes = require(&apos;./gen-nodejs/1_types&apos;); transport = thrift.TBufferedTransport() protocol = thrift.TBinaryProtocol() var connection = thrift.createConnection(&quot;localhost&quot;, 7410, { transport : transport, protocol : protocol }); connection.on(&apos;error&apos;, function(err) { console.log(false, err); }); var client = thrift.createClient(ThriftTest, connection); var sum = client.plus(1, 1, function(err, result){ //connection.end(); //如果不关闭连接，那么强制断开连接，将会导致后端出现error if(err){ console.log(err); return; } console.log(result); }); 2.5、Http Client 调用&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Thrift Test Client&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;text&quot; id=&quot;num1&quot;&gt; + &lt;input type=&quot;text&quot; id=&quot;num2&quot;&gt; &lt;button onclick=&quot;call()&quot;&gt;=&lt;/button&gt; &lt;span id=&quot;result&quot;&gt;?&lt;/span&gt; &lt;!-- &lt;script src=&quot;jquery.js&quot;&gt;&lt;/script&gt; --&gt; &lt;script src=&quot;thrift.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;gen-js/1_types.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;gen-js/ThriftTest.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var transport = new Thrift.Transport(&quot;http://127.0.0.1:7411/thrift&quot;); var protocol = new Thrift.TJSONProtocol(transport); var client = new ThriftTest.ThriftTestClient(protocol); var el_result = document.getElementById(&apos;result&apos;); function call(){ var num1 = +document.getElementById(&apos;num1&apos;).value, num2 = +document.getElementById(&apos;num2&apos;).value; client.plus(num1, num2, function(result) { el_result.innerText = result; alert(&apos;调用成功！&apos;); }); } &lt;/script&gt; &lt;script&gt; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 注意：如果在thrift生成代码时，使用了–gen js:jquery参数，那么在浏览器调用的时候，就必须依赖jquery。 3、demo地址https://github.com/hstarorg/HstarDemoProject/tree/master/thrift_demo"},{"title":"01_PHP简易安装环境","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/PHP学习之路/01_PHP简易安装环境/","text":"0、导言PHP 是啥，我想应该不用解释了吧。 最近发布的最新版本 PHP7 ，提供之前版本的2倍速度提升，感觉很有吸引力哈。在看到2016年编程语言趋势和想到之前也想体验一下 PHP 的情况下，就说干就干，直接来简单学习下这门语言。 1、PHP简易环境搭建1.1、PHP安装PHP 的安装相当简单，打开 PHP 的下载地址：http://php.net/downloads.php，可以看到它的版本下载。 我这里是 Windows 环境，就点击 【Windows downloads】 进入Windows版本的PHP下载地址： http://windows.php.net/download#php-7.0 。在这里找到对应的版本下载即可。 注意：请下载对应x86,x64的zip包，不要下载Debug Pack包。至于Non Thread Safe 与 Thread Safe，由于本人刚接触，不知道有什么区别，随意下载一个就行。 我是Win10 x64版本，所以直接下载的：【VC14 x64 Non Thread Safe (2016-May-25 23:02:13)】（有最新版本下载最新版本即可）。 下载好之后，是一个压缩包。解压到目录中，在环境变量中配置 Path 为该目录。 打开 cmd 窗口，执行 php -v ，如果输出 PHP 的版本号，则表示安装成功！ 1.2、IDE的选择PHP有比较多IDE，这里推荐 PhpStorm 和 VsCode。 本人使用的 VsCode，足够轻量。 1.3、依赖管理工具一个成熟的语言，一定会有很多现成的包，如C#的Nuget，Node的npm。在PHP中，也有同样的工具：Composer。 如何在Windows下使用：Composer？ 首先，进入Composer下载地址：https://getcomposer.org/download/，找到【Composer-Setup.exe】，然后下载安装。 安装成功之后在控制台执行：composer 会输出一系列命令，则证明安装成功。 然后就可以通过 composer install &lt;package&gt; 来安装依赖包了。 想了解更多 composer 命令，请查询：https://getcomposer.org/doc/。 注意，我在Windows中使用composer安装时，先使用了 composer config disable-tls true 和 composer config secure-http false 才得以成功安装依赖。 1.4、Server程序PHP自带有一个命令行的Server，用于开发测试已经足够使用了。所以，我直接使用了该Server。 只需要在php项目的根目录，打开cmd，执行 php -S localhost:9999 就可以启动一个PHP Server了。 想了解更多关于PHP自带的Web Server，请参考 http://php.net/features.commandline.webserver 2、Hello PHP新建一个目录，创建 index.php，输入以下内容： 12345678910111213141516&lt;?php mb_internal_encoding('UTF-8'); mb_http_output('UTF-8');?&gt;&lt;!doctype html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Php Info&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;?php phpinfo(); ?&gt; &lt;/body&gt;&lt;/html&gt; 打开控制台，使用 php -S localhost:9999 启动WebServer。 用浏览器访问 http://localhost:9999，就可以看到当前服务器的PHP环境信息了。 3、Other3.1、推荐资料： PHP之道 3.2、PHP的编码问题，一般在php的页面上，我们都需要设置： 12345&lt;?php mb_internal_encoding('UTF-8'); //内部编码为UTF-8 mb_http_output('UTF-8'); //服务器输出内容编码为UTF-8?&gt; 要想用Server运行含有该代码的PHP页面。需要特别配置一下 php.ini 文件。 在PHP的解压目录，找到 php.ini-development，复制一份为 php.ini，然后找到 extension_dir，设置为：extension_dir = &quot;你的PHP解压目录\\ext&quot;，然后找到 ;extension=php_mbstring.dll 去掉前面的注释。 3.3、PHP框架推荐 Yaf 官方框架，超高性能 http://www.laruence.com/manual/index.html http://php.net/manual/zh/yaf.installation.php LazyPHP 超级简单的框架，建议读源码 https://github.com/easychen/LazyPHP Slim 据说还不错 http://www.slimframework.com/ Laravel 高人气框架 https://laravel.com/ https://lumen.laravel.com/ 专注API开发的PHP。 ThinkPHP 中文 http://www.thinkphp.cn/ InitPHP (A PHP Framework) - (from github) http://www.initphp.com/ TinyMVC (from github) https://github.com/mohrt/tinymvc-php"},{"title":"02_Sass学习之路：注释、变量以及导入","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/Sass学习之路/02_Sass学习之路：注释、变量以及导入/","text":"前言由于.sass不兼容CSS代码，所以以下内容完全使用.scss的语法。 Sass注释Sass中除了提供CSS中的标准注释之外，还提供了一种静默注释： /* 我是标准注释 */ // 我是静默注释 标准注释大多数情况下（一种例外：设置输出风格为compressed）是会生成到最终的CSS中的，而静默注释的话，只是Sass的注释，是不会被生成到CSS文件中的。 如果想，就算设置输出风格为compressed也要加入特定注释呢？那么可以采用重要注释写法，如下： /*! 我的重要注释 */ 也就是在标准注释的基础上，将注释的第一个字符设置为感叹号。 Sass变量Sass作为一个CSS预处理器，那么最基本的编程语言特性变量自然也是必不可少的。Sass中变量系统相对比较丰富，包含局部变量，全局变量，默认变量，特殊变量（变量作用在属性上），多值变量。 Sass变量以$开头，用:分割变量名与变量值，以;结尾。如： $color: red; Sass变量，不区分中横线和下划线，比如定义变量为$bg-color，那么使用$bg_color也能访问到哦！ 局部变量同大多数编程语言一样，变量的作用域是它本身的这个块，以及所有的子集。如: body{ $color: blue; color: $color; .container{ background-color: $color; } } 将被编译为： body { color: blue; } body .container { background-color: blue; } 同时，需要注意：针对以上代码，如果内部修改了$color的值，也会同时影响到外部的变量值。 全局变量如果定义在局部的变量，与它同级的选择器中是无法使用的： body{ $color: blue; color: $color; .container{ background-color: $color; } } // 会出现错误，未定义的变量 footer{ color: $color; } 这个时候，就需要提升$color为全局变量，在变量值之后，加上!global,示例如下： body{ $color: blue !global; color: $color; .container{ background-color: $color; } } // 会出现错误，未定义的变量 footer{ color: $color; } 这个的话，就能够正常编译了，因为$color被提升为全局变量了。 默认变量在Sass中，可以通过在变量值之后加入!default来让变量称为默认变量，如果有对该变量的赋值，不管前后，那么变量的默认值都会被替换掉，示例如下： $color: red; body{ $color: blue !default; color: $color; .container{ background-color: $color; } } footer{ color: $color; } 可以通过注释掉!default来查看生成的CSS的异同。 特殊变量Sass的变量，还可以用在属性中，此时需要使用#{变量名}来引用，示例如下： $containerId: c1; ##{$containerId}{ color: red; } 此时，生成的CSS为： #c1 { color: red; } 多值变量强大的Sass，还提供了一种特殊的变量，即为多值变量，在一个变量中，可以定义多个值，然后通过制定的函数访问，示例如下： // List类型的多值变量 $px: 5px 10px 15px 20px; // Map类型的多值变量 $map: (id1: test, id2: testGrid, color: red); body{ // 此处需要注意，索引是从1开始，不是从0哦。 margin-left: nth($px, 1); // 使用map-get访问，当心key的使用，指定了不存在的key会导致生成的css异常 #{map-get($map, id2)}{ color: red; } #id{ color: map-get($map, color); } } 生成的CSS如下： body { margin-left: 5px; } body testGrid { color: red; } body #id { color: red; } 导入体现可维护性的重要指标就是文件似乎可以单一职责，那么在Sass中，主要体现在导入上。由于Sass中的导入指令和CSS的导入指令是同样的关键字，那么就需要按照一定的规则来判别了，满足以下任意一条规则的导入，使用CSS的原生导入： 被导入的文件名以.css结尾 被导入的文件是一个在线的url地址 以@import url(…)方式去导入文件 同时，编写局部的sass文件，建议使用下划线开头,如： _a.scss，这样就不会生成多余的_a.css了。 //_a.scss #id2{ color: red; } //1.scss @import &quot;a.scss&quot;; #id1{ color: blue; } body{ @import &quot;a.scss&quot;; } 最终生成的结果为: #id2 { color: red; } #id1 { color: blue; } body #id2 { color: red; } 结尾欲知后事如何，请听下回分解！"},{"title":"TypeScript札记：初体验","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/TypeScript札记/TypeScript札记：初体验/","text":"1、简介TypeScript 是一种由微软开发的自由和开源的编程语言。它是JavaScript的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程。 TypeScript是一种Compile-to-JavaScript的语言 TypeScript扩展了JavaScript的句法，所以现有的JavaScript程序可以不加修改，直接在TypeScript下工作。同时，TypeScript编译产生JavaScript以确保兼容性。 2、特点&amp;优势2.1、兼容现有JS代码 2.2、类型系统，面向对象设计，保证程序的健壮性（编译检查） 2.3、良好的语法，良好的工具支持 2.4、良好的社区支持 3、快速开始3.1、 工具 如果是VS开发，安装 TypeScript 1.4 for Visual Studio 2013，版本随时变化，建议下载最新版本。 如果是NPM用户，那么直接 npm install -g typescript 3.2、 Hello Jay 使用VS的用户，直接新建项（TypeScript File即可）；使用其他IDE的用户，如果IDE支持TypeScript，那么直接新建TypeScript；其他则新建文本文件，后缀名为ts。如果是不能在IDE中编译，那么可以直接通过npm安装typescript之后，使用tsc fileName.ts，进行编译。 打开1.ts文件，输入： function hello(name: string){ return &apos;Hello,&apos; + name; } var res = hello(&apos;Jay&apos;); console.log(res); 执行tsc 1.ts之后，生成一个1.js文件（具有可读性的标准js文件）： function hello(name) { return &apos;Hello,&apos; + name; } var res = hello(&apos;Jay&apos;); console.log(res); 4、参考资料1、 官网：http://www.typescriptlang.org/ 2、 入门指南： https://github.com/vilic/typescript-guide"},{"title":"02_Vue组件（上）","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/Vue实践之路/02_Vue组件（上）/","text":"0、关于Vue组件组件是 Vue 中最强大的功能之一，Vue组件也和angular的组件比较类似，可以扩展HTML元素。在较高层面上，也是自定义元素。 在原生HTML元素上附加功能，Vue 的做法是通过 is 特性扩展， ng2 中则称之为属性指令。 1、定义组件在 Vue 中定义组件是一个很轻松的方式，代码如下： 12345678910111213141516// 定义组件构造器var Component1 = Vue.extend(&#123;&#125;);// 全局注册组件Vue.component('component-1', Component1);// 也可局部注册组件// 局部注册意味着该组件仅能在包含它的组件中运行，如示例的Parent组件var Parent = Vue.extend(&#123; template: '', components: &#123; 'component-1': Component1 &#125;&#125;); 为了足够简单，Vue 还提供了一个语法糖写法如下： 12345678910111213// 直接注册组件（不在需要组件构造器）Vue.component('component1', &#123;&#125;);// 局部注册同理var Parent = Vue.extend(&#123; template: '', components: &#123; 'component-1': &#123; &#125; &#125;&#125;) 该语法实际上是 Vue 在背后自动调用 Vue.extend()。 除此之外，如果使用 .vue 格式的组件，我们定义组件的方式如下： 123456&lt;script&gt; // 定义一个组件 export default &#123; &#125;;&lt;/script&gt; 组件选项所谓组件选项，就是在定义组件时，传递给 Vue.extend() 的参数。 定义组件是相当简单的事情，我们更多的需要去关注组件选项！ 先来一个完整的组件选项压压惊： 1234567891011121314151617181920212223242526272829303132333435var Component1 = Vue.extend(&#123; data: &#123;&#125; or fn // 数据对象 props: [] or &#123;&#125; // 组件可配置的属性 propsData: &#123;&#125; // 在创建实例时，给属性赋值（用于测试） computed: &#123;&#125; // 实例计算属性 methods: &#123;&#125; // 实例方法 watch: &#123;&#125; // 监控属性 el: string or HtmlElement or fn //挂载元素，将组件实例挂载到那儿 template: string // 组件模板 replace: boolean // 是否替换挂载元素，和template一起使用，默认true init: fn // 生命周期钩子，初始化时调用，此时数据观察、事件和watcher都没初始化 created: fn // 组件参数已经解析完毕，但还未开始DOM编译 beforeCompile: fn //开始编译DOM compiled: fn // DOM编译完成，数据辩护已经可以触发DOM更新了，但不保证$el已经插入文档 ready: fn // 编译结束和 $el 第一次插入文档之后调用 attached: fn // 在$el插入DOM时调用 detached: fn // 在$el从DOM元素中删除时调用 beforeDestroy: fn // 在开始销毁实例时调用 destroyed: fn // 实例销毁后调用，如果有离开过渡，将会在过渡完成之后调用 directives: &#123;&#125; // 组件局部注册的指令 elementDirectives: &#123;&#125; // 组件局部注册的元素指令 filters: &#123;&#125; // 组件局部注册的过滤器 components: &#123;&#125; // 组件局部注册的子组件 transitions: &#123;&#125; // 组件局部注册的动画 partials: &#123;&#125; // 组件局部注册的分部元素 parent: Vue实例 // 指定实例的父实例 events: &#123;&#125; // 事件监听列表对象 mixins: [] // 组件的混合器 name: string //组件的名称，允许在自己的模板中调用自己（递归组件非常有效） extends: &#123;&#125; or fn // 声明式的扩展组件&#125;); 虽然全量的属性比较多，但实际上常用的并不很太多，下面我列一下我比较常用的属性： 123456789101112131415161718192021222324252627282930313233343536373839404142var Component1 = Vue.extend(&#123; name: 'component-1', data: &#123; firstName: 'Hu', lastName: 'Jay' &#125;, props: ['height', 'width'], template: '&lt;h1&gt;&#123;&#123;fullName&#125;&#125;&lt;/h1&gt;', replace: true, filters: &#123;&#125;, components: &#123;&#125;, transitions: &#123;&#125;, methods: &#123; doSomething: function()&#123; alert(this.fullName); &#125; &#125;, events: &#123; 'do': 'doSomething', //方法名字 'do1': function()&#123; //当捕获 do1 事件时执行 &#125; &#125;, watch:&#123;&#125;, computed: &#123; fullName: function()&#123; return this.firstName + this.lastName; &#125; &#125; created: funciton()&#123; // 初始化操作 &#125;, ready: funciton()&#123; // 如果有DOM操作，那么放在这里 &#125;, beforeDestroy: funciton()&#123; // 如果某些东西需要手动释放，那么放在这里 &#125;&#125;); 如果是在 .vue 格式中，我们的用法稍微有点变化，主要是使用ES6的新特性。 123456789101112131415161718192021222324252627282930313233343536373839&lt;style&gt; &lt;!-- 放置样式 --&gt;&lt;/style&gt;&lt;template&gt; &lt;!-- 此处放置模板，建议都用一个根元素包裹起来 --&gt; &lt;div class=\"app-component-1\"&gt; &lt;h1&gt;我是模板内容&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; //放置组件代码 export default &#123; props: [], data() &#123; return &#123;&#125;; &#125;, created() &#123; &#125;, methods: &#123; fun1() &#123; &#125;, fun2() &#123; &#125; &#125;, events: &#123; 'do': function()&#123; &#125; &#125;, watch: &#123; firstName(newVal, oldVal)&#123; &#125; &#125; &#125;;&lt;/script&gt; 注意：为什么data在.vue中data是一个方法呢？因为.vue下是使用的ES6的特性，如果是属性的话，就是原型属性，当多个组件时，就会共享同一份原型，导致数据错乱，所以通过function返回一个对象，保证每个组件实例隔离。"},{"title":"02-模块化加载&防冲突处理","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/jQuery拆解/02-模块化加载&防冲突处理/","text":"0、模块化加载jQuery 在之前的版本（具体不记得是哪个版本以前了）中，是不支持模块化加载的。 当前，模块化作为一个趋势，jQuery 也增加了对模块化的支持，当今最流行的的模块规范是 UMD，简单点说就是判断各种环境，然后选择合适的方式加载。 来看下具体的实现： 123456789101112131415161718192021222324252627282930313233//首先是一个IIFE，避免污染全局变量( function( global, factory ) &#123; \"use strict\"; // 判断是否是模块化加载 // 如果是CMD加载器，那么会有 module 和 module.exports 属性 if ( typeof module === \"object\" &amp;&amp; typeof module.exports === \"object\" ) &#123; // 如果有document，那就算是浏览器环境，那么直接导出jQuery module.exports = global.document ? // 注意， factory第二个参数是true，也就是说不会挂载到全局变量上（模块化加载不需要挂载到window上） factory( global, true ) : // 虽然看起来是模块化加载，但是没有找到window对象，这个时候就导出一个factory,需要手动传入window对象。 function( w ) &#123; if ( !w.document ) &#123; throw new Error( \"jQuery requires a window with a document\" ); &#125; return factory( w ); &#125;; &#125; else &#123; // 如果不是加载器加载，那么就直接把window或者this传递给 jQuery factory factory( global ); &#125;// Pass this if window is not defined yet&#125; )( typeof window !== \"undefined\" ? window : this, function( window, noGlobal ) &#123; // jQuery本身的逻辑代码 // 注意，jQuery也支持了AMD方式加载。 if ( typeof define === \"function\" &amp;&amp; define.amd ) &#123; define( \"jquery\", [], function() &#123; return jQuery; &#125; ); &#125;&#125;); 通过以上代码实现，jQuery 就实现了模块化加载。 1、防冲突处理当一个库可能会挂载属性到全局变量的时候，那么就要考虑全局变量覆盖这个问题。 比如说 jQuery 会挂载到 window.jQuery 和 window.$ 上，那万一这两个属性已经被其他库使用了，那我们引入 jQuery 不就把别人的库覆盖了么。 作为一个完备的库，jQuery 也处理了这种场景。那就是防冲突方法。 看一下具体的实现： 1234567891011121314151617181920212223242526272829303132333435// 在实现防冲突时，要注意代码的顺序// 首先先用局部变量，把要挂载的属性备份一次。var// Map over jQuery in case of overwrite _jQuery = window.jQuery, // Map over the $ in case of overwrite _$ = window.$;// 实现一个冲突方法，当调用该方法时，就会把之前保存的全局变量进行还原。// deep的意思就是是否要还原jQuery这个属性，因为jQuery并不是一个常用的属性，所以一般不会被其他库占用。jQuery.noConflict = function(deep) &#123; if (window.$ === jQuery) &#123; window.$ = _$; &#125; if (deep &amp;&amp; window.jQuery === jQuery) &#123; window.jQuery = _jQuery; &#125; // 冲突之后，总要挂载吧，通过return jQuery，就能返回jQuery，这个时候可以任意挂载到你想要的属性。 // 实例代码： window.abcde = jQuery.noConflict(); return jQuery;&#125;;// Expose jQuery and $ identifiers, even in AMD// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)// and CommonJS for browser emulators (#13566)// 如果不是非全局（如果是双重否定，实际就是如果是全局）if (!noGlobal) &#123; // 那么就设置到全局变量，这个时候已经把全局属性覆盖了。 window.jQuery = window.$ = jQuery;&#125;return jQuery;"},{"title":"01_Sass学习之路：Sass、Compass安装与命令行","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/Sass学习之路/01_Sass学习之路：Sass、Compass安装与命令行/","text":"导言CSS不是一门真正意义上的编程语言，很多编程语言理所当然的特性（比如变量），都不被支持。同时再开发模块化的web项目的时候，也要避免相互干扰。为了弥补CSS的这些不足，就产生了CSS预处理器，Sass则是其中的佼佼者。 什么是SassSass是最成熟、稳定、强大、专业的CSS扩展语言（官方解释）。直白点，Sass就是一个非常好用的CSS预处理器，为css引入部分编程语言的特性。 Sass在现阶段，有两种编码的语法，一个是兼容CSS语法的Scss格式文件，一个是Haml、Ruby类似语法的Sass格式文件。一般情况下，我们选用第一种兼容Css语法的Scss文件格式 什么是CompassCompass是基于Sass的一个css创作框架，其实就是基于Sass提供了很多非常实用的函数，有点类库的概念。 如何安装Sass是基于Ruby写的，安装Sass需要先安装Ruby：https://www.ruby-lang.org/zh_cn/downloads/。 在Windows上安装Ruby，需要借助RubyInstall工具：http://rubyinstaller.org/ 安装好Ruby只有，可以使用cmd：ruby -v 查看ruby的版本，如果有输出，表示ruby安装成功。这个时候，则可以使用ruby gem sass来安装Sass，ruby gem compass来安装Compass。 *注意事项：由于gem仓库被墙了，如果想使用的话，需要切换镜像地址，国内可以采用淘宝的ruby镜像：http://ruby.taobao.org。可以通过如下命令实现：* //移除官方gems gem sources --remove https://rubygems.org/ //添加淘宝的gems gem sources -a https://ruby.taobao.org/ //查看现有的gems gem sources -l 命令行//编译Sass sass &lt;sass file&gt; &lt;css file&gt; //Sass与Scss相互转换 sass-convert &lt;.sass file&gt; &lt;.scss file&gt; sass-convert &lt;.scss file&gt; &lt;.sass file&gt; //监视Sass文件变更，自动编译(可选输出css的风格，参数为style) sass --watch &lt;sass file&gt;:&lt;css file&gt; [--style [nested|expanded|compact|compressed]] //监视文件夹中Sass文件变更，自动编译 sass --watch &lt;sass folder&gt;:&lt;ouput css folder&gt; //----------------------Compass-------------- //创建Sass工程 compass create //编译sass文件 compass compile //监视Sass工程下sass文件变更(可选输出css的风格，参数为output-style) compass --watch [--output-style [nested|expaned|compact|compressed]] 更简单的使用方式看了以上这么多的步骤，是不是感觉头疼？ 老夫看你天资聪慧，将来必成大器，特为你带来一本秘籍，祝你早日功成！ 在真正的开发环境中，我们一般这么用，结果node+gulp等构建工具。 首先，需要安装node,然后使用npm安装gulp和gulp-sass。 接着，编写一个基于gulp的构建脚本，如果是其他构建工具，那么编写对应的脚本即可，gulpfile.js代码如下： var gulp = require(&apos;gulp&apos;), sass = require(&apos;gulp-sass&apos;); gulp.task(&apos;default&apos;, [&apos;sass&apos;, &apos;watch&apos;], function () { console.log(&apos;Begin watching...&apos;); }); gulp.task(&apos;sass&apos;, function () { return gulp.src(&apos;./*.scss&apos;) .pipe(sass({ outputStyle: &apos;expanded&apos; }).on(&apos;error&apos;, sass.logError)) .pipe(gulp.dest(&apos;./css/&apos;)); }); gulp.task(&apos;watch&apos;, function () { return gulp.watch(&apos;./*.scss&apos;, [&apos;sass&apos;]); }); 最后，使用控制台，启动gulp，然后畅快的编写sass代码吧。"},{"title":"01_Stylus简介&基本使用","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/从0开始Stylus/01_Stylus简介&基本使用/","text":"0、导言关于Stylus Stylus是一个CSS预处理器，也就是利用编程的方式编写css代码，然后stylus会自动帮我们编译为标准的css，并能附加更多的功能。 Stylus开始于2010年，来自于Node.js社区。 Stylus的文件后缀是.styl 常用预处理器之间的简单比较 常用的CSS预处理还有Sass和LESS。Sass提供了非常多的特性，也非常成熟。Less使用起来更为简单。Stylus在功能上更为健壮，和JS的联系更加紧密。 此文产生的缘由 由于亲近Node.js，所以想系统的学习下和js更紧密的Stylus预处理器 最近在实现nk-style的时候，采用了Stylus来编写CSS，用文章的方式来加深理解 1、配套工具如何安装Stylus 既然是Node.js社区的产出，那么很明显，安装方式也带有浓浓的Node风格。使用npm install stylus -g就可以在系统中安装Stylus了，当然，前提是你得先安装node和npm。 如何使用 安装好Stylus之后，我们就可以在控制台输入特定命令，来转换Stylus文件。 stylus css –编译css目录的.styl文件，并输出同名的.css文件 stylus index.styl abc.styl –编译index.styl、abc.styl文件 更多命令请参考 http://stylus-lang.com/docs/executable.html 更常规的用法 一般使用stylus的话，是会结合构建工具来一起使用的。比如结合gulp来使用的方式如下： 1234567var stylus = require('gulp-stylus');gulp.task('css', _ =&gt; gulp.src('./src/index.styl') .pipe(stylus()) .pipe(gulp.dest('./dist/'))); 2、Stylus语法Stylus在语法支持上是比较强大的。既支持标准CSS，也支持缩进格式，最厉害的还能在同一个styl文件中混用。 12345678910body&#123; background: white;&#125;body&#123; background blue&#125;body background green 编译生成的CSS如下： 123456789body &#123; background: #fff;&#125;body &#123; background: #00f;&#125;body &#123; background: #008000;&#125; 2.1、注释在学习一门编程语言（或者类编程语言时），我都胡优先去了解它的注释用法。因为刚学，意味着陌生，意味着需要些一些备注，那么这个时候注释就是个好东西。 在Stylus中，注释有三种方式： 单行注释 –仅在styl文件中可见 多行注释 –常规模式下，输出到css文件中 重点注释 –在compress模式下，也会输出到css文件中 test.styl文件内容 12345678910111213// 单行注释body&#123; background: white;&#125;/* 多行注释 */body&#123; background blue&#125;/*! 多行注释 */body background green 常规模式下输出 1234567891011body &#123; background: #fff;&#125;/* 多行注释 */body &#123; background: #00f;&#125;/* 多行注释 */body &#123; background: #008000;&#125; 压缩模式下输出 12body&#123;background:#fff&#125;body&#123;background:#00f&#125;/* 多行注释 */body&#123;background:#008000&#125; 2.2、变量变量在任何一个编程语言中，都是必不可少的。Stylus中也不例外。 Stylus的变量比较灵活，支持较多的变量名命名方式，如$abc、abc、_abc、-abc等等，但是从易读性上来说，建议大家使用abc或者是$abc（推荐）其一来作为变量名规则。 test.styl内容： 123456789101112131415161718192021/*! 变量 *//* 常规的表达式做变量名，用等号连接变量值 *///在Stylus中，可以使用$，_等前缀，但建议使用特定字符开头，来标识变量font-size = 14px;$font-size = 20px // 单行注释body&#123; background: white; font-size font-size font-size: $font-size width w = 100px height h = 100px //注意，此处表达式的括号不能少 margin-left -(w/2) margin-top -(h/2) //使用@符号引用同级的属性 margin-left -(@width/2) margin-top -(@height/2)&#125; 生成的CSS内容如下： 12345678910111213/* 变量 *//* 常规的表达式做变量名，用等号连接变量值 */body &#123; background: #fff; font-size: 14px; font-size: 20px; width: 100px; height: 100px; margin-left: -50px; margin-top: -50px; margin-left: -50px; margin-top: -50px;&#125; 更多变量使用，请查阅http://stylus-lang.com/docs/variables.html 2.3、选择器在编写CSS的过程中，我们用得最多的无非就是选择器了。我们来看看Stylus对选择器做了哪些扩展。 1234567891011121314151617181920212223242526272829303132333435363738394041424344/*! 选择器 *//* 1、选择器嵌套 */body background white .container background blue/* 2、引用直接父级别节点 */li &amp;:hover color blue/* 3、引用指定级别上层节点,个人觉得稍显复杂，不易懂，尽量少使用 */body color white li a color green ^[1]:hover color yellow/* 4、根节点引用，使用/将当前样式提升到第一层级 */body li / .test color white/* 5、使用../来回到上一层级 */body li ../ .test color yellow/* 6、使用selector()来构造选择器 */&#123;selector(&apos;.a&apos;, &apos;.b, .c&apos;)&#125; color white/* 7、选择器为变量，那么用&#123;&#125;包裹，属性也是 */$selector = &quot;.text-danger&quot;$font = font-family&#123;$selector&#125; &#123;$font&#125; &quot;微软雅黑&quot;/* 8、使用表达式 */exp_margin_pad(n) margin (- n)px body exp_margin_pad(10) 编译为CSS如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243/* 选择器 *//* 1、选择器嵌套 */body &#123; background: #fff;&#125;body .container &#123; background: #00f;&#125;/* 2、引用直接父级别节点 */li:hover &#123; color: #00f;&#125;/* 3、引用指定级别上层节点,个人觉得稍显复杂，不易懂，尽量少使用 */body &#123; color: #fff;&#125;body li a &#123; color: #008000;&#125;body li:hover &#123; color: #ff0;&#125;/* 4、根节点引用，使用/将当前样式提升到第一层级 */.test &#123; color: #fff;&#125;/* 5、使用../来回到上一层级 */body .test &#123; color: #ff0;&#125;/* 6、使用selector()来构造选择器 */.a .b,.a .c &#123; color: #fff;&#125;/* 7、选择器为变量，那么用&#123;&#125;包裹，属性也是 */.text-danger &#123; font-family: &quot;微软雅黑&quot;;&#125;/* 8、使用表达式 */body &#123; margin: -10px;&#125; 花样太多，就不一一例举了。不过，常用的没几个。个人最常用的仅仅是嵌套。 想了解更多，请参考： http://stylus-lang.com/docs/selectors.html 2.5、样式块Stylus的变量没有集合的概念，那么如果有一组样式要复用的时候，变量就有点捉襟见肘了。这个时候，我们可以采用block来实现一组样式的复用。 12345678910111213/*! 样式块，两种定义方式，推荐第二种，为了易读性 */font = font-family &quot;微软雅黑&quot; font-size 1remfont1 = @block&#123; font-family &quot;宋体&quot; font-size 14px;&#125; body &#123;font&#125; &#123;font1&#125; 编译结果为： 1234567/* 样式块，两种定义方式，推荐第二种，为了易读性 */body &#123; font-family: &quot;微软雅黑&quot;; font-size: 1rem; font-family: &quot;宋体&quot;; font-size: 14px;&#125; 2.6 样式继承在编写CSS的过程中，我们往往会发现新加的样式和之前已有的样式类有重复的部分，如果是原生CSS，那么我们又得拷贝一份样式出来。在Stylus中，大可不必如此麻烦。使用@extend很方便的就能解决这个问题。 123456789101112131415161718/*! 样式继承 */.btn border 1px solid red; border-radius 5px.btn-danger @extend .btn //继承.btn的样式 color red//如果不嫌输出.btn，我们只需要将btn做成占位选择器，如下$btn border 1px solid red; border-radius 5px .btn-info @extend $btn color purple 编译后为： 12345678910111213141516/* 样式继承 */.btn,.btn-danger &#123; border: 1px solid #f00; border-radius: 5px;&#125;.btn-danger &#123; color: #f00;&#125;.btn-info &#123; border: 1px solid #f00; border-radius: 5px;&#125;.btn-info &#123; color: #800080;&#125; 注意1：@extend和@extends完全相等，两者可以混用 注意2：@extend与Sass不同的地方，在于Stylus的@extend支持继承嵌套选择器 2.7、方法编程语言重要的一个特征就是函数，在Stylus中，也有函数的概念，函数的概念和Mixins比较类似，但是，函数还可以有返回值 123456789101112131415161718192021222324252627282930313233/*! 函数 */// 个人建议在定义函数时，以f_为前缀，方便识别f_plus(a, b) //简单函数 a + b f_plus2(a, b = a) //带默认值的函数 a + b + 0pxf_multireturn() //多返回值函数 5px 10px 15px 20px f_margin() //想要作为整体返回,为了消除歧义，建议使用rerurn和括号包裹返回值 return (5px 10px 5px 10px)f_test = f_margin //函数可以指定别名//和js雷同，函数可以作为参数传递f_fun1(a, b) a + b + 0pxf_fun2(a, b) a - b + 0pxf_invork(a, b, fn) fn(a, b) body margin-top f_plus(5, 10) margin-top f_plus(5px, 10) margin-top f_plus2(5) margin-top f_plus2(b: 10, a: 5) //命名参数传递 margin-bottom f_multireturn()[3] //取第四个值，下标从0开始 margin f_margin() width f_invork(100, 50, f_fun1) height f_invork(100, 50, f_fun2) 编译之后为： 1234567891011/* 函数 */body &#123; margin-top: 15; margin-top: 15px; margin-top: 10px; margin-top: 15px; margin-bottom: 20px; margin: 5px 10px 5px 10px; width: 150px; height: 50px;&#125; 3、未完，待续"},{"title":"01_认识Vue","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/Vue实践之路/01_认识Vue/","text":"0、关于VueVue 是当前非常流行的一款前端 MV 库（国人开发），结合 vue-router, vue-resource, vuex 等等，就形成了一套比较完善的前端 MV 开发框架。 与它非常相似的框架是 Avalon ，都借鉴了当前流行的前端 MV* 库、框架，都是基于 ES5 getter setter 实现双向绑定。 与 Avalon 相比， Vue 在稳定性和文档方面更胜一筹。 但 Avalon 利用 VBScript 在IE6+上实现了双向绑定，不过文档和稳定性稍微有些欠缺。 那么如果没有IE9-的兼容性要求，有需要产线环境，那么Vue就是非常合适的一个东西了。 1、配套工具Vue 本身仅仅是一个双向绑定，组件化的库，要实现一个完整的应用，那么还需要其他的一些配套工具。 实际上，在 Vue 发布到流行的这几年间，它的配套工具已经相当完善了。特别是 vue-cli，更是极大的减少了环境搭建的成本。 其他的路由，Ajax，数据流， vuejs组织 也都提供了相应的package来支撑。 路由 vue-router Ajax/HTTP vue-resource 数据流 vuex 2、开始一个项目如果有Angular等前端框架使用经验，那么可以很轻松的切入vue的使用，因为有太多的似曾相识。 另外，通过vue-cli，我们可以不用自己去搭建开发环境，几条命令就足以让我们能够看到一个能跑起来的完整项目。特别是还自带热更新，自动编译，自动刷新等强大的构建功能。 来领略一下vue的魅力吧： 12345678910111213141516// 全局安装vue-cli命令行工具$ npm install -g vue-cli // 在当前目录中创建一个demo1目录，并创建一个基于webpack的开发环境。//（该命令是向导式方式，可以设置一些属性）$ vue init webpack demo1 // vue-init &lt;template-name&gt; [project-name]// 进入真正的项目目录$ cd demo1 // 安装依赖，你懂的~$ npm install // 运行开发环境（注意：默认端口是8080，执行该命令后不会自动打开页面，// 需要打开浏览器手动输入 http://localhost:8080 ）$ npm run dev 仅仅有开发环境，你满足了么？反正我是不满足的，vue-cli 还提供了完善的命令，能够直接打包产线所需要的资源。 1$ npm run build // 生产环境打包 3、认识.vue.vue 是vue特有的一种文件格式，一个 .vue 文件也是一个独立的组件。 它把内部内容分为三块，样式，模板和逻辑（JS），逻辑部分原生支持 ES2015，简单的示例如下： 123456789&lt;style&gt; &lt;!-- 用于放置组件样式 --&gt;&lt;/style&gt;&lt;template&gt; &lt;!-- 用于放置组件模板 --&gt;&lt;/template&gt;&lt;script&gt; // 用于放置组件逻辑代码&lt;/script&gt; 其中的 style 标记，还可以使用 scoped 标记来生成模块化CSS，也可以使用 lang=&quot;&lt;lang&gt;&quot; 来选择使用一个CSS预处理器。 我喜欢的方式如下： 1&lt;style scoped lang=\"stylus\"&gt;&lt;/style&gt; 注意：如果选择了使用预处理器，那么需要安装特定的预处理器loader，如使用 npm install stylus-loader 来增加对 stylus 的支持。 4、其他主流MVVM框架性能比较"},{"title":"Angular再回首(2)-那些容易忽略的Component细节","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/Angular相关/Angular再回首(2)-那些容易忽略的Component细节/","text":"0、前言在 Angular 1.5.x 中，增加的组件方法，相当实用和易用。但也有许多小细节问题值得注意，以下为本人在组件实践过程中遇到的问题，或者是需要注意的小细节。 1、问题/小细节（需要注意的点）1.1、如何判断是否添加了可选的 transclude 元素？在很多时候，我们会给一个组件设定多个 transclude，可能其中有一部分是可选的，那如何判断可选的 transclude 被用户设置了值呢？ 此时，我们可以依靠 $transclude 来进行判断： 12345678910111213class XXXComponent&#123; constructor($transclude)&#123; this.$transclude = $transclude; &#125; $onInit()&#123; // 判断transclude是否存在 let transcludeName = 'xxx'; let hasXXX = this.$transclude.isSlotFilled(transcludeName); &#125;&#125;XXXComponent.$inject = ['$transclude']; 1.2、如何监控绑定属性的变更？属性绑定，分为一次性绑定(@)（也算是单向绑定），单向绑定(&lt;)，双向绑定(=)。 # 监控单向绑定属性 对于单向绑定的属性，可以通过生命周期钩子 $onChanges(changesObj) 来进行监控。 12345class XXXController&#123; $onChanges(changesObj)&#123; console.log(changesObj); &#125;&#125; 其中参数 changesObj 是所有变更属性的一个汇总，数据结构如下： 1234567changesObj = &#123; key1: &#123; // 有变更的绑定属性 currentValue: any // 当前值 （变化后的值） previousValue: any // 上一次的值 （变化前的值） isFirstChange(): fn // 方法，用于判断是否是第一次变更。 &#125;&#125; 注意：$onChanges 无法监控双向绑定属性，切记！ # 监控双向绑定 由于 $onChanges 无法监控双向绑定属性，那么我们就必须另外想办法来进行监控，可以有以下几种方案： 方案一：利用 $interval 既然是双向绑定，那么肯定变化是直接生效的，关键就在于我们无法监视到，这个时候我们可以利用 $interval 来实现定时监控。 123456789101112131415161718192021222324class XXXController&#123; constructor($interval)&#123; this.$interval = $interval; this.init(); &#125; init()&#123; let previousValue = null; this.$interval(() =&gt; &#123; if(previousValue !== this.value)&#123; previousValue = this.value; console.log('value changed'); &#125; &#125;, 200); &#125;&#125;XXXController.$inject = ['$interval'];angular.module('xxx').component('xxx', &#123; bindings: &#123; value: '=' &#125;, controller: XXXController, controllerAs: 'vm'&#125;); 优点： 易于理解 缺点： 浪费资源 需要自己书写逻辑 推荐指数： ☆ 方案二：利用 $scope.$watch(keyString) 组件也有独立的 $scope，那么借助 $scope.$watch 也可以实现监听属性变化，代码如下： 1234567891011121314151617181920class XXXController&#123; constructor($scope)&#123; this.$scope = $scope; this.init(); &#125; init()&#123; this.$scope.$watch('vm.value', (newVal, oldVal) =&gt; &#123; console.log('value changed); &#125;); &#125;&#125;XXXController.$inject = ['$scope'];angular.module('xxx').component('xxx', &#123; bindings: &#123; value: '=' // 双向绑定属性 &#125;, controller: XXXController, controllerAs: 'vm'&#125;); 优点： 使用简单 缺点： 字符串形式的 $watch,依赖 controllerAs,不易理解 实质仍然是定时器，只不过是使用的 angular 自身的 $diget 循环 推荐指数： ☆☆ 方案三：利用 $scope.$watch(fn) $scope.$watch 也接受函数类型的参数，相对于字符串形式，没有 controllerAs 的相关性，而且更灵活，代码如下： 1234567891011121314151617181920class XXXController&#123; constructor($scope)&#123; this.$scope = $scope; this.init(); &#125; init()&#123; this.$scope.$watch(() =&gt; this.value, (newVal, oldVal) =&gt; &#123; console.log('value changed); &#125;); &#125;&#125;XXXController.$inject = ['$scope'];angular.module('xxx').component('xxx', &#123; bindings: &#123; value: '=' // 双向绑定属性 &#125;, controller: XXXController, controllerAs: 'vm'&#125;); 优点： 使用简单 缺点： 实质仍然是定时器，只不过是使用的 angular 自身的 $diget 循环 推荐指数： ☆☆☆☆ 方案四：利用 getter &amp; setter 因为我们使用了 ES6 Class，那么 ES6 的 getter setter 特性，我们也是能够使用的，方式如下： 12345678910111213141516171819class XXXController&#123; set value(val)&#123; this._value = val; console.log('value changed'); &#125; get value()&#123; return this._value; &#125;&#125;XXXController.$inject = [];angular.module('xxx').component('xxx', &#123; bindings: &#123; value: '=' // 双向绑定属性 &#125;, controller: XXXController, controllerAs: 'vm'&#125;); 优点： 没有额外的开销，性能高 缺点： 使用相对较为复杂 推荐指数： ☆☆☆☆"},{"title":"Angular开发Tips","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/Angular相关/Angular开发Tips/","text":"1、在使用$routeProvider的时候，需要让模块依赖ngRoute，否则会提示找不到服务，示例： angular.module(&apos;module1&apos;, [&apos;ngRoute&apos;]) .config([&apos;$routeProvider&apos;, function($routeProvider){ //do something... }]); 2、在页面中需要绑定有风险的html的时候，可以使用 ng-bind-html=&quot;html&quot;（version&gt;=1.3）,如果遇到错误，控制器中可以使用html = $sce.trustHtml(unsafeHtml)。 3、 如何动态的向页面添加带指令的HTML？通入如下代码： $compile(html)($scope); 4、如果阻止事件冒泡？示例如下： //方式一，利用一个自定义指令实现 .directive(&apos;stopEventPropagation&apos;, function(){ return { restrict: &apos;A&apos;, link: function(scope, iElement, iAttrs){ //通过获取事件对象，来阻止调用 iElement.bind(&apos;click&apos;, function(e){ e.stopPropagation(); }); } } }); &lt;a stop-event-propagation ng-click=&quot;doSomething();&quot;&gt;Click me&lt;/a&gt; //方式二，直接引用$event对象 &lt;a ng-click=&quot;doSomething(); $event.stopPropagation();&quot;&gt;Click me&lt;/a&gt; 5、关于$route和$location的事件顺序，如下： $routeChangeStart -&gt; $locationChangeStart -&gt; $locationChangeSuccess -&gt; $routeChangeSuccess 6、有关select标签的使用，当options的来源是ajax时，那么如果指定选中项呢？如下： &lt;select ng-options=&quot;sysOptions&quot; ng-model=&quot;selectSystem&quot;&gt;&lt;/select&gt; //如上HTML代码，如果sysOptions来自ajax请求，而selectSystem又不是的话，往往会选中一个空值。 //可以使用如下方式避免： 1234567.controller('TestCtrl', ['$scope', '$http', function($scope, $http)&#123; $http.get(url).success(function(data)&#123; $scope.sysOptions = data; //在异步回调函数中，对ng-model赋值。 $scope.selectSystem = 'Test'; &#125;);&#125;]); 7、在编写指令时，属性的匹配大小写需要注意：如果在html中使用 showName=&quot;xx&quot;,那么在指令的iAttrs中，应该使用 showname 获取。如果要在指令中使用showName获取的话，那么必须在html中使用 show-name=&quot;xx&quot;。 8、要生成安全链接时，需要修改配置，代码如下： 12需要将如下代码： ng-href=\"&#123;&#123;true: 'javascript:void(0);' : 'url'&#125;&#125;\" 生成为： href=\"javascript:void(0);\" 123.config(['$compileProvider', function($compileProvider)&#123; $compileProvider.aHrefSanitizationWhitelist(/^\\s*(https?|ftp|mailto|file|javascript):/)&#125;]); 9、在ng-click等ng事件中，如果拿到事件源对象？如下： &lt;a ng-click=\"click($event);\" /&gt; $scope.click = function($event){ var target = $event.target; }; //注意，如果使用ng-click=\"click($event.target)\"，将会导致angular解析错误。 10、判断angular的模块是否存在，可以使用如下代码： var isAngularModuleExists = function(moduleName){ try{ angular.module(moduleName) }catch{ return false } return true; }; 11、在使用coffee编写使用provider方式编写服务时，当心写在最后的this.$get，coffee会将最后一句编译为return this.$get，而这刚好不符合provider的要求，所以应该在末尾手动加上return或者放置一个undefined在最后，放置编译出return this.$get这样的代码。 12、如果要动态控制是否启用非空验证，可以使用ng-required=”true|false”指令。 13、当心ng-if指令，在使用ng-if指令时，会创建独立的作用域，如果要在$scope监视ng-if包含的变量，那么是无法成功的。如果一定要监视，可以考虑使用ng-show。 14、注意.value()与.constant的区别，前者只能注入和用于服务或者控制器中，后则可以被注入到配置(.config([‘xx’]))中。"},{"title":"Angular再回首(3)-我们来实现一个组件","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/Angular相关/Angular再回首(3)-我们来实现一个组件/","text":"0、前言前两文写了 Component 的一些方面，但没有一个比较线性的串联关系，本文，就来从一个实例出发，来尝试概括一个组件的方方面面。 1、2、组件实现2.1、先整一个组件12angular.module('app', []) .component('finalComponent', &#123;&#125;); 这个组件啥都不干，就提供了一个新的标签，显得毫无意义，但是我们可以从这里看到如何定义一个组件。 注意：组件名称，请使用小驼峰命名法，在HTML中，请使用连字符+小写字母，这种实现是为了处理js和html大小写敏感的差异(js区分大小写，html不区分) 注意2：如果在组件标签中，嵌入有效的标签，是会显示出来的，如下： 123&lt;final-component&gt; &lt;h1&gt;Hello&lt;/h1&gt;&lt;/final-component&gt; 会显示出大号的 “Hello”。 2.2、带模板的组件接着，来实现一个有意义的组件，比如我要渲染一个特定的字符串，代码如下： 1234angular.module('app', []) .component('finalComponent', &#123; template: '&lt;h1&gt;Hello World.&lt;/h1&gt;' &#125;); 现在我们再使用：&lt;final-component&gt;ABC&lt;/final-component&gt;，则会显示 “Hello World” 内容了。 注意：当组件指定了模板属性后，其内部的标签，将不会生效（transclude除外，） 2.3、复杂模板的组件以上，我们已经实现了带模板的组件，可是我们的模板可能会比较复杂，这个时候直接写 template 就不太好用了,此时，我们会考虑把模板拆分到一个独立的 .html 文件中，代码如下： 12&lt;!-- 组件模板内容(文件名为:template.html) --&gt;&lt;h1&gt;Hello World.&lt;/h1&gt; 然后，使用 templateUrl 属性进行关联 1234angular.module('app', []) .component('finalComponent', &#123; templateUrl: '/app/template.html' &#125;); 该代码可以达到 2.2 同样的效果，只是把模板内容拆分到独立文件中了。 注意：模板路径可以是相对路径，也可以是绝对路径，需要注意路径的写法，否则会出现找不到模板 注意2：如果使用 gulp 构建，可以考虑使用 gulp-angular-embed-templates 将独立的模板文件，打包到组件中。 2.4、组件属性绑定之前实现的组件，感觉太死板了，我想改下文字，都不好实现（你非要用js强制操作dom，我拿你也没办法，不过后果自负），这个时候，我们迫切的需要能给组件传递参数。 Angular 组件中，有多个参数传递方式，如下： @ 单向绑定字符串（原值绑定） - 传什么就是什么，不做任何处理 &lt; 单向绑定变量（取scope的值绑定） - 传的值会先用 $scope 转换，把结果传递给组件 = 双向绑定 - 组件内外变化都会通知另一方 2.4.1 直接传递字符串参数使用 @ 进行单向字符串绑定 1234567angular.module('app', []) .component('finalComponent', &#123; templateUrl: '/app/template.html' bindings: &#123; name: '@' &#125; &#125;); 12345&lt;!-- 模板内容 --&gt;&lt;h1&gt;Hello &#123;&#123;$ctrl.name&#125;&#125;.&lt;/h1&gt;&lt;!-- 使用组件 --&gt;&lt;final-component name=\"Jay\"&gt;&lt;/final-component&gt; 此时，将会显示“Hello Jay”，可以看到，设定的参数值会原样显示了。 注意：在模板中，要使用变量，需要加$ctrl前缀，先这样用着，后面会提到 2.4.2 使用单向绑定变量1234567891011121314class TestController&#123; constructor()&#123; this.name = 'Jay' &#125;&#125;TestController.$inject = []; // 依赖angular.module('app', []) .component('finalComponent', &#123; templateUrl: '/app/template.html' bindings: &#123; name: '&lt;' &#125; &#125;) .controller('TestController', TestController); 1234567&lt;!-- 模板内容 --&gt;&lt;h1&gt;Hello &#123;&#123;$ctrl.name&#125;&#125;.&lt;/h1&gt;&lt;!-- 使用组件 --&gt;&lt;div ng-controller=\"TestController as t\"&gt; &lt;final-component name=\"t.name\"&gt;&lt;/final-component&gt;&lt;/div&gt; 此时，也将会显示“Hello Jay”，可以看到，此时 t.name 会拿到 $scope 中进行解析。 注意：推荐使用 controller as 写法 2.4.3 双向绑定1234567891011121314class TestController&#123; constructor()&#123; this.name = 'Jay' &#125;&#125;TestController.$inject = []; // 依赖angular.module('app', []) .component('finalComponent', &#123; templateUrl: '/app/template.html' bindings: &#123; name: '=' &#125; &#125;) .controller('TestController', TestController); 1234567891011&lt;!-- 模板内容 --&gt;&lt;h1&gt; &lt;h1&gt;Hello &#123;&#123;$ctrl.name&#125;&#125;.&lt;/h1&gt; &lt;input ng-model=\"$ctrl.name\"&gt;&lt;/input&gt;&lt;/h1&gt;&lt;!-- 使用组件 --&gt;&lt;div ng-controller=\"TestController as t\"&gt; &lt;final-component name=\"t.name\"&gt;&lt;/final-component&gt; &lt;h3&gt;&#123;&#123;t.name&#125;&#125;&lt;/h3&gt;&lt;/div&gt; 此时，在文本框输入值之后，可以看到组件内外都会及时变更。"},{"title":"HTML5探索一（那些新增的标签和属性）","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/从零开始H5/HTML5探索一（那些新增的标签和属性）/","text":"html5相比html4，添加了部分语义化的标签和属性，现在我们就从这些标签和属性开始，学习html5吧。 首先，认识下HTML5新的文档类型： &lt;!DOCTYPE html&gt; 那些新标签格式 &lt;bdi&gt; 定义文本的文本方向，使其脱离其周围文本的方向设置 &lt;mark&gt; 定义有记号的文本 &lt;meter&gt; 定义预定义范围内的度量 &lt;progress&gt; 定义任何类型的任务的进度 &lt;rp&gt; 定义若浏览器不支持ruby元素显示的内容 &lt;rt&gt; 定义ruby注释的解释 &lt;ruby&gt; 定义ruby注释 &lt;time&gt; 定义日期/时间 &lt;wbr&gt; 强制定义换行点 HTML： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;HTML5 Test Page 1&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;&lt;bdi&gt;BDI:在发布用户评论或其他您无法完全控制的内容时，该标签很有用 test&lt;/bdi&gt;&lt;/div&gt; &lt;hr /&gt; &lt;div&gt;&lt;mark&gt;Mark:定义带有记号的文本&lt;/mark&gt;&lt;/div&gt; &lt;hr /&gt; &lt;div style=&quot;width:200px;border:1px solid red;&quot;&gt;&lt;meter value=&quot;10&quot; /&gt;Meter&lt;/div&gt; &lt;hr /&gt; &lt;div&gt;&lt;progress value=&quot;10&quot; max=&quot;100&quot;&gt;&lt;/progress&gt;Progress: 用于显示进度，结合JS一同使用&lt;/div&gt; &lt;hr /&gt; &lt;div&gt;我在 &lt;time datetime=&quot;2008-02-14&quot;&gt;情人节&lt;/time&gt; 有个约会 &lt;mark&gt;该标签不会再在任何浏览器中呈现任何特殊效果，仅仅方便搜索引擎生成更智能的结果&lt;/mark&gt; &lt;/div&gt; &lt;hr /&gt; &lt;div&gt; &lt;p&gt;如果想学习 AJAX，那么您必须熟悉 XML&lt;wbr&gt;Http&lt;wbr&gt;Request 对象。&lt;/p&gt; &lt;mark&gt;wbr可强制设置换行点&lt;/mark&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 表单 &lt;datalist&gt; 定义下拉列表 &lt;keygen&gt; 定义生成密钥 &lt;output&gt; 定义输出的一些类型 HTML： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;HTML5 Test Page 2&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form method=&quot;post&quot;&gt; &lt;p&gt;datalist:和input元素配合，用于定义input可能的值&lt;/p&gt; &lt;input id=&quot;lang&quot; list=&quot;dl&quot; /&gt; &lt;datalist id=&quot;dl&quot;&gt; &lt;option value=&quot;C#&quot; /&gt; &lt;option value=&quot;Java&quot; /&gt; &lt;option value=&quot;PHP&quot; /&gt; &lt;/datalist&gt; &lt;hr /&gt; &lt;p&gt;keygen:提交密钥串到服务器&lt;/p&gt; Username: &lt;input type=&quot;text&quot; name=&quot;usr_name&quot; /&gt; Encryption: &lt;keygen name=&quot;security&quot; /&gt; &lt;input type=&quot;submit&quot; /&gt; &lt;hr /&gt; &lt;/form&gt; &lt;p&gt;output:定义不同类型的输出&lt;/p&gt; &lt;form oninput=&quot;x.value=parseInt(a.value)+parseInt(b.value)&quot;&gt; 0 &lt;input type=&quot;range&quot; id=&quot;a&quot; value=&quot;50&quot;&gt;100 +&lt;input type=&quot;number&quot; id=&quot;b&quot; value=&quot;50&quot;&gt; =&lt;output name=&quot;x&quot; for=&quot;a&quot;&gt;&lt;/output&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 图像 &lt;canvas&gt; 定义图形 &lt;figcaption&gt; 定义figure元素的标题 &lt;figure&gt; 定义媒介内容的分组，以及它们的标题 HTML： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;HTML5 Test Page 3&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;p&gt;canvas:你懂的，画布，各种绚丽效果就靠它了。&lt;/p&gt; &lt;canvas id=&quot;c&quot;&gt;&lt;/canvas&gt; &lt;script&gt; var canvas=document.getElementById(&apos;c&apos;); var ctx=canvas.getContext(&apos;2d&apos;); ctx.fillStyle=&apos;#FF0000&apos;; ctx.fillRect(0,0,80,100); &lt;/script&gt; &lt;/div&gt; &lt;hr /&gt; &lt;div&gt; &lt;p&gt; figure: 规定独立的流内容（图像、图表、照片、代码等等），figure 元素的内容应该与主内容相关，但如果被删除，则不应对文档流产生影响。 &lt;br /&gt; figcaption:定义 figure 元素的标题，语义化&lt;/p&gt; &lt;figure&gt; &lt;figcaption&gt;黄浦江上的的卢浦大桥&lt;/figcaption&gt; &lt;img src=&quot;https://encrypted-tbn2.gstatic.com/images?q=tbn:ANd9GcSehM_6Bfd79RwCCy1wNj_K6YGEkMsdt0Gekn10Dc6xJ8nxDcS7rg&quot; width=&quot;350&quot; height=&quot;234&quot; /&gt; &lt;/figure&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 音频/视频 &lt;audio&gt; 定义声音内容 &lt;source&gt; 定义媒介源 &lt;track&gt; 定义用在媒体播放器中的文本轨道 &lt;video&gt; 定义视频 链接 &lt;nav&gt; 定义导航链接 列表 &lt;command&gt; 定义命令按钮 –注：现在浏览器暂时都不支持 样式/节 – 语义化标签 &lt;header&gt; 定义section或page的页眉 &lt;footer&gt; 定义section或page的页脚 &lt;section&gt; 定义section &lt;article&gt; 定义文章 &lt;aside&gt; 定义页面内容之外的内容 &lt;details&gt; 定义元素细节 &lt;dialog&gt; 定义对话框或窗口 &lt;summary&gt; 为&lt;details&gt;元素定义可见的标题 编程&lt;embed&gt; 为外部应用程序（非HTML）定义容器 那些新属性 contenteditable 规定元素内容是否可编辑 contextmenu 规定元素的上下文菜单。上下文菜单在用户点击元素时显示 data-* 用于存储页面或应用程序的私有定制数据 draggable 规定元素是否可拖动 dropzone 规定在拖动被多动数据时是否进行复制、移动或链接 hidden 规定元素仍未或不再相关 spellcheck 规定是否对元素进行拼写和语法检查 translate 规定是否应该翻译元素内容 以上全局属性可用于任何HTML元素 参考资料 http://www.w3schools.com/tags/"},{"title":"Angular1.x升级指南","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/Angular相关/Angular1.x升级指南/","text":"0、导言Angular从1.2.x到1.3.x是一个大的跳跃。在1.3.x之后，也有1.4.x，1.5.x这么两个大版本。 Newkit从1.2.x跳跃到1.3.x经历过一次大的变化，在之后的较大版本升级中，基本上没有大多大改动。但是其中的差异点，我们也需要去了解。 1.3.x以前的版本，我们就不去深究了，毕竟现在不是主流，我们就从1.3.x开始，来看看Angular到底有了哪些变化。 1、从1.3.x到1.4.x从1.3到1.4，Angular的变化涉及到很多个方面，一一列举如下。 1.1、动画在1.4中，动画功能进行了很大的重构，但是API基本保持一致。在新的版本中，我们通过注入 $animationCss 来实现用JS创建CSS动画。 1.1.1、定义CSS动画如下： 123456789101112131415161718192021angular.module('app', ['ngAnimate']) .animation('.slide-animation', ['$animateCss', function ($animateCss) &#123; return &#123; enter: function (element, doneFn) &#123; var animation = $animateCss(element, &#123; from: &#123; background: 'black' &#125;, to: &#123; background: 'blue' &#125;, duration: 10 // one second &#125;); animation.start().done(doneFn); &#125;, leave: function(element, doneFn)&#123; var animation = $animateCss(element, &#123; from: &#123; fontSize: '12px' &#125;, to: &#123; fontSize: '25px' &#125;, duration: 10 // one second &#125;); animation.start().done(doneFn); &#125; &#125; &#125;]); 如何使用？ 1&lt;div class=\"test slide-animation\" ng-if=\"vm.ck1\"&gt; AAAAAAAAAAA&lt;/div&gt; 只需要在元素上设置一个class，然后当元素从隐藏到显示，则会执行 enter 动画，从显示到隐藏，则会执行 leave 动画。 1.1.2、监听动画事件 1234567891011// &lt; 1.4element.on('$animate:before', function(e, data) &#123; if (data.event === 'enter') &#123; ... &#125;&#125;);element.off('$animate:before', fn);// 1.4+$animate.on('enter', element, function(data) &#123; //...&#125;);$animate.off('enter', element, fn); 在1.4版本之前，我们需要通过在element上去监听动画开始和结束，另外还必须要通过 data.event 来判断动画类型。 在1.4及以后，我们可以直接通过 $animate 来监控了。 1.1.3、触发动画 1234var $el = $('.slide-animation');$animate.enter($el, $el.parent()).then(function()&#123; console.log('enter');&#125;); 我们需要使用如上的方式，来手动启动动画，此时会触发元素的对应动画事件。 注意：触发动画的回调中，如果要操作$scope,在&lt;1.4中会失败，需要借助$apply，但在1.4+，就不需要了。示例如下： 12345678910$animate.enter(element, elementParent).then(function() &#123; $scope.$apply(function() &#123; $scope.explode = true; &#125;);&#125;);// 1.4+$animate.enter(element, elementParent).then(function() &#123; $scope.explode = true;&#125;); 1.1.4、启用/禁用动画 12345// &lt; 1.4$animate.enabled(false, element);// 1.4+$animate.enabled(element, false); 实现该操作的方法参数1.4+刚好和小于1.4相反。 1.2、表单1.2.1、ngMessages 12345678910&lt;!-- AngularJS 1.3.x --&gt;&lt;div ng-messages=\"model.$error\" ng-messages-include=\"remote.html\"&gt; &lt;div ng-message=\"required\"&gt;Your message is required&lt;/div&gt;&lt;/div&gt;&lt;!-- AngularJS 1.4.x --&gt;&lt;div ng-messages=\"model.$error\"&gt; &lt;div ng-message=\"required\"&gt;Your message is required&lt;/div&gt; &lt;div ng-messages-include=\"remote.html\"&gt;&lt;/div&gt;&lt;/div&gt; 在1.3版本中，ng-messages-include 跟随在 ng-messages 元素上，这样并不灵活。 在1.4+中，ng-messages-include 不允许更随在 ng-messages 元素上，必须放在内部，这样使得使用远程模板非常灵活。 另外，当存在多个form时，我们在使用ng-messages获取指定form的方法也有变化，如下： 12345678// &lt; 1.4&lt;div ng-messages=\"ctrl.form['field_&#123;&#123;$index&#125;&#125;'].$error\"&gt;...&lt;/div&gt;// 1.4 + &lt;div ng-messages=\"ctrl.getMessages($index)\"&gt;...&lt;/div&gt;ctrl.getMessages = function($index) &#123; return ctrl.form['field_' + $index].$error;&#125; 1.2.2、ngOptions ngOptions仅仅只是内部实现变化，在使用上并没有多大差异。其中当遍历Object时，之前的版本是用的 for in，导致输出的key是字符序的。新版本采用 Object.keys，输出的key是定义时候的顺序。 另外当ngOptions表达式执行之后，将不会再触发ngOptions了。 1.2.3、select 在 select 元素中，这是一个非常大的变更。简单理解，如下：在1.3中，ngModel和&lt;option&gt;的value比较仅仅是 ==，所以 200 == &#39;200&#39; //true。在1.4+中，比较方式成了 ===,所以 200 === &#39;200&#39; //false。 这个时候我们可以通过如下方式处理： 1234567ngModelCtrl.$parsers.push(function(value) &#123; return parseInt(value, 10); // Convert option value to number&#125;);ngModelCtrl.$formatters.push(function(value) &#123; return value.toString(); // Convert scope value to string&#125;); 实现指令如下： 1234567891011121314app.directive('convertNumber', function() &#123; return &#123; require: 'ngModel', link: function(scope, el, attr, ctrl) &#123; ctrl.$parsers.push(function(value) &#123; return parseInt(value, 10); &#125;); ctrl.$formatters.push(function(value) &#123; return value.toString(); &#125;); &#125; &#125;&#125;); 当然，如果我们保证ngModel的值为string类型，那就没啥问题了（在不使用ng-value的情况下）。 1.2.4、Form 表单的变化，主要是name属性，在 &lt; 1.4 的版本中，我们可以设置name为 “my:form1”，在1.4+版本中，不在允许这种特殊的用法。 1.3、模板相关1.3.1、ngRepeat &lt; 1.4 版本中，ng-repeat的遍历顺序是字母序。 1.4+版本中，顺序是有浏览器的 for in 来返回的。 1.3.2、ngInclude 123456789101112131415161718192021// &lt; 1.4&lt;div ng-include=\"findTemplate('https://example.com/templates/myTemplate.html')\"&gt;&lt;/div&gt;$scope.findTemplate = function(templateName) &#123; return $sce.trustAsResourceUrl(templateName);&#125;;// 1.4+var templateCache = &#123;&#125;;$scope.findTemplate = function(templateName) &#123; if (!templateCache[templateName]) &#123; templateCache[templateName] = $sce.trustAsResourceUrl(templateName); &#125; return templateCache[templateName];&#125;;// Orangular.module('myApp', []).config(function($sceDelegateProvider) &#123; $sceDelegateProvider.resourceUrlWhitelist(['self', 'https://example.com/templates/**'])&#125;); 1.4、Cookie在1.4+中，cookie增加了新的API： 123456getputgetObjectputObjectgetAllremove 另外，$cookieStore 将不推荐使用。 1.5、HTTP在1.4+中，$http的 transformRequest 将不允许修改请求header。但是我们可以使用如下方式进行动态的header设置： 1234567$http.get(url, &#123; headers: &#123; 'X-MY_HEADER': function(config) &#123; return 'abcd'; //you've got access to a request config object to specify header value dynamically &#125; &#125;&#125;) 1.6、Filterfliter如果作用在非数组上，将会抛出一个异常，之前则是返回一个空数组。 limitTo作用在不合法的value上，现在将会原样返回，之前是返回空对象，空数组。 2、从1.4.x到1.5.x从 1.4.x 到 1.5.x 是一个为升级ng2做准备的变更版本。 该版本主要是增加了一些功能，所以从1.4.x升级到1.5.x基本不需要太大的改动。 在 1.5.x 版本中，增加了一些接近ng2的新特性，如： angular.component() //一种偏向于angular2风格的组件（特殊的指令） $onInit //生命周期钩子 ngAnimateSwap // ngAnimate中一个新的指令 接着，我们来看下它的一些具体变更。 2.1、Core2.1.1、$parse $parse 增加新特性，可以使用locals来覆盖原本的context。用法如下： 12345var context = &#123; user: &#123; name: 'Jay' &#125; &#125;;var locals = &#123; user: &#123; name1: 'Local Jay' &#125; &#125;;var getter = this.$parse('user.name');console.log(getter(context)); // 'Jay'console.log(getter(context, locals)); // 'Local Jay' 2.1.2、ngOptions 如果元素上有 ngOptions 指令，那么 ngModel 指令也必须存在，否则就会抛出错误。 另外 ngOptions 接受假值（’’, 0, false, null） 2.1.3、orderBy 对 undefined 或者 null 进行 orderBy 将会抛出错误。 2.2、ngAria取消了部分元素的可访问性设置。 2.3 ngMessages将 ngMessages 指令的优先级设置为1，如果有优先级低于1的指令有transclude功能，那么需要设置为更高的优先级。 2.4、ngResource$resource 增加了 $cancelRequest() 方法。 2.5、ngRoute增加了 $resolveAs 配置属性，允许对 $resolve 指定别名。 2.6、ngTouch默认禁用了 ngClickOverrideEnabled，在触摸屏上，可能还有300ms的延迟。 如果要启用，那么可以使用如下方式： 123angular.module('myApp').config(function($touchProvider) &#123; $touchProvider.ngClickOverrideEnabled(true);&#125;); 另外，建议使用FastClick来实现该功能。 需要注意，某些现代浏览器在某些场景下已经删除了300ms延迟： Chrome 和 Firefox for Android 发现设置了 &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt; 将会删除300ms延迟。 IE当设置 touch-action 为 none 或者 manipulation 移除延迟。 注意：这些变化并不影响ngSwipe指令。 3、总结Angular1.x基本已经进入维护期了，很少会有新特性加入了。现在的重心在angular2，所以我们也可以优先对angular2做一些技术储备。"},{"title":"Angular从0到1：function（下）","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/Angular相关/Angular从0到1：function（下）/","text":"1、前言2、function（下）2.13、angular.isArray(★★)angular.isArray用于判断对象是不是数组，等价于Array.isArray console.log(angular.isArray([])); // true console.log(angular.isArray({0: &apos;1&apos;, 1: &apos;2&apos;, length: 2})); // false 2.14、angular.isDate(★★)通过判断toString.call(value)是不是等于’[object Date]’ 来判断对象是个是一个Date对象. console.log(angular.isDate(new Date())); // true console.log(angular.isDate(223)); // false 2.15、angular.isDefined(★★)判断对象或者属性是否定义 var obj = {a: 1, b: null, c: undefined}; console.log(angular.isDefined(obj.a)); // true console.log(angular.isDefined(obj.b)); // true console.log(angular.isDefined(obj.c)); // false console.log(angular.isDefined(obj.d)); // false 2.16、angular.isElement(★★)此方法判断元素是不是一个元素（包含dom元素，或者jquery元素） console.log(angular.isElement(document.getElementsByTagName(&apos;body&apos;)[0])); // true console.log(angular.isElement($(&apos;body&apos;))); // true 2.17、angular.isFunction(★★)此方法判断对象是不是一个function ，等价于 typeof fn === ‘function’ console.log(angular.isFunction(new Function(&apos;a&apos;, &apos;return a&apos;))); // true console.log(angular.isFunction(function(){})); // true console.log(angular.isFunction({})); // false 2.18、angular.isNumber(★★)判断数字是否为number function isNumber(value) { return typeof value === &apos;number&apos;; } 2.19、angular.isObject(★★)function isObject(value) { return value !== null &amp;&amp; typeof value === &apos;object&apos;; } 2.20、angular.isString(★★)function isString(value) { return typeof value === &apos;string&apos;; } 2.21、angular.isUndefined(★★)function isUndefined(value) { return typeof value === &apos;undefined&apos;; } 2.22、angular.lowercase(★★)转换字符串为小写模式，如果参数不是字符串，那么原样返回 var lowercase = function(string) { return isString(string) ? string.toLowerCase() : string; }; console.log(angular.lowercase(1)); // 1 console.log(angular.lowercase(&apos;ABCdef&apos;)); // &apos;abcdef&apos; 2.23、angular.uppercase(★★)转换字符串为大写模式，如果参数不是字符串，那么原样返回 var uppercase = function(string) { return isString(string) ? string.toUpperCase() : string; }; console.log(angular.uppercase(1)); // 1 console.log(angular.uppercase(&apos;ABCdef&apos;)); // &apos;ABCDEF&apos; 2.24、angular.merge(★★)将多个对象进行深度复制，与extend()不同，merge将会递归进行深度拷贝。该拷贝是完全深拷贝，就连对象引用也不一样。 var o = {}; var obj1 = {a1: 1, a2: 2, a3: [1]}; var obj2 = {b1: [2], b2: /abc/}; var obj3 = [o]; var obj4 = {d: o}; var result = angular.merge({}, obj1, obj2, obj3); console.log(result); console.log(result[0] === o); // false console.log(result.d === o); // false 2.25、angular.noop(★★)一个空函数，调试时非常有用。可以避免callback未定义引发的error。 function foo(callback) { var result = calculateResult(); (callback || angular.noop)(result); } 2.26、angular.reloadWithDebugInfo(★★)启用DebugInfo，该设置优先级高于$compileProvider.debugInfoEnabled(false)"},{"title":"Ajax","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/jQuery拆解/Ajax/","text":"0、AjaxjQuery Ajax 在 jQuery 中是一个非常重要的部分。"},{"title":"02_Angular2组件生命周期","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/Angular2一路向前/02_Angular2组件生命周期/","text":"0、Angular2 组件Angular1并不是围绕组件的概念来实现的。所以，我们需要controller、$scope，同时也需要封装自定义指令。 在Angular2中，把之前的这些东西都丢弃了，使用了一种更面向对象的组件模型。 一个组件控制着我们称之为View的显示部分。组件同时也是自描述的。 在Angular2中，指令也是存在的，组件只是指令的一种。 1、定义一个组件最基本的组件只需要提供一个selector和template就足够了。代码如下： 123456789101112131415161718192021222324252627282930313233343536import &#123;Component&#125; from 'angular2/core';@Component(&#123; selector: 'basic-info', template: '&lt;h1&gt;Basic Info&lt;/h1&gt;'&#125;)export class AboutComponent&#123; constructor() &#123; &#125;&#125;``` 要实现输入和输出呢？```javascriptimport &#123;Component, Input, Output, EventEmitter&#125; from 'angular2/core';@Component(&#123; selector: 'basic-info', template: ` &lt;h1&gt;Basic Info, &#123;&#123;abc&#125;&#125;&lt;/h1&gt; &lt;input type=\"text\" [(ngModel)]=\"abc\"&gt; `&#125;)export class BasicInfo&#123; @Input('test') set value(val)&#123; this.abc = val; this.callback.next([val]); &#125; @Output('callback') callback = new EventEmitter(); constructor()&#123; this.abc = 'aaaa'; &#125;&#125; 如何使用？ 12&lt;input type=\"text\" [(ngModel)] = \"value\"&gt;&lt;basic-info [test]=\"value\" (callback)=\"innerCallback($event)\"&gt;&lt;/basic-info&gt; 2、组件生命周期Angular2会管理组件的整个生命周期，包括组件的创建、渲染、子组件的创建和渲染、数据绑定属性变化时的校验、从DOM移除之前的销毁等等。 那如果我们想在某个状态时，进行一些操作应该怎么办呢？Angular2提供了组件生命周期的钩子，供我们在这些时间点添加自定义的操作。 在angular2/core中提供了多个Lifecycle Hook接口，我们可以实现一个或多个接口，来设置自定义操作。每一个接口，都会有一个钩子方法，钩子方法的名称是接口的名称加上前缀ng。如OnInit的钩子方法如下： 123456789101112131415161718192021222324import &#123;Component, Input, Output, EventEmitter&#125; from 'angular2/core';@Component(&#123; selector: 'basic-info', template: ` &lt;h1&gt;Basic Info, &#123;&#123;abc&#125;&#125;&lt;/h1&gt; &lt;input type=\"text\" [(ngModel)]=\"abc\"&gt; `&#125;)export class BasicInfo&#123; @Input('test') set value(val)&#123; this.abc = val; this.callback.next([val]); &#125; @Output('callback') callback = new EventEmitter(); constructor()&#123; this.abc = 'aaaa'; &#125; // 组件Init时创建 ngOnInit()&#123; console.log('basic info init.'); &#125;&#125; 生命周期钩子（组件和指令都有的） ngOnInit //组件初始化，在Angular初始化数据绑定输入属性之后 ngOnChanges // ngDoCheck ngOnDestroy 生命周期钩子（组件特有的） ngAfterContentInit // Angular将外部内容放入视图后 ngAfterContentChecked // 在Angular检测放到视图内的外部内容的绑定后 ngAfterViewInit // Angular创建视图之后 ngAfterViewChecked //Angular检测了组件视图的绑定之后 执行顺序 ngOnChanges //绑定属性变化时 ngOnInit //在第一次ngOnChanges之后，初始化时 ngDoCheck //每次Angular变化检测时 ngAfterContentInit //组件内容初始化之后 ngAfterContentChecked //组件内容变化后 ngAfterViewInit //初始化组件视图和子视图之后 ngAfterViewChecked //在数组视图和子视图检查之后 ngOnDestroy 我们将组件设定上钩子函数如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344import &#123;Component, Input, Output, EventEmitter&#125; from 'angular2/core';@Component(&#123; selector: 'basic-info', template: ` &lt;h1&gt;Basic Info, &#123;&#123;abc&#125;&#125;&lt;/h1&gt; &lt;input type=\"text\" [(ngModel)]=\"abc\"&gt; `&#125;)export class BasicInfo&#123; @Input('test') set value(val)&#123; this.abc = val; this.callback.next([val]); &#125; @Output('callback') callback = new EventEmitter(); constructor()&#123; this.abc = 'aaaa'; &#125; ngOnInit()&#123; console.log('basic info init.'); &#125; ngDoCheck()&#123; console.log('basic info do check.'); &#125; ngOnChanges()&#123; console.log('basic info changes.'); &#125; ngOnDestroy()&#123; console.log('basic info destroy'); &#125; ngAfterContentInit()&#123; console.log('basic info after content init'); &#125; ngAfterContentChecked()&#123; console.log('basic info after content checked'); &#125; ngAfterViewInit()&#123; console.log('basic info after view init'); &#125; ngAfterViewChecked()&#123; console.log('basic info after view checked'); &#125;&#125; 控制台打印的结果是： 12345678910111213141516basic info changes.test.component.js:23 basic info init.test.component.js:26 basic info do check.test.component.js:35 basic info after content inittest.component.js:38 basic info after content checkedtest.component.js:41 basic info after view inittest.component.js:44 basic info after view checkedtest.component.js:26 basic info do check.test.component.js:38 basic info after content checkedtest.component.js:44 basic info after view checkedtest.component.js:26 basic info do check.test.component.js:38 basic info after content checkedtest.component.js:44 basic info after view checkedtest.component.js:26 basic info do check.test.component.js:38 basic info after content checkedtest.component.js:44 basic info after view checked"},{"title":"详解angular之$q","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/Angular相关/详解angular之$q/","text":"0、什么的PromisePromise（承诺）是用于改善异步编程体验的一种编程模型，它提供了一些列的API的方法论，让你能更优雅的解决异步编程中出现的一些问题。 1、Promise的核心竞争力在处理有依赖性的回调的时候，我们的代码是这样写的： step1(function (value1) { step2(value1, function(value2) { step3(value2, function(value3) { step4(value3, function(value4) { // Do something with value4 }); }); }); }); 这就是我们所谓的回调地狱。 如果用Promise的方式来实现，是怎么样呢？ step1().then(step2).then(step3).then(step4) 代码更简单逻辑也清晰，异步的回调嵌套变成了同步写法，孰优孰劣相信大家都一目了然。 2、Angular服务$q在angular中，基于nodejs中流行的Q提供了一个简化版本的Q,对外的话提供一个service $q。 以下列举出angular中的$q提供的API 1、Promise.then() 将回调变成链式调用，then可以接两个参数，successCallback, errorCallback,示例如下：var deferred = $q.defer(); var promise = deferred.promise; promise.then(successCallback, errorCallback); 2、Promise.catch 捕获Promise异常，Promise.catch(errorCallback)等价于Promise.then(null, errorCallback)3、Promise.finally(callback, notifyCallback) promise结束后要做的事情和接收通知信息4、Deferred.resolve(val) 通知promise请求处理完毕，并将处理结果传给回调函数（successCallback），示例如下：var deferred = $q.defer(); setTimeout(function(){ deferred.resolve(&apos;abc&apos;); //会将abc传递给successCallback }, 1000); var promise = deferred.promise; promise.then(successCallback, errorCallback); 5、Deferred.reject(msg) 通知promise请求出现异常，将异常信息传给回调函数（errorCallback），示例如下：var deferred = $q.defer(); setTimeout(function(){ deferred.reject(&apos;abc&apos;); //会将abc传递给errorCallback }, 1000); var promise = deferred.promise; promise.then(successCallback, errorCallback); 6、Deferred.notify(value) 内部执行有变化时，对外发起通知。将会在Promise.finally中捕获到var deferred = $q.defer(); setTimeout(function(){ deferred.reject(&apos;abc&apos;); //会将abc传递给errorCallback }, 1000); var promise = deferred.promise; promise.then(successCallback, errorCallback); 7、$q.when(val/fn) 将任意对象/函数包装成promise，返回包装好的promise。8、$q.all(promises).then() 当所有的promise都成功解析后，流程才继续往下走。示例如下:$q.all($http.get(&apos;xxx&apos;), $http.post(&apos;xxx&apos;,{})) .then(successCallback, errorCallback); 3、$q的使用常规使用 //定义开关变量 var canSuccess = false; //定义一个Promise var buildPromise = ()=&gt;{ var deferred = $q.defer(); setTimeout(()=&gt;{ if(canSuccess){ deferred.resolve(&apos;promise执行成功！&apos;) }else{ deferred.reject(&apos;promise执行失败！&apos;) } },5000); return deferred.promise; }; //使用它 var promise = buildPromise(); promise.then(()=&gt;{ console.log(&apos;执行成功啦！&apos;); }, ()=&gt;{ console.log(&apos;执行失败了！&apos;); }) 使用$q.all var p1 = $http.get(&apos;xxxx&apos;); var p2 = $http.get(&apos;xxxx2&apos;); $q.all(p1, p2).then(() =&gt;{ console.log(&apos;两次请求都成功了！&apos;); }); 4、$q源码分解//Deferred定义 function Deferred() { this.promise = new Promise(); //Necessary to support unbound execution :/ this.resolve = simpleBind(this, this.resolve); this.reject = simpleBind(this, this.reject); this.notify = simpleBind(this, this.notify); } //函数柯里化 function simpleBind(context, fn) { return function(value) { fn.call(context, value); }; } 通过这种方式，就能将resolve，reject和promise关联起来了。既然我们最终要返回promise，那我们来看已看Promise的实现： function Promise() { this.$$state = { status: 0 }; } extend(Promise.prototype, { then: function(onFulfilled, onRejected, progressBack) { if (isUndefined(onFulfilled) &amp;&amp; isUndefined(onRejected) &amp;&amp; isUndefined(progressBack)) { return this; } var result = new Deferred(); this.$$state.pending = this.$$state.pending || []; this.$$state.pending.push([result, onFulfilled, onRejected, progressBack]); if (this.$$state.status &gt; 0) scheduleProcessQueue(this.$$state); return result.promise; }, &quot;catch&quot;: function(callback) { return this.then(null, callback); }, &quot;finally&quot;: function(callback, progressBack) { return this.then(function(value) { return handleCallback(value, true, callback); }, function(error) { return handleCallback(error, false, callback); }, progressBack); } }); 从这里很明显可以看出，catch就是一个语法糖，调用的还是then。finally也是一个语法糖，就是不关成功，还是失败，都会调用callback。那这个时候，我们主要关注的方法就放到then这个方法的实现上。 为了实现链式调用，在then方法内部，又实例化了Deferred对象，并返回Defferrd.promise。 接下来就来看处理过程： this.$$state.pending = this.$$state.pending || []; this.$$state.pending.push([result, onFulfilled, onRejected, progressBack]); if (this.$$state.status &gt; 0) scheduleProcessQueue(this.$$state); extend(Deferred.prototype, { resolve: function(val) { if (this.promise.$$state.status) return; if (val === this.promise) { this.$$reject($qMinErr( &apos;qcycle&apos;, &quot;Expected promise to be resolved with value other than itself &apos;{0}&apos;&quot;, val)); } else { this.$$resolve(val); } }, $$resolve: function(val) { var then, fns; fns = callOnce(this, this.$$resolve, this.$$reject); try { if ((isObject(val) || isFunction(val))) then = val &amp;&amp; val.then; if (isFunction(then)) { this.promise.$$state.status = -1; then.call(val, fns[0], fns[1], this.notify); } else { this.promise.$$state.value = val; this.promise.$$state.status = 1; scheduleProcessQueue(this.promise.$$state); } } catch (e) { fns[1](e); exceptionHandler(e); } }, reject: function(reason) { if (this.promise.$$state.status) return; this.$$reject(reason); }, $$reject: function(reason) { this.promise.$$state.value = reason; this.promise.$$state.status = 2; scheduleProcessQueue(this.promise.$$state); }, notify: function(progress) { var callbacks = this.promise.$$state.pending; if ((this.promise.$$state.status &lt;= 0) &amp;&amp; callbacks &amp;&amp; callbacks.length) { nextTick(function() { var callback, result; for (var i = 0, ii = callbacks.length; i &lt; ii; i++) { result = callbacks[i][0]; callback = callbacks[i][3]; try { result.notify(isFunction(callback) ? callback(progress) : progress); } catch (e) { exceptionHandler(e); } } }); } } }); 在调用then的时候，就将锅中回调写到$$state的pending数组中，让defferred.resolve的时候就会调用Deferred的内部方法，调用我们传递的回调函数。 源码分解实在是说不明白，后期再发一篇如何实现一个简易的Promise，希望能更简洁易懂 5、 了解更多JavaScript Promise迷你书（中文版） Angular $q api"},{"title":"01_Angular2初体验","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/Angular2一路向前/01_Angular2初体验/","text":"0、关于Angular2Angualr2是前端最流行的MV*框架AngularJS的革命性更新版本，官网：https://angular.io/，号称一个框架统一移动版和桌面。 1、背景将AngularJS升级为Angular2，是大势所趋。在之前，我们就必须要对Angular2有足够的了解。所以这一系列文章，希望从各个点将angular2分而破之。 另外，由于Angular2当前处于Beta阶段，所以代码的时效性不高。所以每篇都会注明相关版本。 Angular2推荐的开发语言是TypeScript http://www.typescriptlang.org/，所以我们这一系列文章也使用TypeScript开发（实际是使用JavaScript，半天没弄成功，丧气ing…）。 不要害怕TypeScript，因为TypeScript是ES6的超集，我们完全可以使用ES6的方式来编写TypeScript代码。对我们来说，仅仅是文件名后缀变化了。 2、Angular2 Hello-WorldAngular2并不仅仅只有一个JS文件，要想成功运行Angular2，需要包含如下内容： systemjs –模块加载器 Rxjs –对Js的扩展，至今不知道它是做什么的 angular2 如果要支持IE，那么还需要 es6-shim systemjs 中的system-polyfills.js文件 angular2中的shims_for_IE.js文件 接着就直接创建项目吧，结构如下： 1234567&lt;root folder&gt; components/ hello_world.html hello_world.ts bootstrap.ts index.html package.json 首先第一步，我们要通过npm安装我们的依赖项：npm install angular2 rxjs systemjs es6-shim typescript --save 接着，实现我们的index.html内容： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Angular2 Hello World&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- Angular2组件标记 --&gt; &lt;hello_world&gt;&lt;/hello_world&gt; &lt;!-- IE required polyfills --&gt; &lt;script src=\"node_modules/es6-shim/es6-shim.js\"&gt;&lt;/script&gt; &lt;script src=\"node_modules/systemjs/dist/system-polyfills.js\"&gt;&lt;/script&gt; &lt;script src=\"node_modules/angular2/es6/dev/src/testing/shims_for_IE.js\"&gt;&lt;/script&gt; &lt;!-- Compile TypeScript --&gt; &lt;script src=\"node_modules/typescript/lib/typescript.js\"&gt;&lt;/script&gt; &lt;!-- Angular2 required --&gt; &lt;script src=\"node_modules/systemjs/dist/system.js\"&gt;&lt;/script&gt; &lt;script src=\"node_modules/angular2/bundles/angular2-polyfills.js\"&gt;&lt;/script&gt; &lt;script src=\"node_modules/rxjs/bundles/Rx.js\"&gt;&lt;/script&gt; &lt;script src=\"node_modules/angular2/bundles/angular2.js\"&gt;&lt;/script&gt; &lt;!-- startup app --&gt; &lt;script&gt; System.config(&#123; transpiler: 'typescript', typescriptOptions: &#123; emitDecoratorMetadata: true &#125;, packages: &#123;'components': &#123;defaultExtension: 'ts'&#125;&#125; //配置components目录下的请求，默认格式为ts &#125;); //注意：此处import的时候，必须要指明后缀，因为我们是把bootstrap.ts放在index平级的，在System的config中没有配置默认扩展名 System.import('bootstrap.ts').then(null, console.error.bind(console)); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 然后是我们的hello_world.html和hello_world.ts，内容如下： 12345&lt;h1&gt;Hello Angular2&lt;/h1&gt;My name is: &lt;input type=\"text\" [(ngModel)]=\"username\"&gt;&lt;br&gt;Angular2: &lt;span *ngIf=\"username\"&gt;Hello, &#123;&#123;username&#125;&#125;&lt;/span&gt; 123456789101112import &#123;Component&#125; from 'angular2/core';@Component(&#123; selector: 'hello_world', //此处指明了组件的标记，我们就可以使用&lt;hello_world&gt;&lt;/hello_world&gt;来使用这个组件了。 templateUrl: 'components/hello_world.html'&#125;)//export的意思是导出这个组件，在使用的地方，就可以使用import &#123;xx&#125; from 'xxx'来获取到了。export class HelloWorldComponent&#123; constructor()&#123; &#125;&#125; 最后，是我们的bootstrap.ts入口JS： 1234import &#123;bootstrap&#125; from 'angular2/platform/browser';import &#123;HelloWorldComponent&#125; from 'components/hello_world';bootstrap(HelloWorldComponent); 通过anywhere启动静态服务器，就可以看到我们的页面了。 But，理想很丰满，现实很骨感，为嘛不兼容IE11？？？ 错误提示如下： 1&quot;&apos;Symbol&apos; is undefined&quot; 坑你没商量*！最终发现是Rx的版本必须用angular2提供的那个版本 地址是：https://code.angularjs.org/2.0.0-beta.12/Rx.js 所以把Rx.js文件替换下，就可以在IE11中跑起来了。 另外，经测试，Angular2可兼容IE9及以上版本。 3、结尾Demo源码"},{"title":"04_Angular2指令简析","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/Angular2一路向前/04_Angular2指令简析/","text":"0、Angular2指令在Angular1中，就已经有了指令的概念。Angular1中的指令用于实现可复用UI部件，也用于操作dom元素。 那么在Angular2中的指令是一样的东西么？ Angular2中有组件的概念，指令这个东西就变得更加纯粹。 Angular2的指令有三种： 组件 属性指令 结构指令 组件是有模板的指令，是指令的中一个另类，因为它使用@Component来装饰，而不是@Directive。 属性指令用于改变现有元素的展现和行为，使用的时候它们看起来像是正常的HTML属性，所以称之为属性指令。如ngModel指令。 结构指令通过添加、删除和替换DOM树中的元素来改变布局，由于可以更改DOM结构，所以称之为结构指令。如ngIf，ngSwitch。 由于Angular2的API好不够稳定，书写该文时，采用的是Angular2 rc1（@angular rc.1）版本，其他版本请自行测试。 1、属性指令接着，我们就一步步来实现一个属性指令 dynamicColor 。 首先，我们需要创建一个ts文件，然后把指令的骨架搭建起来。 1234567891011import &#123;Directive&#125; from '@angular/core';@Directive(&#123; selector: '[dynamicColor]'&#125;)export class DynamicColorDirective&#123; constructor()&#123; &#125;&#125; 以上代码中，我们创建了一个dynamicColor指令。 接下来，我们来实现具体的功能，可以设置元素的背景色和前景色，并能实现事件通知。 要实现动态背景色和前景色，那我们需要额外附加两个属性bgColor和color。 要想在指令中获取这两个属性值，那么我们可以通过@Input方式或者是inputs属性，代码如下： 123456789101112131415161718import &#123;Directive, Input&#125; from '@angular/core';@Directive(&#123; selector: '[dynamicColor]'&#125;)export class DynamicColorDirective&#123; @Input() private bgColor: string; @Input() private color: string; constructor()&#123; &#125;&#125; 或者是： 1234567891011121314151617181920212223import &#123;Directive, Input&#125; from '@angular/core';@Directive(&#123; selector: '[dynamicColor]', //注意，在之前的版本中，使用properties属性，而且，当前还可以使用。 inputs: [ 'bgColor: bgColor', //字符串以冒号隔开，前者是DynamicColorDirective的属性，后者的html元素的属性 'color: color' ]&#125;)export class DynamicColorDirective&#123; // @Input() private bgColor: string; // @Input() private color: string; constructor()&#123; &#125;&#125; 那么html中又应该如何传递值给指令呢？ 123&lt;div class=\"test\" dynamicColor [bgColor]=\"testBgColor\" [color]=\"testColor\"&gt; Hi!&lt;/div&gt; 注意：在html元素的属性上，我们可以有两种写法。一种是直接书写属性，此时会把属性值原样传递给指令。第二种是使用[属性]，此时属性值应该是表达式（可以使用变量，判断等语句），传递给指令的是表达式的结果。 我们又如何在后端查看这两个值呢？ 直接在constructor中console？明确的说是不行的，因为constructor的代码会先于绑定执行。 这个时候，我们就需要借助指令的生命周期钩子。 指令的生命周期钩子有如下几个： ngOnInit –初始化时 ngOnChanges – 属性绑定之时（会有一次inputs属性绑定先于初始化） ngDoCheck – 执行属性检查时 ngOnDestroy – 指令释放时 了解了生命周期钩子，我们就可以通过ngOnInit来查看绑定好的属性值了。 1234567891011121314151617181920212223242526import &#123;Directive, Input, OnInit&#125; from '@angular/core';@Directive(&#123; selector: '[dynamicColor]', inputs: [ 'bgColor: bgColor', //字符串以冒号隔开，前者是DynamicColorDirective的属性，后者的html元素的属性 'color: color' ]&#125;)export class DynamicColorDirective implements OnInit&#123; // @Input() private bgColor: string; // @Input() private color: string; constructor()&#123; &#125; ngOnInit()&#123; console.log('bgColor', this.bgColor); console.log('color', this.color); &#125;&#125; 接下来，我们需要设置元素的background color和color样式，那么我们必须要拿到这个而元素的引用, 并在初始化之后进行绑定。 1234567891011121314151617181920212223242526272829303132333435import &#123;Directive, Input, OnInit, ElementRef&#125; from '@angular/core';@Directive(&#123; selector: '[dynamicColor]', inputs: [ 'bgColor: bgColor', //字符串以冒号隔开，前者是DynamicColorDirective的属性，后者的html元素的属性 'color: color' ]&#125;)export class DynamicColorDirective implements OnInit&#123; private nativeElement: any; // @Input() private bgColor: string; // @Input() private color: string; constructor(el: ElementRef)&#123; this.nativeElement = el.nativeElement; &#125; private _setElementStyle(): void&#123; this.nativeElement.style.backgroundColor = this.bgColor; this.nativeElement.style.color = this.color; &#125; ngOnInit()&#123; console.log('bgColor', this.bgColor); console.log('color', this.color); this._setElementStyle(); &#125;&#125; 当从元素上绑定的属性变化时，又应该从哪里获取到变更呢？这就需要借助生命周期里面的OnChanges函数，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041import &#123;Directive, Input, ElementRef, OnInit, OnChanges&#125; from '@angular/core';@Directive(&#123; selector: '[dynamicColor]', inputs: [ 'bgColor: bgColor', //字符串以冒号隔开，前者是DynamicColorDirective的属性，后者的html元素的属性 'color: color' ]&#125;)export class DynamicColorDirective implements OnInit, OnChanges&#123; private nativeElement: any; // @Input() private bgColor: string; // @Input() private color: string; constructor(el: ElementRef)&#123; this.nativeElement = el.nativeElement; &#125; private _setElementStyle(): void&#123; this.nativeElement.style.backgroundColor = this.bgColor; this.nativeElement.style.color = this.color; &#125; ngOnInit()&#123; console.log('bgColor', this.bgColor); console.log('color', this.color); this._setElementStyle(); &#125; ngOnChanges()&#123; console.log('bgColor-change', this.bgColor); console.log('color-change', this.color); this._setElementStyle(); &#125;&#125; 由于每次变化都会触发OnChanges，那么为了提高性能，我们可以在这里加入一个节流函数。 1234567private _setElementStyle(): void &#123; clearTimeout(this.timeoutId); this.timeoutId = setTimeout(() =&gt; &#123; this.nativeElement.style.backgroundColor = this.bgColor; this.nativeElement.style.color = this.color; &#125;, 500);&#125; 有了节流函数，我们就不太确定到底执行了几次更新操作了。这个时候，我们可以加入事件通知。这就涉及到指令的@Output了。 12@Output()private updated: EventEmitter&lt;any&gt; = new EventEmitter(); 也等同于： 1234outputs: [ 'updated: updated']private updated: EventEmitter&lt;any&gt; = new EventEmitter(); 注意：在之前的版本中，也可以用events属性来替代outputs，现在也还可以使用 要对外发出通知，只需要使用如下代码： 12this.updated.emit('updated');this.updated.next('updated2'); HTML标签使用时，代码如下： 123&lt;div class=\"test\" dynamicColor [bgColor]=\"testBgColor\" [color]=\"testColor\" (updated)=\"notify($event)\"&gt; Hi!&lt;/div&gt; 至此，我们这个指令就已经完成了，所有代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//dynamicColor.directive.tsimport &#123;Directive, Input, Output, ElementRef, EventEmitter, OnInit, OnChanges&#125; from '@angular/core';@Directive(&#123; selector: '[dynamicColor]', inputs: [ 'bgColor: bgColor', //字符串以冒号隔开，前者是DynamicColorDirective的属性，后者的html元素的属性 'color: color' ], outputs: [ 'updated: updated' ]&#125;)export class DynamicColorDirective implements OnInit, OnChanges &#123; private nativeElement: any; private timeoutId: any; // @Input() private bgColor: string; // @Input() private color: string; // @Output() private updated: EventEmitter&lt;any&gt; = new EventEmitter(); constructor(el: ElementRef) &#123; this.nativeElement = el.nativeElement; &#125; private _setElementStyle(): void &#123; clearTimeout(this.timeoutId); //先清除已有的timeout //保证只执行最后一次。 this.timeoutId = setTimeout(() =&gt; &#123; this.nativeElement.style.backgroundColor = this.bgColor; this.nativeElement.style.color = this.color; this.updated.emit('updated'); this.updated.next('updated2'); &#125;, 500); &#125; ngOnInit() &#123; console.log('bgColor', this.bgColor); console.log('color', this.color); this._setElementStyle(); &#125; ngOnChanges() &#123; console.log('bgColor-change', this.bgColor); console.log('color-change', this.color); this._setElementStyle(); &#125;&#125; 1234567//test.html&lt;h1&gt;Dynamic Color Directive&lt;/h1&gt;&lt;input type=\"text\" [(ngModel)]=\"testBgColor\"&gt;&lt;div class=\"test\" dynamicColor [bgColor]=\"testBgColor\" [color]=\"testColor\" (updated)=\"notify($event)\"&gt; Hi!&lt;/div&gt; 123456789101112131415161718192021//test.component.tsexport class TestComponent&#123; private testBgColor: string = 'blue'; private testColor: string = 'red'; constructor()&#123; &#125; private test(data)&#123; console.log('data', 'my', data); &#125; private notify(data)&#123; console.log('notify = ', data); &#125; &#125; 思考一下？我们还有没有更简单的方式实现以上的效果呢？ 12345678910111213141516171819202122232425262728import &#123;Directive, EventEmitter&#125; from '@angular/core';@Directive(&#123; selector: '[dynamicColor]', inputs: [ 'bgColor: bgColor', //字符串以冒号隔开，前者是DynamicColorDirective的属性，后者的html元素的属性 'color: color' ], outputs: [ 'updated: updated' ], host: &#123; '[style.backgroundColor]': 'bgColor', '[style.color]': 'color' &#125;&#125;)export class DynamicColorDirective &#123; private bgColor: string; private color: string; private updated: EventEmitter&lt;any&gt; = new EventEmitter(); constructor() &#123; &#125;&#125; 通过host直接在元素上添加绑定。 2、结构指令结构指令帮助我们修改dom结构，我们就简单实现一个templateInclude指令。 12345678910111213141516171819202122232425262728293031323334import &#123;Directive, Input, Output, ElementRef, EventEmitter, OnChanges&#125; from '@angular/core';import &#123;Http&#125; from '@angular/http';@Directive(&#123; selector: '[templateInclude]'&#125;)export class TemplateIncludeDirective implements OnChanges &#123; private nativeElement: any; @Input('templateInclude') private templateUrl: string; @Output() private loaded: EventEmitter&lt;any&gt; = new EventEmitter(); constructor(el: ElementRef, private http: Http) &#123; this.nativeElement = el.nativeElement; &#125; private _setTemplate() &#123; this.http.get(this.templateUrl) .subscribe(res =&gt; &#123; this.nativeElement.innerHTML = res.text(); this.loaded.next(`$&#123;this.templateUrl&#125; loaded`); &#125;); &#125; ngOnChanges() &#123; console.log(this.templateUrl); this._setTemplate(); &#125;&#125; 3、总结1、指令的元数据有很多属性可以使用 12345678910111213class DirectiveMetadata &#123; selector : string //指令使用的标记（选择器） inputs : string[] //输入参数绑定 properties : string[] //属性绑定（过期，请使用inputs） outputs : string[] //输出参数绑定 events : string[] //事件绑定（过期，请使用outputs） host : &#123;[key: string]: string&#125; //宿主元素属性设置 providers : any[] //服务绑定 bindings : any[] //服务绑定（过期，请使用providers） exportAs : string //导出名称 queries : &#123;[key: string]: any&#125; //用于指令依赖关系&#125; 2、在使用指令（不仅仅是指令）进行绑定的时候，[]表示输入属性，()表示输出属性和事件 3、尽量使用统一的做法，用装饰器优于在属性上做绑定 4、在编写指令（不仅限于指令）时，将class中内容按照特定顺序进行排列，推荐顺序如下（个人建议，仅供参考）： 私有变量 共有变量 @Input变量 @Output变量 构造函数 私有方法（建议下划线开头） 公有方法 生命周期钩子方法"},{"title":"05_Angular2组件简析","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/Angular2一路向前/05_Angular2组件简析/","text":"0、Angular2组件注：由于Angular2的API好不够稳定，书写该文时，采用的是Angular2 rc1（@angular rc.1）版本，其他版本请自行测试。 在上篇中，我们已经讲到了指令，这篇呢，我们一起来看看Angular2组件是怎么一回事。 首先，组件也是指令，组件是一种有模板（内嵌视图）的特殊指令。 从元数据指令源代码中也可以看出组件与指令的关系： 123export class ComponentMetadata extends DirectiveMetadata &#123; &#125; 相比 Directive, Component 新增了一些属性，如下： 123456789101112&#123; changeDetection : ChangeDetectionStrategy; 定义变化检测类型 viewProviders: any[]; 用于在组件中注入特定的class。一般是实体类 moduleId: string; 定义主键的ID templateUrl: string; 如ng1，外部模板地址 template: string; 如ng1，内嵌模板内容 styleUrls: string[]; 外部样式表文件 styles: string[]; 内嵌样式 directives: Array&lt;Type | any[]&gt;; 使用到的指令 pipes: Array&lt;Type | any[]&gt;; 使用到的管道 encapsulation: ViewEncapsulation 封装视图的类型&#125; 1、组件生命周期既然组件也是指令，那么指令所拥有的四大阶段组件也同样拥有。 而且，由于组件带有视图，还多了几个和视图相关的生命周期阶段。如下： ngAfterContentInit 组件内容渲染到页面之后触发 ngAfterContentChecked 检查组件内容绑定数据后触发 ngAfterViewInit 创建组件视图之后触发 ngAfterViewChecked 检查组件视图绑定数据后触发 它们的执行顺序也和以上顺序一致。 2、整一个组件试试？接下来，我们就简单实现一个组件 TodoList 来实验一下以上的知识点。 首先，搭建好一个简单的架子，如下： 1234567891011import &#123;Component&#125; from '@angular/core';@Component(&#123; selector: 'todo-list'&#125;)export class TodoListComponent&#123; constructor()&#123; &#125;&#125; 使用组件装饰器 Component 来定义一个组件，注意其中 selector 属性和 Directive 中的写法不一样了。 组件必须以标签的方式存在，所以 selector 属性值仅仅只需要写标签名就可以了，不再需要其他特别的符号了。 组件和指令最大的差别就在于模板，所以我们接下来添加上模板代码： 12345678910111213141516171819import &#123;Component&#125; from '@angular/core';@Component(&#123; selector: 'todo-list', template: `&lt;div class=\"todo-list\"&gt; &lt;h1&gt;Todo List&lt;/li&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; `&#125;)export class TodoListComponent&#123; constructor()&#123; &#125;&#125; 如上，一个简单的模板就搞好了。这里需要注意 templateUrl 和 template 是互斥的两个属性。一般来说只选择一个赋值，如果两者都存在，那么会采用 tempalte 的值。 模板有了，我们就来点业务逻辑： 先假设Todo有三个状态： 12345enum TodoStatus &#123; Open, Processing, Closed&#125; 在来定义Todo的实体类： 1234567891011121314class Todo &#123; private name: string; private description: string; private status: TodoStatus; constructor(name: string, status: TodoStatus, description?: string) &#123; this.name = name; this.status = status; this.description = description || ''; &#125;&#125; 接着来实现一个组件： 123456789101112131415161718@Component(&#123; selector: 'todo-list', template: require('./todo-list.component.html')&#125;)export class TodoList &#123; private todos: Array&lt;Todo&gt;; private todo: &#123; name: string, desc: string &#125; = &#123; name: '', desc: '' &#125;; constructor() &#123; this.todos = []; &#125; addTodo() &#123; this.todos.push(new Todo(this.todo.name, TodoStatus.Open, this.todo.desc)); &#125;&#125; 这个时候，HTML页面内容如下： 123456789101112131415&lt;div *ngIf=\"todos.length === 0\"&gt;No todos.&lt;/div&gt;&lt;ul class=\"todo-list\"&gt; &lt;li *ngFor=\"let todo of todos\"&gt; &#123;&#123;todo.name&#125;&#125; - &#123;&#123;todo.description&#125;&#125; &lt;/li&gt;&lt;/ul&gt;&lt;hr&gt;&lt;div class=\"todo-edit\"&gt; Name: &lt;input type=\"text\" [(ngModel)]=\"todo.name\"&gt; &lt;br&gt; Description: &lt;br&gt; &lt;textarea name=\"\" id=\"\" cols=\"30\" rows=\"3\" [(ngModel)]=\"todo.desc\"&gt;&lt;/textarea&gt; &lt;br&gt; &lt;button (click)=\"addTodo()\"&gt;Add Todo&lt;/button&gt;&lt;/div&gt; 功能做好了，我们得给它来点样式美化。 此时我们仅仅需要实现一点样式： 12345678.todo-list&#123; margin: 0; padding: 0;&#125;.todo-list li&#123; list-style: none; border: 1px solid red;&#125; 然后在组件装饰器中申明就可以了： 12345@Component(&#123; selector: 'todo-list', template: require('./todo-list.component.html'), styles : [require('./todo-list.component.css')]&#125;) 至此，一个简单的可以添加todo的todo-list就已经完成了。 注意：注入@Input，@Output之类的和Directive都是一样的，此处就不再演示了。"},{"title":"03_Angular2的那些Decorator","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/Angular2一路向前/03_Angular2的那些Decorator/","text":"0、DecoratorDecorator 是ECMAScript中建议的标准，使得我们可以在设计时对类和属性进行注解和修改。 1、Angular2的Decorator在Angular2的早期版本（使用AtScript）中，我们是使用Annotation（注解），它以一个声明的方式将元数据添加到代码中。 在后来迁移到TypeScript的时候，我们可以使用 Decorator 和 Annotation 。作为使用者来说，使用 Decorator 和 Annotation 几乎是一样的，唯一的区别是我们没有去控制 Annotation 如何将元数据添加到我们的代码中，而 Decorator 是对 这些 Annotation 的最终实现。 从长远看，我们更应该多关注 Decorator ，因为它才是真正的标准建议。 2、Angular2的那些Decorator2.1、In angular2/core2.1.1、ComponentComponent 用于声明可重用的UI构建模块（组件），每个 Angular component都要求有一个 @Component 注解，它指定了组件何时被实例化，哪些属性和 hostListeners 被绑定。 当组件实现（implements）了一些生命周期钩子（lifecycle-hooks），那么将在特定的时间点访问这些钩子的回调函数。 如何使用 123456789101112131415161718192021222324@Component(&#123; selector: 'demo', // 配置选择器 inputs: [], outputs: [], properties: [], events: [], host: &#123;&#125;, providers: [], // 设定所依赖的Providers（ng1中的service，provider，factory） exportAs: '', moduleId: '', //设定模块ID viewProviders: [], queries: &#123;&#125;, //changeDetection templateUrl : '', // 指定模板文件URL，和template冲突 template: 'Hello &#123;&#123;name&#125;&#125;!', //指定模板内容，和templateUrl冲突 styleUrls: [], // 设定组件依赖的样式表文件 styles : [], //设定组件依赖的样式 directives: [], //设定所依赖的Directives（ng1中的directives） pipes: [] //设定所依赖的Pipes（ng1中的filter） //encapsulation&#125;)export class Demo &#123; private name: string = 'World';&#125; 注：从继承关系来看，Component extends Directive。 2.1.2、DirectiveDirective 允许你在DOM元素上附加行为。如果指令带有内嵌视图，那么就成为了组件。 指令同样也有生命周期钩子。使用方式和 Component 雷同。 指令允许多种注入方式来实例化： 1、无注入 – 该指令没有外部依赖 123456// 空构造，无注入@Directive(&#123; selector: '[my-directive]' &#125;)class MyDirective &#123; constructor() &#123; &#125;&#125; 2、组件级别的注入 – 该指令依赖一些外部服务 1234567import &#123;User&#125; from 'xxx';@Directive(&#123; selector: '[my-directive]' &#125;)class MyDirective &#123; constructor(user: User) &#123; //依赖外部服务 &#125;&#125; 3、注入当前元素的其它指令 –该指令依赖当前元素上的其他指令，搭配其他指令一起使用 1234567import &#123;User&#125; from 'xxx';@Directive(&#123; selector: '[my-directive]' &#125;)class MyDirective &#123; constructor(depDirective: DepDirective) &#123; //依赖当前元素上的其他指令 &#125;&#125; 123&lt;div my-directive dep-directive&gt; &lt;/div&gt; 4、注入当前元素、父元素、更上层的父元素上的指令 –该指令依赖上层元素的指令 12345678import &#123;User&#125; from 'xxx';@Directive(&#123; selector: '[my-directive]' &#125;)class MyDirective &#123; //要使用 @Host() constructor(@Host() depDirective: DepDirective) &#123; //可以依赖父辈元素上的指令 &#125;&#125; 123&lt;div dep-directive&gt; &lt;div my-directive&gt;&lt;/div&gt;&lt;/div&gt; 5、注入直接子集集合元素的的指令 –该指令依赖直接子元素的指令 12345678import &#123;User&#125; from 'xxx';@Directive(&#123; selector: '[my-directive]' &#125;)class MyDirective &#123; //使用 @Query&lt;Type&gt; ，依赖直接子元素上的指令 constructor(@Query(DepDirective) depDirective: QueryList&lt;DepDirective&gt;) &#123; &#125;&#125; 1234&lt;div my-directive&gt; &lt;p dep-directive&gt;&lt;/p&gt; &lt;p dep-directive&gt;&lt;/p&gt;&lt;/div&gt; 6、注入后代集合元素的指令 –该指令依赖后代元素的指令 12345678import &#123;User&#125; from 'xxx';@Directive(&#123; selector: '[my-directive]' &#125;)class MyDirective &#123; //使用 @Query&lt;Type&gt; ，依赖直接子元素上的指令 constructor(@Query(DepDirective, &#123;descendants: true&#125;) depDirective: QueryList&lt;DepDirective&gt;) &#123; &#125;&#125; 123456&lt;div my-directive&gt; &lt;div&gt; &lt;p dep-directive&gt;&lt;/p&gt; &lt;p dep-directive&gt;&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 7、可选注入 –该指令的依赖是可选的。 123456@Directive(&#123; selector: &apos;[my-directive]&apos; &#125;)class MyDirective &#123; // 使用 @Optional 标记，依赖是可选的。 constructor(@Optional() depDirective:DepDirective) &#123; &#125;&#125; 注：以上多种注入方式也适用于 Component 。 2.1.3、InjectableInjectable 允许使用注入。在编写组件/指令时，如果有注入，那么就需要将指令/组件标记为可注入的。 2.1.4、PipePipe 允许我们定义管道方法，实现ng1中filter类似的功能。 如何编写一个Pipe？ 1234@Pipe(&#123;name: 'lowercase'&#125;)class Lowercase &#123; transform(v: string, args: any[]) &#123; return v.toLowerCase(); &#125;&#125; 2.2、In angular2/router2.2.1、CanActivateCanActivate 允许我们在使用路由时，检查组件的权限，来确定是否可以使用。 1234@Component(&#123;selector: 'control-panel-cmp', template: `&lt;div&gt;Settings: ...&lt;/div&gt;`&#125;)@CanActivate(checkIfWeHavePermission)class ControlPanelCmp &#123;&#125; 2.2.2、RouteConfigRouteConfig 用于我们配置路由。 使用如下： 1234567891011121314151617@Component(&#123; selector: &apos;dojo-app&apos;, moduleId: module.id, templateUrl: &apos;app.html&apos;, styleUrls: [&apos;app.css&apos;], directives: [ROUTER_DIRECTIVES, HeaderComponent]&#125;)@RouteConfig([ &#123;path: &apos;/&apos;, name: &apos;Home&apos;, component: HomeComponent&#125;, &#123;path: &apos;/about&apos;, name: &apos;About&apos;, component: AboutComponent&#125;])export class AppComponent&#123; constructor() &#123; &#125;&#125; 3、参考 https://angular.io/docs/ts/latest/api/index.html#!?apiType=Decorator https://angular.io/docs/ts/latest/api/index.html#!?apiFilter=metadata"},{"title":"09_Angular2使用ui-router-ng2","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/Angular2一路向前/09_Angular2使用ui-router-ng2/","text":"0、导言Angular2的路由组件从beta到rc经历了多次变更，知道rc.4都没有完全稳定下来。其次它的功能也并不强大，全局钩子，动态加载，状态控制都不支持。 如果是使用Angular1，那这个时候我们一般会选择 ui-router 这一个强大的基于状态的路由。 其实，ui-router 也提供了一个Angular2的版本，那就是 ui-router-ng2。 我们就来简单的尝试下它的使用，和利用它来实现动态加载一批组件（结合webpack）。 1、引入 ui-router-ng2要使用 ui-router-ng2，我们必须要先通过 npm install ui-router-ng2 来安装该包。 安装成功之后，我们需要实现一个 UIRouterConfig 的实例，代码如下： 1234567891011121314151617181920import &#123; Injectable &#125; from '@angular/core';import &#123; UIRouter, UIRouterConfig &#125; from 'ui-router-ng2';import &#123;AboutComponent&#125; from './about.component';@Injectable()export class AppRouterConfig implements UIRouterConfig &#123; constructor() &#123; &#125; configure(uiRouter: UIRouter) &#123; uiRouter.stateRegistry.register(&#123; name: 'about', component: AboutComponent, url: '/about' &#125;); &#125;&#125; 一般做法，我们需要在 configure 方法中，注册路由状态对象。 当实现了 UIRouterConfig 之后，我们就可以在应用启动时来使用它了，具体代码如下： 1234567891011121314151617181920212223import &#123; enableProdMode, provide, PLATFORM_DIRECTIVES &#125; from '@angular/core';import &#123; APP_BASE_HREF, LocationStrategy, HashLocationStrategy, PlatformLocation &#125; from '@angular/common';import &#123; BrowserPlatformLocation &#125; from '@angular/platform-browser';import &#123; bootstrap &#125; from '@angular/platform-browser-dynamic';import &#123; UIROUTER_PROVIDERS, UIRouterConfig, UIROUTER_DIRECTIVES &#125; from 'ui-router-ng2';import &#123; RootComponent &#125; from './../shell';import &#123; AppRouterConfig &#125; from './routes';enableProdMode();bootstrap(RootComponent, [ provide(APP_BASE_HREF, &#123; useValue: '/' &#125;), provide(LocationStrategy, &#123; useClass: HashLocationStrategy &#125;), provide(PlatformLocation, &#123; useClass: BrowserPlatformLocation &#125;), ...UIROUTER_PROVIDERS, provide(UIRouterConfig, &#123; useClass: AppRouterConfig &#125;), provide(PLATFORM_DIRECTIVES, &#123; useValue: UIROUTER_DIRECTIVES, multi: true &#125;)]) .then(x =&gt; &#123; console.log('app started...'); &#125;) .catch(error =&gt; console.log(error)); 其中最关键是和路由相关的代码是： 123...UIROUTER_PROVIDERS, //依赖路由提供者provide(UIRouterConfig, &#123; useClass: AppRouterConfig &#125;), //指定RouterConfigprovide(PLATFORM_DIRECTIVES, &#123; useValue: UIROUTER_DIRECTIVES, multi: true &#125;) //依赖路由指令 在经过这些步骤之后，我们的项目就已经可以使用 ui-router-ng2 来进行路由管理了。 2、路由钩子ui-router-ng2 提供了很强大的路由钩子函数，可以让我们很方便的对路由的各个阶段进行控制。 使用方式如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import &#123;Injectable, Inject&#125; from '@angular/core';import &#123;UIRouter, UIRouterConfig&#125; from 'ui-router-ng2';import &#123;AboutComponent&#125; from './about.component';@Injectable()export class AppRouterConfig implements UIRouterConfig &#123; constructor() &#123; &#125; configure(uiRouter: UIRouter) &#123; uiRouter.stateRegistry.register(&#123; name: 'about', component: AboutComponent, url: '/about' &#125;); // 以下t均为Transition实例 uiRouter.transitionService.onBefore(&#123;&#125;, t =&gt; &#123; console.log('onBefore', t); //路由跳转之前 &#125;); uiRouter.transitionService.onStart(&#123;&#125;, t =&gt; &#123; console.log('onStart', t); //路由跳转开始 &#125;); uiRouter.transitionService.onExit(&#123;&#125;, t =&gt; &#123; console.log('onExit', t); //路由跳出时 &#125;); uiRouter.transitionService.onRetain(&#123;&#125;, t =&gt; &#123; console.log('onRetain', t); //... &#125;); uiRouter.transitionService.onEnter(&#123;&#125;, t =&gt; &#123; console.log('onEnter', t); //路由进入时 &#125;); uiRouter.transitionService.onFinish(&#123;&#125;, t =&gt; &#123; console.log('onFinish', t); //路由跳转完成 &#125;); uiRouter.transitionService.onSuccess(&#123;&#125;, t =&gt; &#123; console.log('onSuccess', t); //路由跳转成功 &#125;); uiRouter.transitionService.onError(&#123;&#125;, t =&gt; &#123; console.log('onError', t); //路由跳转出错 &#125;); &#125;&#125; 通过以上的各个阶段，我们可以灵活控制跳转是否继续，每个钩子函数都接受 boolean 和 Promise&lt;boolean&gt;来让我们确定是否跳转。 3、自定义回调处理invalidState通过以上的方式，我们实现了状态路由，也实现了路由跳转的控制。接下来，我们另辟蹊径来实现动态加载。 由于当我们请求不合法的state时，uiRouter都会执行到 invalidCallbacks 这个函数，我这里就通过它加载动态模块。 实现代码如下： 12345678910111213141516configure(uiRouter: UIRouter) &#123; ... //省略不相关代码 uiRouter.stateProvider.invalidCallbacks = [($from$, $to$) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; let toStateName = $to$.name(); let moduleName = this._getModuleName(toStateName); if (!moduleName) &#123; return; &#125; this.moduleLoader.load(moduleName).then(_ =&gt; &#123; let state = uiRouter.stateService.target(toStateName); resolve(state); &#125;); &#125;); &#125;];&#125; 接着，再来看看moduleLoader的代码： 12345678910111213141516171819202122232425262728293031323334353637import &#123; Injectable, Inject &#125; from '@angular/core';import &#123;Http&#125; from '@angular/http';import &#123;UIRouter&#125; from 'ui-router-ng2';@Injectable()export class ModuleLoader &#123; private uiRouter: UIRouter; private loadedModules: Set&lt;string&gt;; constructor(private http: Http) &#123; this.loadedModules = new Set&lt;string&gt;(); &#125; setRouter(uiRouter) &#123; this.uiRouter = uiRouter; &#125; load(moduleName): Promise&lt;any&gt; &#123; if (this.loadedModules.has(moduleName)) &#123; return Promise.resolve(); &#125; return new Promise((resolve, reject) =&gt; &#123; this.http.get(`../dist/assets/js/$&#123;moduleName&#125;.js`) .toPromise() .then(res =&gt; &#123; let mod = eval(res.text()); mod.MODULE_STATES.forEach(state =&gt; &#123; this.uiRouter.stateRegistry.register(state); &#125;); this.loadedModules.add(moduleName); resolve(); &#125;).catch(err =&gt; reject(err)); &#125;); &#125;&#125; 通过请求指定的文件，然后利用eval执行出具体的state数组，通过register方法，动态注入到我们的ui-router中。 注意invalidCallbacks回调中的参数($from$, $to$)，必须使用这两个名字，通过分析源代码发现它是用参数名做了匹配的，如果换成其他名称，会提示注入错误。 invalidCallbacks回调中的逻辑非常关键，演示了如何获取原始要跳转的state，也演示了如何恢复继续跳转。 4、更多待探索当前对 ui-router-ng2 的探索还不够多，另外它本身也还在beta版本，该处理方式应该还有优化空间。"},{"title":"08_Angular2动态加载组件","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/Angular2一路向前/08_Angular2动态加载组件/","text":"0、为什么需要动态加载在一个比较大的应用程序中，我们不可能将所有的业务逻辑一次性加载出来，比较浪费资源，因为单个用户一般用不到所有的功能，这个时候，就需要部分组件动态加载了。 1、Angular2如何动态加载组件在Angular2，有一个服务是 DynamicComponentLoader，我们就可以通过它来进行动态加载组件。 首先要使用它的话，我们必须要在providers中指定它。 另外，它还有一些必须的依赖，是 injector，当引入了这些元素之后，我们就可以实现一个加载组件的方法： 123456789101112131415161718192021class AppComponent &#123; constructor(dynamicComponentLoader, viewContainerRef, injector) &#123; this.dynamicComponentLoader = dynamicComponentLoader; this.viewContainerRef = viewContainerRef; this.injector = injector; &#125; //动态加载组件的方法，需要传入一个组件 loadComponent(component) &#123; this.viewContainerRef.clear(); this.dynamicComponentLoader.loadAsRoot(component, '#component-container', this.injector) .then((componentRef) =&gt; &#123; //必须要这样来编写，否则会导致双向绑定表达式获取不到值。 componentRef.changeDetectorRef.detectChanges(); componentRef.onDestroy(() =&gt; &#123; componentRef.changeDetectorRef.detach(); &#125;); return componentRef; &#125;); &#125;&#125; 在以上代码中，核心就是 dynamicComponentLoader 的 loadAsRoot 方法，这个方法里面有个参数是 &#39;#component-container&#39;，实际上指定将动态加载的组件放置的容器， 123&lt;div id=\"content\"&gt; &lt;child id=\"component-container\"&gt;&lt;/child&gt;&lt;/div&gt; 通过这样的方式，我们就能够动态的把组件加载到页面上了。 注：dynamicComponentLoader 还有一个加载方法是 loadNextToLocation(component, viewContainerRef)，只需要提供要动态加载的组件和一个容器引用，就可以将组件加载到容器中了。"},{"title":"07_Angular2使用路由","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/Angular2一路向前/07_Angular2使用路由/","text":"0、关于路由此处所说的路由是指URL路由（也许叫URL Rewrite）。其实是把网址（URL）映射到相关Controller、Component的这个功能。 Angular2的路由其实也就是URL路由，在Angular2中，有两个模块提供了路由功能，@angular/router-deprecated 和 @angular/router。 @angular/router-deprecated 从名称也可以看出，它是一个过时的模块（beta版本中它的名字是 angular2/router，在rc版本被更名）。但疑惑的是，它一直存在于 @angular 包中。在这里，我主要使用 @angular/router 来实现路由功能。 1、使用Angular2路由建议在根组件中配置路由。要使用路由，必须先依赖 ROUTER_PROVIDERS；如果要使用路由指令，必须先依赖 ROUTER_DIRECTIVES。 大概结构如下： 1234567891011 //bootstrap.tsimport &#123;provide&#125; from '@angular/core';import &#123;bootstrap&#125; from '@angular/platform-browser-dynamic';import &#123;LocationStrategy, HashLocationStrategy&#125; from '@angular/common';import &#123;AppComponent&#125; from './app/app.component';bootstrap(AppComponent, [ provide(LocationStrategy, &#123; useClass: HashLocationStrategy &#125;)]); 1234567891011121314151617181920212223242526272829//app.component.tsimport &#123;Component, provide&#125; from '@angular/core';import &#123;Routes, ROUTER_DIRECTIVES, ROUTER_PROVIDERS&#125; from '@angular/router';import &#123;HomeComponent&#125; from './../home/home.component';import &#123;AboutComponent&#125; from './../about/about.component';@Component(&#123; selector: 'demo-app', template: `&lt;h3&gt;Angular2 Router Test&lt;/h3&gt;&lt;a [routerLink]=\"['/home']\"&gt;Home&lt;/a&gt;&lt;a [routerLink]=\"['/about']\"&gt;About&lt;/a&gt; &lt;router-outlet&gt;&lt;/router-outlet&gt; `, directives: [ROUTER_DIRECTIVES], providers: [ROUTER_PROVIDERS]&#125;)@Routes([ &#123; path: '/home', component: HomeComponent&#125;, &#123; path: '/about', component: AboutComponent &#125;])export class AppComponent &#123; constructor() &#123; console.log('app init'); &#125;&#125; 通过 @Routes，我们可以配置路由对应的组件。当然，要求这些组件必须已经存在。在配置路由节点的时候，我们仅仅需要提供 path 和 component 参数。 在模板中使用 [routerLink] 可以配置连接，它的值是一个数组，第一个元素是要导向的url，第二个参数是路由参数。 除了使用 [routerLink] 实现路由跳转，还可以使用特定服务来跳转，代码如下： 12this.router.navigate(['/about']);this.router.navigateByUrl('/about'); 当URL比较复杂，如/home/test/index时，使用navigate方式如下： 1this.router.navigate(['home', 'test' ,'index']); 2、路由参数有时候，我们需要给路由传递一些参数，这个时候就需要在配置路由的时候，指定参数。使用 [routerLink] 的方式如下: 1&lt;a [routerLink]=\"['/about', &#123;id: 1&#125;]\"&gt;About&lt;/a&gt; 那么如何获取这个参数呢？就需要在 AboutComponent 组件中通过 RouteSegment 来获取，代码如下： 12345export class AboutComponent &#123; constructor(private routeSegment: RouteSegment) &#123; console.log('about init', 'params:', routeSegment.parameters); &#125;&#125; 3、嵌套路由（子路由）一般来说，我们写一个中大型的应用程序，一个一级路由根本就不够使用。这个时候，就可以使用嵌套路由来把应用程序拆分成很多小的模块。 在这种情况下，就需要我们的子组件也需要使用 @Routes 来申明自己的路由体系。 1234567891011121314151617181920212223242526272829303132333435//about.component.tsimport &#123;Component&#125; from '@angular/core';import &#123;ROUTER_DIRECTIVES, Routes, RouteSegment&#125; from '@angular/router';import &#123;AboutUserComponent&#125; from './about-user.component';import &#123;AboutMeComponent&#125; from './about-me.component';@Component(&#123; selector: 'demo-about', template: ` &lt;h1&gt;About&lt;/h1&gt; &lt;a [routerLink]=\"['/home']\"&gt;Go to Home&lt;/a&gt; &lt;a [routerLink]=\"['./user', id]\"&gt;Go to About User&lt;/a&gt; &lt;a [routerLink]=\"['./me']\"&gt;Go to About Me&lt;/a&gt; &lt;router-outlet&gt;&lt;/router-outlet&gt; `, directives: [ROUTER_DIRECTIVES]&#125;)@Routes([ &#123; path: '/', component: AboutUserComponent &#125;, &#123; path: '/user/:id', component: AboutUserComponent &#125;, &#123; path: '/me', component: AboutMeComponent &#125;])export class AboutComponent &#123; private id: number = 1; constructor(private routeSegment: RouteSegment) &#123; console.log('about init', 'params:', routeSegment.parameters); &#125; &#125; 在这段代码里，我们需要注意，[routerLink]的值，有些是 [&#39;/home&#39;], 也有 [&#39;./me] 这种，它们有什么区别呢？ 其实直接 ‘/home’ 是指从根路径开始计算，也就是跳转到父路由，真实路径就是 /home。如果是使用的 ‘./me’ 这种形式，那么是相对路径，所以点击这个链接，跳转到的实际上是 /about/me 这个地址。 4、生命周期钩子（拦截器）在路由中，我们可以通过实现 CanDeactivate 来控制路由是否可以被解除；还可以通过实现 OnActivate 来控制路由激活后的操作。 当我们在 HomeComponent 中编写如下语句时： 123456routerCanDeactivate(curTree: RouteTree, futureTree: RouteTree) &#123; console.log('abc'); return new Promise((resolve, reject) =&gt; &#123; resolve(false); &#125;);&#125; 当进入Home页之后，我们就已经无法跳出了。 当我们在 HomeComponent 中编写如下语句时： 123routerOnActivate(currSegment: RouteSegment, prev: RouteSegment, currTree: RouteTree, prevTree: RouteTree)&#123; console.log('succeed');&#125; 每一次跳转到Home组件，我们都能在控制台看到输出 succeed 。 很遗憾的是，暂时没有发现有全局的路由钩子，这也就意味着，我们没法在一个地方控制所有的路由是否允许被解除。 5、后记以上就是Angular2路由的简单使用了。相关Demo，请点击 这里 在Angular2中，还有一个路由是 @angular/router-deprecated，它是之前的路由方式，由于已经被标注为过期，这里就不在说明，如果想了解一下，可以查看 Demo 至于更复杂的动态路由，动态加载组件等等，未完待续…"},{"title":"06_Angular2管道（Pipe）简析","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/Angular2一路向前/06_Angular2管道（Pipe）简析/","text":"0、Angular2 Pipe注：由于Angular2的API好不够稳定，书写该文时，采用的是Angular2 rc1（@angular rc.1）版本，其他版本请自行测试。 对于 Pipe，其实我们并不陌生。在angular1中，它被称之为 filter。 Pipe用于对数据进行格式化处理，就好比管道，一个进一头出，中间过程就是管道的处理逻辑。 Angular2中的 Pipe 本质上是包含特定方法的类。 1、编写一个简单PipePipe 相对于指令和组件来说，非常简单，我们仅仅需要编写一个类： 123class EmptyToZero&#123; &#125; 实现特定的方法： 12345678exprt class EmptyToZero&#123; transform(v: any, args: any[])&#123; if(v === undefined || v === null || v === '')&#123; return 0; &#125; return v; &#125;&#125; 使用 Pipe 装饰，请设定名称: 1234567891011import &#123;Pipe&#125; from '@angular/core';@Pipe(&#123; name: 'empty2zero' &#125;)export class EmptyToZero &#123; transform(v: any, args: any[]) &#123; if (v === undefined || v === null || v === '') &#123; return 0; &#125; return v; &#125;&#125; 如何使用？ 1&lt;span&gt;&#123;&#123; value | empty2zero&#125;&#125;&lt;/span&gt; 当然前提是要在Component中申明要使用的Pipe： 123456@Component(&#123; selector: 'todo-list', template: require('./todo-list.component.html'), styles : [require('./todo-list.component.css')], pipes:[EmptyToZero]&#125;) 2、有状态的Pipe在使用 Pipe 装饰器的时候，我们可以提供两个参数： 1234@Pipe(&#123; name: 'empty2zero', //string类型，必填项，指定pipe的名称 pure: true //boolean类型，可选项，默认为true，设定为true时，表示无状态管道。无论是输入或者是什么参数的改变都会触发重新计算结果。&#125;) 有状态的 Pipe 可以收到一个Promise对象或者检测输入和自动订阅输入，最终返回一个可触发的值。 要使用有状态的管道，必须将pure属性设置为false。 比较典型的有状态异步管道如下： 1234567891011121314151617import &#123;Pipe&#125; from 'angular2/core';@Pipe(&#123; name: 'fetch', pure: false&#125;)export class FetchJsonPipe &#123; private fetchedValue:any; private fetchPromise:Promise&lt;any&gt;; transform(value:string, args:string[]):any &#123; if (!this.fetchPromise) &#123; this.fetchPromise = window.fetch(value) .then((result:any) =&gt; result.json()) .then((json:any) =&gt; this.fetchedValue = json); &#125; return this.fetchedValue; &#125;&#125;"},{"title":"C#中处理耗时任务的几种方式","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/C#/C#中处理耗时任务的几种方式/","text":"0、准备首先，我们先创建几个耗时任务： public class TestTasks { //无参、无返回值任务 public void Task1() { Console.WriteLine(&quot;task1.&quot;); Thread.Sleep(5000); Console.WriteLine(&quot;task1 completed.&quot;); } //有参数、无返回值任务 public void Task2(int x) { if (x &lt; 2000) { x += 2000; } Console.WriteLine(&quot;task2.&quot;); Thread.Sleep(x); Console.WriteLine(&quot;task2 completed.&quot;); } //有参数，有返回值任务 public int Task3(int x) { if (x &lt; 2000) { x += 2000; } Console.WriteLine(&quot;task3.&quot;); Thread.Sleep(x); Console.WriteLine(&quot;task3 completed.&quot;); return x; } } 1、创建新线程执行方法var tt = new TestTasks(); new Thread(tt.Task1).Start(); //针对有参数的任务，需要用Lambda进行包装或者使用ParameterizedThreadStart对象 new Thread(x=&gt;tt.Task2((int)x)).Start((object)1000); //使用ParameterizedThreadStart，要求要执行的方法参数必须为object，同时无返回值。 //new Thread(new ParameterizedThreadStart(tt.Task2)).Start((object)1000); 注意：使用该方式无法执行带返回值的方法。 推荐指数：★★ 2、使用异步调用方式执行方法var tt = new TestTasks(); Action ac = tt.Task1; Action&lt;int&gt; ac2 = tt.Task2; ac.BeginInvoke(null, null); ac2.BeginInvoke(1000, null, null); //以下是调用有参数，有返回值的方法 //代码一 private delegate int AsyncCaller(int x); //该代码放在方法体外部 AsyncCaller ac = new AsyncCaller(tt.Task3); var asyncResult = ac.BeginInvoke(1000,null,null); int result = ac.EndInvoke(asyncResult); //接收返回值 //代码二，使用Func简化代码 Func&lt;int,int&gt; ac = tt.Task3; var asyncResult = ac.BeginInvoke(1000,null,null); int result = ac.EndInvoke(asyncResult); 注意：通过这种方式生成新线程是运行在后台的（background）,优先级为normal 推荐指数：★★ 3、通过ThreadPool（线程池）执行方法var tt = new TestTasks(); ThreadPool.QueueUserWorkItem(o =&gt; tt.Task1()); ThreadPool.QueueUserWorkItem(o =&gt; tt.Task2(1000)); 注意：该方式不支持返回值，可以将返回值保存在引入类型的参数上，然后进行迂回实现 推荐指数：★★★ 4、通过BackgroundWorker（后台Worker）执行方法var tt = new TestTasks(); var bw = new BackgroundWorker(); bw.DoWork += (sender, e) =&gt; tt.Task1(); bw.DoWork += (sender, e) =&gt; tt.Task2(1000); //要接收返回值，必须将返回值赋值给Result。 bw.DoWork += (sender, e) =&gt; e.Result = tt.Task3(1000); bw.RunWorkerAsync(); //注册事件使用返回值 bw.RunWorkerCompleted += (sender, e) =&gt; Console.WriteLine(e.Result); 注意：使用BackgroundWorker注册DoWork事件的任务只能挨个执行，如果要同时执行多个任务，需要多个BackgroundWorker。要使用返回值，一定要记得赋值给Result。 推荐指数：★★ 5、同时Task执行方法var tt = new TestTasks(); var t1 = Task.Factory.StartNew(tt.Task1); var t2 = Task.Factory.StartNew(() =&gt; tt.Task2(1000)); var t3 =Task.Factory.StartNew(() =&gt; tt.Task3(1000)); //等待t1,t2,t3执行完成 Task.WaitAll(t1,t2,t3); Console.WriteLine(t3.Result); 注意：Task具有灵活的控制能力，同时可以单个等待，多个等待。 推荐指数：★★★★★ 6、使用async/await执行方法private async void AsyncRunTask() { var tt = new TestTasks(); await Task.Factory.StartNew(tt.Task1); await Task.Factory.StartNew(() =&gt; tt.Task2(1000)); var result = await Task.Factory.StartNew(() =&gt; tt.Task3(1000)); Console.WriteLine(result); } AsyncRunTask(); Console.WriteLine(&quot;不用等待，我先执行了。&quot;); 注意：需要Framework4.5的支持 推荐指数：★★★★ The End没有原理，没有言语，相信以大家聪明的大脑，已经学会如何在C#中执行耗时任务和使用多线程了。"},{"title":"跟我学Angular2（1-初体验）","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/Angular2一路向前/跟我学Angular2（1-初体验）/","text":"0、导言Angular1作为最流行的前端MV*框架，给前端开发带来了极大的便利性。但是，仍然有许多不好的地方已经很难再改变了。Angular团队根据WEB发展的趋势和Angular1中积累的经验来开发了一个全新的Angular，也就是Angular2。 1、优势Angular2做了很激进的变化，带来的成果也是显而易见的。 极大的提高了性能 更强大的模块化 改进的依赖注入 对Web Component友好 原生移动支持 - iOS 和 Android 服务端渲染，搜索引擎优化 2、工具链由于Angular2面向未来，使用了太多还不被当前主流浏览器支持的技术，跑起来还真不是一个容易的事情，所以我们需要一个工具链： systemjs - 通用模块加载器，支持AMD、CommonJS、ES6等各种格式的JS模块加载 es6-module-loader - ES6模块加载器，systemjs会自动加载这个模块 traceur - ES6转码器，将ES6代码转换为当前浏览器支持的ES5代码。systemjs会自动加载 这个模块。 3、Angular2 Hello worldStep1、下载angular2https://angular.io/是angular2的官网，我们需要通过npm进行下载angular2： npm install angular2 https://www.npmjs.com/package/angular2。 Step2、引入angular2&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=&quot;../node_modules/angular2/bundles/angular2.sfx.dev.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; Step3、 Hello angular&lt;body&gt; &lt;app&gt;&lt;/app&gt; &lt;script&gt; var App = ng.Component({ selector: &apos;app&apos;, template: &apos;&lt;h1&gt;Hello {{name}}.&lt;/h1&gt;&apos; }).Class({ constructor: function() { this.name = &apos;Angular2&apos;; } }); ng.bootstrap(App); &lt;/script&gt; &lt;/body&gt;"},{"title":"jQuery中那些有趣的代码","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/jQuery拆解/jQuery中那些有趣的代码/","text":"0、动态执行JS代码123456function DOMEval(code, doc) &#123; doc = doc || document; var script = doc.createElement(\"script\"); script.text = code; doc.head.appendChild(script).parentNode.removeChild(script);&#125; 1、"},{"title":"01-目录篇","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/jQuery拆解/01-目录篇/","text":"0、导言jQuery 作为最流行的DOM操作库，已经基本上成了浏览器的事实标准。抱着学习高效dom操作的目的，我就来整个系列，来拆解下 jQuery。 在这里，我选择的当前最新版本的 jQuery(3.1.1) 来分析。 1、jQuery功能块为了简化分析过程，我将 jQuery 分为如下几个部分，然后针对每个部分进行单独分析。 模块化加载&amp;防冲突处理 基础结构"},{"title":"CSS3入门之文本与字体","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/CSS3学习之路/CSS3入门之文本与字体/","text":"1、CSS3文本效果1.1、text-shadow文本阴影语法：text-shadow: h-shadow v-shadow blur color;(&lt;水平阴影&gt;，&lt;垂直阴影&gt;，[模糊距离]，[阴影颜色]) 示例： &lt;h1 style=&quot;text-shadow: 5px 5px 2px green;&quot;&gt;我是文本阴影&lt;/h1&gt; &lt;h1 style=&quot;text-shadow: 0 0 5px blue;&quot;&gt;我是文本阴影&lt;/h1&gt; &lt;h1 style=&quot;text-shadow: 2px 2px 4px #000000;color: white;&quot;&gt;我是文本阴影&lt;/h1&gt; 我是文本阴影 我是文本阴影 我是文本阴影 该属性兼容IE10+以及所有现代浏览器 1.2、word-break文本换行语法： word-break: normal|break-all|keep-all; normal:默认换行；break-all:允许在单词内换行；keep-all:只能在半角空格或连字符处换行 示例： &lt;div style=&quot;width:100px;word-break:break-all;&quot;&gt;Nice to meet you. good mor-ning.&lt;/div&gt; &lt;div style=&quot;width:100px;word-break:keep-all;&quot;&gt;Nice to meet you. good mor-ning.&lt;/div&gt; Nice to meet you. good mor-ning.Nice to meet you. good mor-ning. 1.3、text-overflow修剪文本语法：text-overflow: clip|ellipsis|string; 示例： &lt;div style=&quot;width: 100px; overflow:hidden; white-space:nowrap;text-overflow: clip;&quot;&gt;Nice to meet you. good mor-ning.&lt;/div&gt; &lt;div style=&quot;width: 100px; overflow:hidden; white-space:nowrap;text-overflow: ellipsis;&quot;&gt;Nice to meet you. good mor-ning.&lt;/div&gt; Nice to meet you. good mor-ning.Nice to meet you. good mor-ning. 注意：使用text-overflow的时候，需要与overflow:hidden;white-space:nowrap;协同使用 2、CSS3字体在CSS3之前，必须使用已经在用户计算机上安装好的字体，给Web设计带来很大的局限性。现在，通过CSS3,Web设计师可以使用他们喜欢的任意字体。 2.1、@font-face引入网络字体Firefox、Chrome、Safari 以及 Opera 支持 .ttf (True Type Fonts) 和 .otf (OpenType Fonts) 类型的字体。 Internet Explorer 9+ 支持新的 @font-face 规则，但是仅支持 .eot 类型的字体 (Embedded OpenType)。 不兼容IE8，IE8-。 示例： &lt;style&gt; @font-face { font-family: SentyPaperCut; src:url(http://hstarcdn.github.io/fonts/SentyPaperCut.ttf); } @font-face { font-family:SentyCreamPuff; src:url(http://hstarcdn.github.io/fonts/SentyCreamPuff.otf); } .font1,.font2{ font-size: 50px; } .font1{ color: red; font-family: SentyTEA-Platinum; } .font2{ color: blue; font-family: SentyCreamPuff; } &lt;/style&gt; &lt;span class=&quot;font1&quot;&gt; 自定义字体演示 &lt;/span&gt; &lt;span class=&quot;font2&quot;&gt; 自定义字体演示 &lt;/span&gt; @font-face { font-family: SentyTEA-Platinum; src:url(http://hstarcdn.github.io/fonts/SentyTEA-Platinum.ttf); } @font-face { font-family:SentyCreamPuff; src:url(http://hstarcdn.github.io/fonts/SentyCreamPuff.otf); } .font1,.font2{ font-size: 50px; } .font1{ color: red; font-family: SentyTEA-Platinum; } .font2{ color: blue; font-family: SentyCreamPuff; } 自定义字体演示 自定义字体演示 除此之外，在@font-face中，还可以设置多种字体描述符，如： 描述符值描述font-familyname必需。规定字体的名称。srcURL必需。定义字体文件的 URL。font-stretch normal condensed ultra-condensed extra-condensed semi-condensed expanded semi-expanded extra-expanded ultra-expanded 可选。定义如何拉伸字体。默认是 “normal”。font-style ormal italic oblique 可选。定义字体的样式。默认是 “normal”。font-weight normal bold 100 200 300 400 500 600 700 800 900 可选。定义字体的粗细。默认是 “normal”。unicode-rangeunicode-range可选。定义字体支持的 UNICODE 字符范围。默认是 “U+0-10FFFF”。"},{"title":"10_Angular2模块","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/Angular2一路向前/10_Angular2模块/","text":"0、导言该Angular2系列，从10开始，则对应 Angular2 正式版本。"},{"title":"CSS3入门之转换","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/CSS3学习之路/CSS3入门之转换/","text":"1、CSS3 转换1.1、转换是什么，能实现哪些效果？转换是使元素改变形状、尺寸和位置的一种效果，主要能实现的效果如下： 移动 缩放 转动 拉长 拉伸 1.2、浏览器兼容CSS3的转换属性为 transform ，IE10+,Firefox,Chrome,Opera,Safari等现代浏览器支持transform属性，IE9需要-ms-前缀。 2、 2D 转换准备工作： &lt;style&gt; .container{ position:relative;border:1px solid red; width: 100px; height: 100px; } .container&gt;div{ width: 50px; height: 50px; background: gray; } &lt;/style&gt; .container{ position:relative;border:1px solid red; width: 100px; height: 100px; } .container div{ width: 50px; height: 50px; background: gray; } 2.1、translate() – 移动translate(/*x坐标移动位移*/ left, /*y坐标移动位移*/ top) &lt;h3&gt;右移20px&lt;/h3&gt; &lt;div class=&quot;container&quot;&gt; &lt;div style=&quot;transform: translate(20px);&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;h3&gt;下移20px&lt;/h3&gt; &lt;div class=&quot;container&quot;&gt; &lt;div style=&quot;transform: translate(0px,20px);&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;h3&gt;左移20px，下移20px&lt;/h3&gt; &lt;div class=&quot;container&quot;&gt; &lt;div style=&quot;transform: translate(-20px,20px);&quot;&gt;&lt;/div&gt; &lt;/div&gt; 右移20px 下移20px 左移20px，下移20px 2.2、rotate() – 旋转rotate(/*旋转角度*/ deg) &lt;h3&gt;旋转135度&lt;/h3&gt; &lt;div class=&quot;container&quot;&gt; &lt;div style=&quot;transform: rotate(135deg);&quot;&gt;&lt;/div&gt; &lt;/div&gt; 旋转135度 2.3、scale() – 缩放scale(/*宽度缩放比例*/ widthScale, /*高度缩放比例*/ heightScale) &lt;h3&gt;缩放到0.5倍&lt;/h3&gt; &lt;div class=&quot;container&quot;&gt; &lt;div style=&quot;transform: scale(0.5, 0.5);&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;h3&gt;宽度缩放到1.5倍，高度缩放到0.25倍&lt;/h3&gt; &lt;div class=&quot;container&quot;&gt; &lt;div style=&quot;transform: scale(1.5, 0.25);&quot;&gt;&lt;/div&gt; &lt;/div&gt; 缩放到0.5倍 宽度缩放到1.5倍，高度缩放到0.25倍 2.4、skew() – 倾斜skew(/*X轴倾斜角度*/ xDeg, /*Y轴倾斜角度*/ yDeg) &lt;h3&gt;X轴翻转30度&lt;/h3&gt; &lt;div class=&quot;container&quot;&gt; &lt;div style=&quot;transform: skew(30deg);&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;h3&gt;X轴翻转30度，Y轴翻转10度&lt;/h3&gt; &lt;div class=&quot;container&quot;&gt; &lt;div style=&quot;transform: skew(30deg, 10deg)&quot;&gt;&lt;/div&gt; &lt;/div&gt; X轴翻转30度 X轴翻转30度，Y轴翻转10度 2.5、matrix() –矩阵&lt;h3&gt;旋转30度&lt;/h3&gt; &lt;div class=&quot;container&quot;&gt; &lt;div style=&quot;transform: matrix(0.866,0.5,-0.5,0.866,0,0)&quot;&gt;&lt;/div&gt; &lt;/div&gt; 旋转30度 2.6 Transform方法函数描述matrix(n,n,n,n,n,n)定义 2D 转换，使用六个值的矩阵。translate(x,y)定义 2D 转换，沿着 X 和 Y 轴移动元素。translateX(n)定义 2D 转换，沿着 X 轴移动元素。translateY(n)定义 2D 转换，沿着 Y 轴移动元素。scale(x,y)定义 2D 缩放转换，改变元素的宽度和高度。scaleX(n)定义 2D 缩放转换，改变元素的宽度。scaleY(n)定义 2D 缩放转换，改变元素的高度。rotate(angle)定义 2D 旋转，在参数中规定角度。skew(x-angle,y-angle)定义 2D 倾斜转换，沿着 X 和 Y 轴。skewX(angle)定义 2D 倾斜转换，沿着 X 轴。skewY(angle)定义 2D 倾斜转换，沿着 Y 轴。 3、3D 转换3.1、rotateX、rotateY&lt;div class=&quot;container&quot;&gt; &lt;div style=&quot;transform: rotateY(0deg)&quot; id=&quot;fun2&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; function fun2 (element) { var i = 0; var interval = setInterval(function(){ element.style.transform = &apos;rotateY(&apos; + i + &apos;deg)&apos;; i++; }, 5); } fun2(document.getElementById(&apos;fun2&apos;)); &lt;/script&gt; function fun2 (element) { var i = 0; var interval = setInterval(function(){ element.style.transform = 'rotateY(' + i + 'deg)'; i++; }, 5); } fun2(document.getElementById('fun2')); 3.2、Transform方法函数描述matrix3d(n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n)定义 3D 转换，使用 16 个值的 4x4 矩阵。translate3d(x,y,z)定义 3D 转化。translateX(x)定义 3D 转化，仅使用用于 X 轴的值。translateY(y)定义 3D 转化，仅使用用于 Y 轴的值。translateZ(z)定义 3D 转化，仅使用用于 Z 轴的值。scale3d(x,y,z)定义 3D 缩放转换。scaleX(x)定义 3D 缩放转换，通过给定一个 X 轴的值。scaleY(y)定义 3D 缩放转换，通过给定一个 Y 轴的值。scaleZ(z)定义 3D 缩放转换，通过给定一个 Z 轴的值。rotate3d(x,y,z,angle)定义 3D 旋转。rotateX(angle)定义沿 X 轴的 3D 旋转。rotateY(angle)定义沿 Y 轴的 3D 旋转。rotateZ(angle)定义沿 Z 轴的 3D 旋转。perspective(n)定义 3D 转换元素的透视视图。"},{"title":"Angular2踩坑大全","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/Angular2一路向前/Angular2踩坑大全/","text":"Angular2的那些坑1、同样的代码，引用Rxjs库的版本不对，就会导致在IE11下无法运行。(特定版本下重现)正确的版本：https://code.angularjs.org/2.0.0-beta.12/Rx.js 2、在使用TypeScript编写Angular2代码时，一定要将注意 tsconfig.json，其中 experimentalDecorators 和 emitDecoratorMetadata 必须要设置为true，否则无法使用依赖注入。 3、&lt;router-outlet&gt; 不能放在带有 *ngIf的容器内，否则会出现初始化时无法找到。"},{"title":"CSS3入门之边框与背景","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/CSS3学习之路/CSS3入门之边框与背景/","text":"1、前言CSS3作为CSS的最新版本，在展示效果上有非常大的提升，接下来，我们就一起领略一下CSS3的风采吧。 2、CSS3边框12345678&lt;style&gt; .td&#123; width: 200px; height: 100px; border: 1px solid black; margin: 10px 0; &#125;&lt;/style&gt; 2.1、border-radius(用于设置圆角边框)在CSS2时代，要想实现圆角边框，是一件非常麻烦的事情。一种实现方式是使用一个背景图片，为了实现伸缩效果，还需要至少3张图片拼凑，相当麻烦。另外一种实现方式是使用多个div重叠来实现圆角。 在CSS3中，有一个非常简单的属性，那就是border-radius。 语法： border-radius: 1-4 length|% / 1-4 length|%; 123456border-radius: 10px;//等价于border-top-left-radius:10px;border-top-right-radius:10px;border-bottom-right-radius:10px;border-bottom-left-radius:10px; 演示圆角边框 演示圆角边框 兼容性说明： IE9+，Chrome,FF,Safari,Oprea123456div&#123; border:2px solid; border-radius:25px; -moz-border-radius:25px; /* Old Firefox */&#125; 2.2、box-shadow(用于添加边框阴影)语法： box-shadow: h-shadow v-shadow blur spread color inset;,其中h-shadow和v-shadow是必须设置，允许负值。【参数说明：水平阴影的位置，垂直阴影的位置，模糊距离，阴影的尺寸，阴影的颜色，外部引用(outset)改为内部阴影】 123456789101112131415161718192021222324252627282930&lt;div class=\"td\" style=\"border-radius:10px; border: 1px solid red;\"&gt; 演示圆角边框&lt;/div&gt;&lt;div class=\"td\" style=\"box-shadow: 2px 2px red;\"&gt; 简单阴影&lt;/div&gt;&lt;div class=\"td\" style=\"box-shadow: -2px -2px red;\"&gt; 简单阴影&lt;/div&gt;&lt;div class=\"td\" style=\"box-shadow: -2px -2px red;\"&gt; 简单阴影&lt;/div&gt;&lt;div class=\"td\" style=\"box-shadow: -2px -2px 10px red;\"&gt; 带模糊效果的阴影&lt;/div&gt;&lt;div class=\"td\" style=\"box-shadow: -2px -2px 10px red;\"&gt; 带模糊效果的阴影&lt;/div&gt;&lt;div class=\"td\" style=\"box-shadow: 2px 2px 10px 10px red;\"&gt; 带模糊效果指定尺寸的阴影&lt;/div&gt;&lt;div class=\"td\" style=\"box-shadow: 2px 2px 10px 10px red;\"&gt; 带模糊效果指定尺寸的阴影&lt;/div&gt;&lt;div class=\"td\" style=\"box-shadow: 2px 2px 10px 10px red inset;\"&gt; 内部阴影&lt;/div&gt;&lt;div class=\"td\" style=\"box-shadow: 2px 2px 10px 10px red inset;\"&gt; 内部阴影&lt;/div&gt; 兼容性说明： IE9+，Chrome,FF,Safari,Oprea 2.3、border-image(CSS3边框图片)border-image是简写属性，全部是： 12345border-image-source //背景图片源border-image-slice //图片边框内偏移border-image-width //图片边框的宽度border-image-outset //边框图像区域超出边框的量border-image-repeat //边框是否适应平铺(repeated)、铺满(rounded)、拉伸(stretched) 123456789101112&lt;div style=\"border-width:10px;border-image: url(http://www.w3school.com.cn/i/border.png) 10 10 round;\"&gt; 简单图片边框&lt;/div&gt;&lt;div style=\"border-width:10px;border-image: url(http://www.w3school.com.cn/i/border.png) 10 10 round\"&gt; 简单图片边框&lt;/div&gt;&lt;div style=\"border-width:10px;border-image: url(http://www.w3school.com.cn/i/border.png) 10 10 50 round\"&gt; 完全设置的图片边框&lt;/div&gt;&lt;div style=\"border-width:10px;border-image: url(http://www.w3school.com.cn/i/border.png) 10 10 50 round\"&gt;完全设置的图片边框&lt;/div&gt; 兼容性说明： Chrome,FF,Safari,Oprea1234567div&#123; border-image:url(border.png) 30 30 round; -moz-border-image:url(border.png) 30 30 round; /* 老的 Firefox */ -webkit-border-image:url(border.png) 30 30 round; /* Safari 和 Chrome */ -o-border-image:url(border.png) 30 30 round; /* Opera */&#125; 3、CSS3背景整体兼容性以下CSS背景的特性，全部支持IE9+,FF,Chrome,Safari,Oprea 3.1、background-size(用于规定背景图片的尺寸)在以前的CSS中，背景图片的大小，是由图片本身的大小决定的。在CSS3中，有一个简单的CSS样式可以设置背景图片的大小，允许我们在不同的环境中重复使用背景图片。可以以像素或百分比规定尺寸。123456789&lt;div style=\" background-image:url(http://www.w3school.com.cn/i/bg_flower_small.gif); background-size: 50% 70%; background-repeat:no-repeat;\"&gt;&lt;/div&gt;&lt;div style=\"background-image:url(http://www.w3school.com.cn/i/bg_flower_small.gif);background-size: 50% 70%;background-repeat:no-repeat;\"&gt; 简单设置背景图大小&lt;/div&gt; 3.2、background-origin(规定背景图片的定位区域)盒子模型示意图： background-origin属性则可以设置背景图片放置于哪个区域上（content-box,padding-box,border-box） 1234567891011121314&lt;div style=\"width:66px;height:125px;background-image:url(http://www.w3school.com.cn/i/bg_flower_small.gif);background-origin:content-box; padding: 20px;border:20px solid red;\"&gt;&lt;/div&gt;&lt;div style=\"width:66px;height:125px;background-image:url(http://www.w3school.com.cn/i/bg_flower_small.gif);background-origin:border-box; padding: 20px;border:20px solid red;\"&gt;&lt;/div&gt;&lt;div style=\"width:66px;height:125px;background-image:url(http://www.w3school.com.cn/i/bg_flower_small.gif);background-origin:padding-box;padding: 20px;border:20px solid red;\"&gt;&lt;/div&gt; 3.3、多重背景可以针对标签设置多个背景，用法如下： 1234body&#123; background-image:url(bg_flower.gif),url(bg_flower_2.gif);&#125;"},{"title":"Angular再回首(1)-Component组件","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/Angular相关/Angular再回首(1)-Component组件/","text":"0、再谈组件Component(组件) 在 Angular1 就已经有雏形了，那就是指令。在 Angular2 中，组件的概念被大大的强化，甚至是Angular2的核心概念。 在前端这么多年的演变中，组件也反哺到 Angular1，成为 Angular1 的一种重要特性，在此之前，我们仅仅可以用 Directive 来实现类似组件的效果。 1、Angular组件与指令在 Angular 1.5.x 中，新增加了 angular.component 方法，用于实现组件的构造。 在此之前，我们可能用 angular.directive 来实现类似的效果。 这个时候我们可能就会疑惑，它们有什么区别呢？ Feature Directive Component bindings No Yes (binds to controller) bindToController Yes (default: false) No (use bindings instead) compile function Yes No controller Yes Yes (default function() {}) controllerAs Yes (default: false) Yes (default: $ctrl) link functions Yes No multiElement Yes No priority Yes No require Yes Yes restrict Yes No (restricted to elements only) scope Yes (default: false) No (scope is always isolate) template Yes Yes, injectable templateNamespace Yes No templateUrl Yes Yes, injectable terminal Yes No transclude Yes (default: false) Yes (default: false) 更多信息，请参考 Angular 官方说明 从上表我们可以看出，对于 Directive，Component 从设计思路上更加完善，也更加纯粹。总得来说，组件显得更易理解，更简单易用。 2、组件生命周期在 angular.directive() 中，是没有生命周期这个概念的，我们无法在指令的特定阶段插入自己的逻辑。 但是在 angular.component() 中，则是具有特定的生命周期，以方便我们进行控制。 生命周期如下： $onInit – 指令初始化时执行（放置初始化代码） $onChanges(changesObj) – 组件数据变化时执行，并可获取变更对象 $doCheck() – 执行变更检测时执行 $onDestroy() – 组件释放时执行（放置清理代码） $postLink() – 类似后连接函数 （一般放置dom操作，因为此时组件已经渲染好） 实例： 1234567891011121314151617181920212223242526272829303132333435363738394041((angular, window) =&gt; &#123; class AlertComponent &#123; constructor() &#123; &#125; $onInit() &#123; console.log('init'); &#125; $onChanges(changesObj) console.log('change', changesObj); &#125; $doCheck() &#123; console.log('check'); &#125; $onDestroy() &#123; console.log('destroy'); &#125; $postLink() &#123; console.log('post link'); &#125; &#125; AlertComponent.$inject = []; // 配置依赖项 angular.module('components').component('jAlert', &#123; templateUrl: 'components/alert/alert.html', // scope绑定语法，&lt; 单向绑定（变量），@ 单向绑定（纯字符串）， = 双向绑定，&amp; 事件绑定 bindings: &#123; menuData: '&lt;' &#125;, controller: AlertComponent, controllerAs: '$ctrl', require: '', transclude: false &#125;);&#125;)(window.angular, window); 在页面使用该指令后，可以在控制台看出如下输出： 1234initcheckpost linkN个check（脏检查） 在切换路由，或者其他会删掉该组件的操作时，会看出控制台输出 destroy。 如果中途有数据变化，控制台还会输出 change。 这就是整个组件的生命周期。 3、属性绑定在 directive 中，我们要获取数据，一般会采用 $scope 传参，或者通过link函数来捕获参数。 在新的组件申明中，我们只需要通过 bindings 就可以实现复杂的参数绑定。 简单思考下，我们可能需要哪些绑定呢？ 双向绑定 （双向） 单向绑定变量 （从外到内） 单向绑定属性（字符串）（从外到内） 输出绑定 （从内到外） 在组件的 bindings 属性中，我们也刚好有四种语法，来一一对应这四种绑定。 具体写法如下： 123456bindings: &#123; model: '=', // 双向绑定 title: '@', // 单项绑定字符串（直接用组件上的属性值） key: '&lt;', // 单项绑定变量，取到属性值，然后返回$scope[属性值] onClick: '&amp;' // 输出绑定，执行外部函数&#125; 假设组件标签为 &lt;j-test&gt;，那么用法如下： 1234567$scope = &#123; model: '1', key: 'abc', onClick: () =&gt; &#123; &#125;&#125;; 1&lt;j-test model=\"model\" key=\"key\" title=\"Title\" on-click=\"onClick()\"&gt;&lt;/j-test&gt; 此时，我们在组件中，就能获取到对应的值： 123456&#123; model: 1, // 从scope中取 key: 'abc', // 从scope中取 title: 'Title', // 直接用string onClick: fn // 执行该onClick会触发外部函数$scope.onClick&#125; 注意：关于输出函数传递参数，需要有特定的写法（一定要注意！！！） 在组件中的写法 在组件中，要给该函数传参，必须使用： 1234this.onClick(&#123; param1: 'xxx', param2: 'BBB'&#125;); 的写法，并建议参数名使用 $ 开头，如：$event。 在组件绑定中的写法 1&lt;j-test model=\"model\" key=\"key\" title=\"Title\" on-click=\"onClick(param1, param2)\"&gt;&lt;/j-test&gt; 注意onClick的写法，里面的参数名称，必须和组件中参数对象中的key匹配。 4、给组件设定外部HTML在使用组件过程中，我相信很容易遇到需要使用外部html的组件，如 Tabs, Panel 等，那我们给组件内部传入自定义的HTML呢？ 这个时候，我们可以使用 ng-transclude 4.1、传递单个HTML片段首先，主要在注册组件时，开启 transclude（设置transclude为true），然后我们就可以在组件html中，设定占位符，有如下两种方式： 12345&lt;!-- 占位符1 --&gt;&lt;div ng-transclude&gt;&lt;/div&gt;&lt;!-- 占位符2 --&gt;&lt;ng-transclude&gt;&lt;/ng-transclude&gt; 然后在使用组件的地方，就可以直接把要使用的HTML放在组件标记中，如： 123&lt;j-test&gt; &lt;span&gt;我会被传递到主键内部&lt;/span&gt;&lt;/j-test&gt; 4.2、传递多个HTML片段以上，我们知道了如何传递单个HTML片段，但传递多个HTML片段也是非常有必要的，如 Dialog组件，我们很可能会传递 dialog-header, dialog-body 等等，那此时又应如何呢？ 这个场景，我们可以借助 ng-transclude 的 slot 功能实现， 首先，是占位符的变化，如下： 1234567&lt;!-- 占位符1 --&gt;&lt;div ng-transclude=\"header\"&gt;&lt;/div&gt;&lt;div ng-transclude=\"body\"&gt;&lt;/div&gt;&lt;!-- 占位符2 --&gt;&lt;ng-transclude ng-transclude-slot=\"header\"&gt;&lt;/ng-transclude&gt;&lt;ng-transclude ng-transclude-slot=\"body\"&gt;&lt;/ng-transclude&gt; 其次是组件配置的变化，因为有多个 transclude，那么仅仅设置为 true，就不太能满足需求了。需要修改如下： 1234transclude: &#123; header: '?panelHeader', // panelHeader表示内部标签，?表示是可选的 body: 'panelBody' // 没有问号，表示该节点必选&#125; 接下来，就应该是调用时的改变，调用如下： 12345678&lt;j-panel&gt; &lt;panel-header&gt; 我是Panel Header（可选） &lt;/panel-header&gt; &lt;panel-body&gt; 我是Panel Body（必须） &lt;/panel-body&gt;&lt;/j-panel&gt; 5、组件 require同 Directive 一样，组件也可以相互依赖，只需要在注册组件时，设置require属性即可，写法如下： 123require: &#123; componentCtrl: '^parentComponent'&#125; 6、小结新增的 angular.component 就是这么一个东西，比起 directive 更加纯粹，更加强大，更加易用。建议在后续使用中，多多尝试该方式。"},{"title":"01_初识Canvas，绘制简单图形","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/Canvas学习札记/01_初识Canvas，绘制简单图形/","text":"0、关于Canvas&lt;canvas&gt; 是HTML5新增的一个标签，用于定义图形，比如图表和其他图像。 &lt;canvas&gt; 标签只是图形容器，必须要使用脚本来绘制图形。 一句话概括就是：&lt;canvas&gt; 是浏览器上的画图，允许你通过js自由作画。 Canvas和SVG与VML的不同&lt;canvas&gt; 有一个基于JS的绘图API，它本身并不会绘制图形。SVG和VML都是用一个XML文档来描述图形。 虽然它们在功能上基本相同，但是从表面上来看，它们非常不同。SVG和VML绘图易于编辑，只需要从描述中修改元素属性。而Canvas想移除元素，往往需要擦掉绘图重新绘制它。 Canvas兼容HTML5标准属性和事件&lt;canvas&gt; 作为一个HTML的新标签，标准的HTML属性和事件它都支持。比如可以设置 title、style、class 等属性，也可以使用诸如 onclick 等事件。 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Canvas Test&lt;/title&gt; &lt;style&gt; body&#123; text-align: center; &#125; .c1&#123; border: 1px solid red; height: 600px; width: 800px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id=\"c1\" onclick=\"alert('abc')\" class=\"c1\"&gt;&lt;/canvas&gt;&lt;/body&gt;&lt;/html&gt; 1、使用Canvas要使用canvas，首先，我们先得html中加入canvas标签。最好，再加上一个id属性（也可以不加，只是查找该元素要稍微麻烦点）。 12345678910...&lt;body&gt; &lt;canvas id=\"c1\" onclick=\"alert('abc')\" class=\"c1\"&gt;&lt;/canvas&gt; &lt;script&gt; var c1 =document.getElementById('c1'); // 如果不用id属性，我们可以用如下方式来获取canvas对象 //var c1 = document.getElementsByTagName('canvas')[0]; &lt;/script&gt;&lt;/body&gt;... 在获取到 canvas 元素之后，我们需要通过 getContext(contextID) 方法获取到画布。 当前 contextID的值仅仅可以用’2d’，在未来，可能会允许传递’3d’，来进行三维绘图。 123456789101112...&lt;body&gt; &lt;canvas id=\"c1\" onclick=\"alert('abc')\" class=\"c1\"&gt;&lt;/canvas&gt; &lt;script&gt; var c1 =document.getElementById('c1'); // 如果不用id属性，我们可以用如下方式来获取canvas对象 //var c1 = document.getElementsByTagName('canvas')[0]; var context = c1.getContext('2d'); console.log(context); //可以看到context是一个CanvasRenderingContext2D对象 &lt;/script&gt;&lt;/body&gt;... CanvasRenderingContext2D 对象实现了一个画布所使用的大多数方法。现在我们就需要对它来进行使用，将图像绘制到浏览器上。 1.1、绘制矩形关于矩形的绘制，主要有三个方法： fillRect(x, y, width, height) 用于填充矩形 strokeRect(x, y, width, height) 用于绘制矩形边框 clearRect(x, y, width, height) 用于清空矩形区域（设置矩形区域为空白） 其中 x,y表示从那个点开始绘制。width,height 表示矩形的宽度和高度。 要设置矩形的填充颜色，需要通过 fillStyle 来控制，支持 &#39;red&#39;, &#39;#fff&#39;, &#39;rgb(10,10,10)&#39;, &#39;rgba(10,10,10,10,0.5)&#39;等多种颜色属性。 要设置矩形的边框颜色，需要通过 strokeStyle 来控制，属性值和 fillStyle 一致。 123456789101112...//绘制红色矩形context.fillStyle = 'red'; context.fillRect(10,10,100,100);//绘制蓝色矩形框context.strokeStyle = 'blue';context.strokeRect(150,150,100,100);//清空矩形区域（设置矩形区域为空白）context.clearRect(100,100,100,100);... 1.2、绘制线条我们可以通过 lineTo(x, y) 绘制直线。两点成直线，绘制直线需要两个点，所以我们需要先设置一个起点，一般来说，我们使用 moveTo(x, y) 设置笔触的位置。当然，你也可以用 lineTo(x, y) 来设置一个笔触点。 在没有设置笔触的场景下，以下两段代码的效果完全一致： 123456//画线，设置起点。context.moveTo(200, 200);//设置轨迹context.lineTo(500,500);//画线context.stroke(); 123456//画线，设置起点。context.lineTo(200, 200);//设置轨迹context.lineTo(500,500);//画线context.stroke(); 一般来说，我们会在 canvas 初始化或者 beginPath() 调用后，通过 moveTo(x, y) 来设置一个初始笔触点。 要同时绘制多个线条，我们应该通过 beginPath() 来建立路径。 123456789//用线条绘制了一个矩形context.beginPath();context.moveTo(400, 400);context.lineTo(450, 400);context.lineTo(450, 450);context.lineTo(400, 450);context.closePath();//真实的绘图context.stroke(); 看了以上的代码，可能会有一个疑惑，为什么仅仅三个线条就构成了一个矩形呢？ 原因在于当调用 closePath() 的时候，会把最后的笔触点和最开始的笔触点连接在一起，这个时候也就构成了第四条直线。 注意：当前路径为空，即调用beginPath()之后，或者canvas刚建的时候，第一条路径构造命令通常被视为是moveTo（），无论最后的是什么。出于这个原因，你几乎总是要在设置路径之后专门指定你的起始位置。 闭合路径 closePath(),不是必需的。这个方法会通过绘制一条从当前点到开始点的直线来闭合图形。如果图形是已经闭合了的，即当前点为开始点，该函数什么也不做。 当你调用 fill() 函数时，所有没有闭合的形状都会自动闭合，所以你不需要调用 closePath() 函数。但是调用stroke()时不会自动闭合。 再来填充一个梯形玩玩： 123456context.beginPath();context.moveTo(100, 400);context.lineTo(200, 400);context.lineTo(250, 500);context.lineTo(50, 500);context.fill(); 1.3、绘制矩形线条矩形线条是一个比较常用的图形，所以提供了一个简单的方法来直接绘制： 123456//绘制矩形线条context.beginPath();context.rect(700, 10, 50, 50);context.stroke();context.fillStyle = 'red';context.fill(); 1.4、绘制圆弧绘制圆弧或者圆的时候，我们可以使用如下方法： arc(x, y, radius, startAngle, endAngle, anticlockwise) 画一个以（x,y）为圆心的以radius为半径的圆弧（圆），从startAngle开始到endAngle结束，按照anticlockwise给定的方向（默认为顺时针）来生成。 arcTo(x1, y1, x2, y2, radius) 根据给定的控制点和半径画一段圆弧，再以直线连接两个控制点。 anticlockwise为true则表示逆时针绘制。 1234567//绘制圆弧context.beginPath();context.arc(550, 150, 100, getRadian(90) , getRadian(360), false);context.stroke();context.beginPath();context.arc(550, 150, 100, 0, getRadian(90), false);context.fill(); 以上代码，绘制了两个弧形，一个空心，一个实心。一般再绘制圆弧的时候就不要执行 moveTo(x, y)，否则绘制终点会被连接到这个触点上。 注意：在arc函数中，startAngle 和 endAngle 属性值都是弧度，而不是我们所熟知的角度。所以我们一个一个角度转换为弧度的函数，如下： 123function getRadian(degrees/*角度值*/)&#123; return (Math.PI / 180) * degrees;&#125; arcTo没吃透，暂时描述不出来，先简单看看示例： 1234567891011//绘制圆弧（必须要设定起始点）context.beginPath();context.fillRect(600, 400, 10, 10);context.fillRect(700, 500, 10, 10);context.fillStyle = 'blue';context.fillRect(700, 400, 10, 10);context.beginPath();context.moveTo(700, 400);context.arcTo(600, 600, 700, 700, 500);context.stroke(); 2、其他2.1、canvas检查支持性如果仅仅需要在UI上体现，那么我们可以在 &lt;canvas&gt; 标签内部放置元素，如果浏览器不支持 &lt;canvas&gt; 标签，那么内部的元素就会被浏览器解析，而显示出来。 123&lt;canvas id=\"stockGraph\" width=\"150\" height=\"150\"&gt; &lt;p&gt;Canvas not be support.&lt;/p&gt;&lt;/canvas&gt; 除此之外，我们也可以用js的方式来检查。 12345var c1 = document.getElementById('c1');//如果canvas元素没有getContext方法，那么就证明浏览器不支持canvas。if(!c1.getContext)&#123; console.log('Canvas not be support.')&#125; 2.2、canvas的width和height属性&lt;canvas&gt; 对象有两个比较特别的属性，width、height，这两者用于控制画布的大小，width的默认值是300，height的默认值为150。当这两个属性值有变化时，在该画布上已经完成的任何绘图都会擦除掉。 1234var c1 = document.getElementById('c1');console.log('default width:', c1.width, '; default height:', c1.height);c1.width = 500;c1.height = 600; &lt;canvas&gt; 的的height和width属性如果和用css设置的height和width样式不一致，那么就可能会产生扭曲。 2.3、来个好玩的，画个桃心12345678910111213141516171819202122232425262728293031323334353637383940414243function drawHeart() &#123; context.fillStyle = 'purple'; //三次曲线 context.beginPath(); context.moveTo(75, 40); context.bezierCurveTo(75, 37, 70, 25, 50, 25); context.bezierCurveTo(20, 25, 20, 62.5, 20, 62.5); context.bezierCurveTo(20, 80, 40, 102, 75, 120); context.bezierCurveTo(110, 102, 130, 80, 130, 62.5); context.bezierCurveTo(130, 62.5, 130, 25, 100, 25); context.bezierCurveTo(85, 25, 75, 37, 75, 40); context.fill();&#125;drawHeart();``` ### 2.4 附上测试代码```html&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Canvas Test&lt;/title&gt; &lt;style&gt; body &#123; text-align: center; &#125; .c1 &#123; border: 1px solid red; height: 600px; width: 800px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id=\"c1\" onclick=\"alert('abc')\" class=\"c1\"&gt;&lt;/canvas&gt; &lt;script src=\"main.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788var c1 = document.getElementById('c1');// 如果不用id属性，我们可以用如下方式来获取canvas对象//var c1 = document.getElementsByTagName('canvas')[0];c1.width = 800;c1.height = 600;var context = c1.getContext('2d');console.log(context); //可以看到context是一个CanvasRenderingContext2D对象function getRadian(degrees/*角度值*/) &#123; return (Math.PI / 180) * degrees;&#125;//绘制红色矩形context.fillStyle = 'red';context.fillRect(10, 10, 100, 100);//绘制蓝色矩形框context.strokeStyle = 'blue';context.strokeRect(150, 150, 100, 100);//清空矩形区域（设置矩形区域为空白）context.clearRect(100, 100, 100, 100);//画线，设置起点。context.moveTo(200, 200);//设置轨迹context.lineTo(500, 500);//画线context.stroke();//绘制空心矩形context.beginPath();context.moveTo(400, 400);context.lineTo(450, 400);context.lineTo(450, 450);context.lineTo(400, 450);context.closePath();context.stroke();//绘制实心梯形context.beginPath();context.moveTo(100, 400);context.lineTo(200, 400);context.lineTo(250, 500);context.lineTo(50, 500);context.fill();//绘制圆弧context.beginPath();context.arc(550, 150, 100, getRadian(90), getRadian(360), true);context.stroke();context.beginPath();context.arc(550, 150, 100, 0, getRadian(90), true);context.stroke();//绘制圆弧（必须要设定起始点）context.beginPath();context.fillRect(600, 400, 10, 10);context.fillRect(700, 500, 10, 10);context.fillStyle = 'blue';context.fillRect(700, 400, 10, 10);context.beginPath();context.moveTo(700, 400);context.arcTo(600, 600, 700, 700, 500);context.stroke();//绘制矩形线条context.beginPath();context.rect(700, 10, 50, 50);context.stroke();context.fillStyle = 'red';context.fill();function drawHeart() &#123; context.fillStyle = 'purple'; //三次曲线 context.beginPath(); context.moveTo(75, 40); context.bezierCurveTo(75, 37, 70, 25, 50, 25); context.bezierCurveTo(20, 25, 20, 62.5, 20, 62.5); context.bezierCurveTo(20, 80, 40, 102, 75, 120); context.bezierCurveTo(110, 102, 130, 80, 130, 62.5); context.bezierCurveTo(130, 62.5, 130, 25, 100, 25); context.bezierCurveTo(85, 25, 75, 37, 75, 40); context.fill();&#125;drawHeart();"},{"title":"01_Dotnet Core尝鲜","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/DotNetCore/01_Dotnet Core尝鲜/","text":"0、About Dotnet CoreDotnet Core 是新一代的 .Net Framework，是一个具有跨平台能力的应用程序开发框架。它本身是由多个子项目组成的。包括 Core Fx、Core CLR、.Net Compiler Platform 等等。 Dotnet Core 具有高效的开发效率，高性能和跨平台能力，是 .Net平台 的一次大跃进。 1、尝试 Dotnet Core1.1、InstallDotnet Core 从发布至今，已经有很长一段时间了。期间也发布了beta，rc等版本。就在前不久，正式版也已经发布了，经过了之前大量的api变化，现在core已经非常稳定了。这个阶段，已经值得我们去尝试、去使用它了。 要尝试 Dotnet core, 我们先进入它的网站https://dotnet.github.io/，https://www.microsoft.com/net/core#windows 。 根据我们的操作系统版本，选择合适的开发包。我这里是Windows下开发，理所当然的下载 the .NET Core SDK for Windows 。 安装好之后，在命令行输入 dotnet --version ，如果输出了版本信息，那就表示安装成功了。 注意：如果之前尝试过Dotnet Core，请保证在安装最新版本的SDK之前，先卸载干净。 1.2、Console App在安装好SDK之后，我们就可以开始创建项目了。新建一个文件夹，进入控制台，执行 dotnet new，即可看到在目录下生成了如下文件结构： 12Program.csproject.json 内容如下： 1234567891011121314//Program.csusing System;namespace ConsoleApplication&#123; public class Program &#123; public static void Main(string[] args) &#123; Console.WriteLine(\"Hello World!\"); &#125; &#125;&#125; 123456789101112131415161718192021//project.json&#123; \"version\": \"1.0.0-*\", \"buildOptions\": &#123; \"debugType\": \"portable\", \"emitEntryPoint\": true &#125;, \"dependencies\": &#123;&#125;, \"frameworks\": &#123; \"netcoreapp1.0\": &#123; \"dependencies\": &#123; \"Microsoft.NETCore.App\": &#123; \"type\": \"platform\", \"version\": \"1.0.0\" &#125; &#125;, \"imports\": \"dnxcore50\" &#125; &#125;&#125; 此时我们可以通过 dotnet restore 来安装依赖。 注意：就算project.json中的dependencies属性为空对象，我们也要执行 dotnet restore，该命令会生成project.lock.json文件。 注意2：如果我们的网络环境的走的代理，那么可能会在安装依赖这个步骤遇到407错误，此时我们需要配置Nuget的代理设置，找到 %AppData%/NuGet/NuGet.Config 文件，然后添加如下配置项： 1234567&lt;configuration&gt; &lt;config&gt; &lt;add key=\"http_proxy\" value=\"s1firewall:8080\" /&gt; &lt;add key=\"http_proxy.user\" value=\"jh3r\" /&gt; &lt;add key=\"http_proxy.password\" value=\"xxx\" /&gt; &lt;/config&gt;&lt;/configuration&gt; 通过这样的设置，就可以使用代理来安装依赖了。 当我们安装好依赖之后，通过执行 dotnet run 来编译和运行我们的程序，此时可以在控制台看到输出： Hello World! 以上，就是我们使用 Dotnet Core 的一般步骤了。 1.3、Web App在尝试了Console App之后，我们也来试试Web App 在 Dotnet Core 下是如何运行的。 首先，基本步骤如上，先创建一个项目模板。 接着，首先要使用Web功能，我们需要指定依赖，在project.json中的dependencies属性中增加依赖： 123&quot;dependencies&quot;: &#123; &quot;Microsoft.AspNetCore.Server.Kestrel&quot;: &quot;1.0.0&quot;&#125; 注意：在设定依赖的时候，一定要注意版本号，如果依赖库的版本号不兼容Core的版本，那么很可能会出现一些莫名其妙的错误，而找不到原因。 增加依赖之后，我们再次通过 dotnet restore 来安装依赖。 这个时候，我们来编写Web宿主程序，内容如下： 12345678910111213141516171819//Program.csusing System;using Microsoft.AspNetCore.Hosting;namespace WebApplication&#123; public class Program &#123; public static void Main(string[] args) &#123; var host = new WebHostBuilder() .UseKestrel() .UseStartup&lt;Startup&gt;() //此处使用了类型Startup，来自于Startup.cs .UseUrls(\"http://localhost: 10000\") .Build(); host.Run(); &#125; &#125;&#125; 12345678910111213141516171819//Startup.csusing System;using Microsoft.AspNetCore.Builder;using Microsoft.AspNetCore.Http;namespace WebApplication&#123; public class Startup &#123; public void Configure(IApplicationBuilder app) &#123; app.Run((context) =&gt; &#123; return context.Response.WriteAsync(\"Hello, From Core.\"); &#125;); &#125; &#125;&#125; 编写好如上代码之后，我们在执行 dotnet run，访问 http://localhost:10000 就可以看到我们的Web程序已经成功运行起来了。 以上则是一个简单的Web程序所需要的代码。 2、Other2.1、Dotnet Core 与 Node.js 的性能测试。在 Dotnet Core 的官方宣传中，号称比 Node.js 快8倍。实际上，通过计算从0到100000000的累加来看，两者的差距并不大（几十ms的差别，Node稍弱）。 由于时间环境关系，没有进行更复杂测试，但我想在高并发下，Node的机制可能会有更高的性能。在大量IO操作处理中，Dotnet Core会有绝对的优势【后续可验证】。 2.2、如何直接运行Dotnet Core程序？在开发模式下，我们通过 dotnet run 来运行程序，那我们如何来运行发布好的程序呢？ 首先，我们可以通过 dotnet publish 来生成好我们的应用程序（在Windows下生成的是dll，其他平台未测试）。 在发布模式，我们的程序所依赖的包，也会被一同发布到目录下，我们可以在 /appRoot/bin/Debug/netcoreapp1.0/publish 中找到我们发布好的文件。 此时，我们就可以将publish目录拷贝到其他电脑运行了。 由于发布好的文件入口点是 .dll 文件，我们要运行它的话，需要通过 dotnet xxx.dll 来进行启动。 注意：在publish的时候，我们可以使用参数dotnet publish -c Release 生成Release版本的发布包，目录对应变更为 bin/Release/ 注意2：请不要删除publish目录下的文件，否则可能导致无法运行。经测试，.deps.json 和 .pdb可以删除，但依赖和 .runtimeconfig.json是绝对不能删除的。 2.3 后续此文为 Dotnet Core 系列第一篇，后续计划将Web开发所需要用到的一些基本知识点，库等均在 Dotnet Core 调试通，且成文。 加油，Dotnet! 【6.30号更新】 2.4、如何创建web项目在 1.3 中，我们知道如何把一个Console App 改造为一个Web项目，但这对应开发一个Web应用来说还不够。 其实，dotnet new 可以默认创建 Web 项目开发模板。 通过 dotnet new -t --help 我们可以看到 dotnet new 能帮我们创建的项目类型有如下四种： Console Web Lib xunittest 我们可以直接通过 dotnet new -t Web 来创建一个 Web 项目模板，简单快捷。 2.5、如果在Linux下发布（CentOS7）Dotnet Core 开发的程序，具有跨平台能力，那如何在非Windows上发布呢？各大操作系统方式并不同。 在CentOS7（仅支持7+）上发布非常简单。 首先是在CentOS7上安装 Dotnet Core，不知道如何安装？请查阅 https://www.microsoft.com/net/core#centos 。 安装好之后，只需要在Windows把开发好的程序，通过 dotnet publish 生成发布目录，然后将该目录拷贝到CentOS上即可。 最后，在CentOS上执行 dotnet xxx.dll 即可运行项目了。 注意： xxx.dll是你开发的项目的主程序"},{"title":"ES6入门系列二（特性总览上）","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/ES6入门/ES6入门系列二（特性总览上）/","text":"0、导言最近从coffee切换到js，代码量一下子变大了不少，也多了些许陌生感。为了在JS代码中，更合理的使用ES6的新特性，特在此对ES6的特性做一个简单的总览。 1、箭头函数(Arrows)使用 =&gt; 简写的函数称之为箭头函数，和C#的lambda，CoffeeScript的语法比较类似。 var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]; //简单使用 var arr2 = arr.map(x =&gt; x + 1); console.log(arr2); //等价于 arr2 = arr.map(function (x) { return x + 1; }); console.log(arr2); //此处必须用()包裹对象，否则语法错误 var arr3 = arr.map((x, i) =&gt; ({ idx: i, value: x })); console.log(arr3); //等价于 arr3 = arr.map(function (x, i) { return { idx: i, value: x }; }); console.log(arr3); //如果函数是一个语句块 var arr4 = []; arr.forEach(x =&gt; { if (x % 3 === 0) { arr4.push(x); } }); console.log(arr4); //等价于 arr4.length = 0; arr.forEach(function (x) { if (x % 3 === 0) { arr4.push(x); } }); console.log(arr4); //此处this一直指向obj对象。和一般function不同，箭头函数共享词法作用域。 var obj = { name: &apos;test&apos;, foods: [&apos;fish&apos;, &apos;milk&apos;], eat() { this.foods.forEach(x =&gt; console.log(this.name + &apos;like eat &apos; + x) //注意。此地不能有分号，因为属于表达式，不是语句块。 ); } }; obj.eat(); 2、类定义（classes）在ES6中，可以直接使用class关键字定义类，并可以定义构造函数，静态方法，get/set 方法，实例方法等。 &apos;use strict&apos;; class Animal { constructor(name) { this.name = name; } eat() { console.log(this.name + &apos; should eat food.&apos;); } }; class Dog extends Animal { //构造函数 constructor(age) { super(&apos;Dog&apos;); this.age = age; //实例方法 this.instanceFun = function () { console.log(&apos;Instance Function.&apos;); } } //静态方法 static go() { console.log(&apos;Dog will go.&apos;); } //原型方法 prototypeFunc() { console.log(&apos;Prototype Function.&apos;); } //get、set get dogName() { return &apos;Name: &apos; + this.name; } set dogName(value) { this.name = value; } //get get dogAge() { return &apos;Age: &apos; + this.age; } } var dog = new Dog(4); Dog.go(); dog.eat(); dog.instanceFun(); dog.prototypeFunc(); console.log(dog.dogName); dog.dogName = &apos;x&apos;; console.log(dog.dogName); console.log(dog.dogAge); dog.dogAge = 5; //会失败，属性没有getter。 3、增强的对象常量（Enhanced Object Literals）var obj = { name: &apos;obj&apos;, __proto__: { name: &apos;parent&apos; }, toString() { // 可以通过super直接取到原型对象的属性 return super.name + &apos;:&apos; + this.name; }, [&apos;prop_&apos; + (() =&gt; 1)()]: 1 //动态属性 }; console.log(obj.toString()); console.log(obj.prop_1); 4、模板字符串（Template Strings）简化了字符串的构造，拼接等。 //基本字符串，\\n有效。 var str = `Basic string &apos;\\n&apos; in Javascript.`; console.log(str); // Basic string &apos; // &apos; in Javascript. //多行字符串 str = `Multiline strings`; console.log(str); // Multiline // strings //字符串插值 var name = &apos;Jay&apos;; str = `Hello, ${name}`; console.log(str); // &apos;Hello, Jay.&apos; 5、解构（Destructuring）– Node和Chrome中执行不成功，忽略允许使用模式匹配，来匹配数组和对象。 6、Default + Rest + Spread – Node和Chrome中执行不成功，忽略7、局部变量+常量（Let + Const）&apos;use strict&apos;; //必须启用严格模式 { let x = 1; } console.log(x); //Error:x is not defined. const PI = 3.14; PI = 3.15; //Error: 无法对常量赋值 console.log(PI); //3.14 8、迭代器 + For..Of（Iterators + For..Of）比较类似于C#中的IEnumerable，使用for..of来访问迭代器。它不要求实现一个数组，而是使用和LINQ类似的懒加载。 (function () { &apos;use strict&apos;; let test = { [Symbol.iterator]() { let pre = 0, cur = 1; return { next() {//此处方法名不能变 pre = cur; cur = pre + cur; console.log(&apos;pre = &apos; + pre); console.log(&apos;cur = &apos; + cur); //返回值的属性名也不能改变 return { done: false, value: cur }; } } } }; for (var n of test) { if (n &gt; 1000) { break; } console.log(n); } })(); // 用于获取数组的键值 for (var item of[1, 3, 5, 7, 9]) { console.log(item); } 9、生成器（Generators）允许在function*()函数中使用yield关键字。 function* foo(x) { var y = 2 * (yield(x + 1)); var z = yield(y / 3); return (x + y + z); } var it = foo(5); console.log(it.next()); // { value:6, done:false } console.log(it.next(12)); // { value:8, done:false } console.log(it.next(13)); // { value:42, done:true } 10、unicode增加了对unicode字符的支持。比如“𠮷”（这个和吉不一样哦！） console.log(&apos;𠮷&apos;.length); //2 // 正则表达式增加了u这个参数，匹配unicode字符。 console.log(&quot;𠮷&quot;.match(/./u)[0].length) // 2 // new form &quot;\\u{20BB7}&quot;==&quot;𠮷&quot;==&quot;\\uD842\\uDFB7&quot; // new String ops &quot;𠮷&quot;.codePointAt(0) == 0x20BB7 // for-of iterates code points for(var c of &quot;𠮷&quot;) { console.log(c); } 11、参考资料1、ECMAScript 6 features https://github.com/lukehoban/es6features 2、ECMAScript 6 入门 http://es6.ruanyifeng.com/"},{"title":"ES6入门系列一（基础）","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/ES6入门/ES6入门系列一（基础）/","text":"##1、let命令Tips: 块级作用域（只在当前块中有效） 不会变量提升（必须先申明在使用） 让变量独占该块，不再受外部影响 不允许重复声明 总之：let更像我们熟知的静态语言的的变量声明指令 ES6新增了let命令，用来声明变量。用法类似于var，但所声明的变量，只能在let命令所在的代码块内有效。 let声明的变量只有块级作用域 &apos;use strict&apos; { let a = 1; } console.log(a); //结果是什么？ 看一段熟悉的代码： var a = []; for (var i = 0; i &lt; 10; i++) { a[i] = function () { console.log(i); }; } console.log(a[6]()); //结果是什么？ 如果改用let的话，那么看以下代码输出什么？ &apos;use strict&apos; var a = []; for (let i = 0; i &lt; 10; i++) { a[i] = function () { console.log(i); }; } console.log(a[6]()); // ? 同时，在使用let的时候，必须先申明再使用，不像var会变量提升： &apos;use strict&apos; console.log(a); let a = 1; ES6中明确规定，如果区块存在let和const，那么该区块就形成封闭作用域，凡是在声明致歉就使用这些变量，就会报错。简称“暂时性死区”（temporal dead zone，简称TDZ）。 看一个不太容易发现的死区：（注：该代码未测试） function bar(x=y, y=2) { return [x, y]; } bar(); // 报错 调用bar之所以报错，是因为参数x默认值等于另一个参数y，而此时y还没有声明，属于“死区”。 需要注意，函数参数作用域和函数体的作用域是分离的： let foo = &apos;outer&apos;; function bar(func) { let foo = &apos;inner&apos;; console.log(func()); // outer } bar(function(){ console.log(foo); }); 同时，let还不允许重复声明 { let a = 1; var a = 1; } { let a = 1; let a = 2; } ##2、const命令Tips： const用于声明常量，一旦声明，值就不能改变 const具有块级作用域 const不能变量提升（先声明后使用） 不可重复声明 const看起来很像我们熟知的静态语言的只读对象 const声明常量，一旦声明，值将是不可变的。 &apos;use strict&apos; const PI = 3.1415; PI // 3.1415 PI = 3; //Error const指令指向变量所在的地址，所以对该变量进行属性设置是可行的（未改变变量地址），如果想完全不可变化（包括属性），那么可以使用冻结。 &apos;use strict&apos; const C1 = {}; C1.a = 1; console.log(C1.a); // 1 //冻结对象，此时前面用不用const都是一个效果 const C2 = Object.freeze({}); C2.a = 1; //Error,对象不可扩展 console.log(C2.a); ##3、全局对象属性 JavaScript中，全局对象是最顶层的对象，浏览器中是window对象，Node中是global对象，ES5规定，所有全局变量都是全局对象的属性。 在ES6中，var和function申明的变量，属于全局对象的属性，let和const则不是全局对象的属性。 &apos;use strict&apos; let b = 2; console.log(global.b); // undefined"},{"title":"ES6入门系列三（特性总览下）","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/ES6入门/ES6入门系列三（特性总览下）/","text":"0、导言最近从coffee切换到js，代码量一下子变大了不少，也多了些许陌生感。 为了在JS代码中，更合理的使用ES6的新特性，特在此对ES6的特性做一个简单的总览。 1、模块(Module - Chrome测试不可用) 在ES6中，有class的概念，不过这只是语法糖，并没有解决模块化问题。Module功能则是为了解决模块化问题而提出的。 我们可以使用如下方式定义模块： 11_lib.js文件内容 // 导出属性和方法 export var PI = 3.1415926; export function calcCircularArea(r){ return PI * r * r; } app.js文件内容 //导出所有，使用别名调用 import * as lib from &apos;11_lib&apos;; console.log(lib.calcCircularArea(2)); console.log(lib.PI); //导出属性和方法 import {calcCircularArea, PI} from &apos;11_lib&apos;; console.log(calcCircularArea(2)); console.log(PI); 2、模块加载器(Module Loaders - Chrome测试不可用)既然用了定义module的规范，那么也就需要一个模块加载器，需要支持如下内容： 动态加载 状态隔离 全局命名空间隔离 编译钩子 嵌套虚拟化 1234System.import('11_lib').then(function(m) &#123; console.log(m.calcCircularArea(2)); console.log(m.PI);&#125;); 3、图 + 集合 + 弱引用图 + 若引用集合(Map + Set + WeakMap + WeakSet)在ES6中，新增了几种数据结构。 Map是一种类似于Object的结构，Object本质上是键值对的集合，但是只能是字符串当做键，所以有一定的使用限制。Map的话，则可以拿任意类型来作为key。具体使用如下： var map = new Map(); var key = {key: &apos;hah&apos;}; map.set(key, &apos;1&apos;); //设置key-value map.set(key, 2); //对已有key进行设置，表示覆盖 console.log(map.get(key)); //获取key的值 console.log(map.size);//获取map的元素个数 map.has(key); //判断map中有指定的key map.delete(key); //删除map中指定的key map.clear(); //清空map WeakMap和Map是比较类似的，唯一的区别是只接受对象作为键名（null除外），而且键名所指向的对象，不计入垃圾回收机制。 Set是一种类似于数组，但成员的值都是唯一（引用唯一）的一种数据结构。具体使用如下： var set = new Set();//定义set set.add(1).add(2).add(1).add(&apos;2&apos;); //添加数据 console.log(set.size);//查看set中元素的数量，结果应该是3，因为重复添加不计算，2和&apos;2&apos;不等。 set.delete(1); //删除set的值（通过value删除）。 set.has(1); //set是否包含某个value set.keys(); //返回set的所有key set.values(); //返回set的所有value set.clear();//清空set WeakSet和Set也是比较类型的，和Set有两个区别，一个是成员只能是对象；二个是WeakSet是不可遍历的。 4、代理（Proxies） (Chrome测试不可用)代理允许用宿主的行为来创建对象，能够实现拦截，对象的虚拟化，日志和分析等功能。 5、数据类型Symbols在ES5中，JS只有6中原始类型，在ES6中，新增了Symbols类型，成为了JS中的第7种原始类型。该类型表示独一无二的值。使用如下： var key = Symbol(); //定义Symbol对象console.log(typeof key); //symbol ，表示为类型，而且不是string类型的。key = Symbol(‘这是一个说明’); //可以在定义Symbol的时候，添加一个说明 Symbol不能与其他类型值进行运算，但是可以显式转换为字符串，和转换为布尔值 console.log(key.toString()); console.log(String(key)); if(key){ console.log(&apos;key is true&apos;); } 在对象的内部，要使用Symbol值定义属性时，必须放在方括号中。 var obj = { [key]: &apos;abc&apos; }; 6、可以子类化的内置对象在ES6中，我们可以自定义类型来继承内置对象，这个时候，如果要自定义构造函数，必须要在构造函数中调用super(),来呼叫父类的构造。 &apos;use strict&apos;; class MyArray extends Array { // 如果要定义constuctor，那么就必须要使用super来执行父类的构造 constructor(){ super(); } } var arr = new MyArray(); arr[1] = 12; console.log(arr.length === 2); 7、新增的API（Math + Number + String + Array + Object APIs）如下代码，一目了然： //数字类api Number.EPSILON; //增加常量e Number.isInteger(Infinity) // false Number.isNaN(&quot;NaN&quot;) // false //数学类api Math.acosh(3) // 1.762747174039086 Math.hypot(3, 4) // 5 Math.imul(Math.pow(2, 32) - 1, Math.pow(2, 32) - 2) // 2 //字符串类api &quot;abcde&quot;.includes(&quot;cd&quot;) // true &quot;abc&quot;.repeat(3) // &quot;abcabcabc&quot; //数组api Array.from(document.querySelectorAll(&apos;*&apos;)) // Returns a real Array Array.of(1, 2, 3) // Similar to new Array(...), but without special one-arg behavior [0, 0, 0].fill(7, 1) // [0,7,7] [1, 2, 3].find(x =&gt; x == 3) // 3 [1, 2, 3].findIndex(x =&gt; x == 2) // 1 [1, 2, 3, 4, 5].copyWithin(3, 0) // [1, 2, 3, 1, 2] [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].entries() // iterator [0, &quot;a&quot;], [1,&quot;b&quot;], [2,&quot;c&quot;] [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].keys() // iterator 0, 1, 2 [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].values() // iterator &quot;a&quot;, &quot;b&quot;, &quot;c&quot; //对象api Object.assign(Point, { origin: new Point(0,0) }) 8、二进制和八进制字面量（Binary and Octal Literals）直接上示例： var n1 = 0b111110101; //0b前缀，表示二进制字面量 console.log(n1); //输出的时候，直接用10进制展示 var n2 = 0o12345; //0o前缀，表示八进制字面量 console.log(n2); 9、承诺（Promises）Promise是ES6中新增的异步编程库。 //使用承诺定义一个异步任务 var p = new Promise((resolve, reject)=&gt;{ return setTimeout(function(){ reject(&apos;ok&apos;); }, 2000); }); p.then((data)=&gt;{ console.log(data); }, (data)=&gt;{ console.log(&apos;error&apos; + data); }).then(()=&gt;{ console.log(&apos;throw err&apos;); throw &apos;Error&apos;; }).catch(err =&gt; { console.log(err); }); 10、参考资料1、ECMAScript 6 features https://github.com/lukehoban/es6features 2、ECMAScript 6 入门 http://es6.ruanyifeng.com/"},{"title":"JS实现继承的几种方式","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/JS札记/JS实现继承的几种方式/","text":"前言JS作为面向对象的弱类型语言，继承也是其非常强大的特性之一。那么如何在JS中实现继承呢？让我们拭目以待。 JS继承的实现方式既然要实现继承，那么首先我们得有一个父类，代码如下： // 定义一个动物类 function Animal (name) { // 属性 this.name = name || &apos;Animal&apos;; // 实例方法 this.sleep = function(){ console.log(this.name + &apos;正在睡觉！&apos;); } } // 原型方法 Animal.prototype.eat = function(food) { console.log(this.name + &apos;正在吃：&apos; + food); }; 1、原型链继承核心： 将父类的实例作为子类的原型 function Cat(){ } Cat.prototype = new Animal(); Cat.prototype.name = &apos;cat&apos;; // Test Code var cat = new Cat(); console.log(cat.name); console.log(cat.eat(&apos;fish&apos;)); console.log(cat.sleep()); console.log(cat instanceof Animal); //true console.log(cat instanceof Cat); //true 特点： 非常纯粹的继承关系，实例是子类的实例，也是父类的实例 父类新增原型方法/原型属性，子类都能访问到 简单，易于实现 缺点： 要想为子类新增属性和方法，必须要在new Animal()这样的语句之后执行，不能放到构造器中 无法实现多继承 来自原型对象的引用属性是所有实例共享的（详细请看附录代码： 示例1;)） 创建子类实例时，无法向父类构造函数传参 推荐指数：★★（3、4两大致命缺陷） 2、构造继承核心：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型） function Cat(name){ Animal.call(this); this.name = name || &apos;Tom&apos;; } // Test Code var cat = new Cat(); console.log(cat.name); console.log(cat.sleep()); console.log(cat instanceof Animal); // false console.log(cat instanceof Cat); // true 特点： 解决了1中，子类实例共享父类引用属性的问题 创建子类实例时，可以向父类传递参数 可以实现多继承（call多个父类对象） 缺点： 实例并不是父类的实例，只是子类的实例 只能继承父类的实例属性和方法，不能继承原型属性/方法 无法实现函数复用，每个子类都有父类实例函数的副本，影响性能 推荐指数：★★（缺点3） 3、实例继承核心：为父类实例添加新特性，作为子类实例返回 function Cat(name){ var instance = new Animal(); instance.name = name || &apos;Tom&apos;; return instance; } // Test Code var cat = new Cat(); console.log(cat.name); console.log(cat.sleep()); console.log(cat instanceof Animal); // true console.log(cat instanceof Cat); // false 特点： 不限制调用方式，不管是new 子类()还是子类(),返回的对象具有相同的效果 缺点： 实例是父类的实例，不是子类的实例 不支持多继承 推荐指数：★★ 4、拷贝继承function Cat(name){ var animal = new Animal(); for(var p in animal){ Cat.prototype[p] = animal[p]; } Cat.prototype.name = name || &apos;Tom&apos;; } // Test Code var cat = new Cat(); console.log(cat.name); console.log(cat.sleep()); console.log(cat instanceof Animal); // false console.log(cat instanceof Cat); // true 特点： 支持多继承 缺点： 效率较低，内存占用高（因为要拷贝父类的属性） 无法获取父类不可枚举的方法（不可枚举方法，不能使用for in 访问到） 推荐指数：★（缺点1） 5、组合继承核心：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用 function Cat(name){ Animal.call(this); this.name = name || &apos;Tom&apos;; } Cat.prototype = new Animal(); // Test Code var cat = new Cat(); console.log(cat.name); console.log(cat.sleep()); console.log(cat instanceof Animal); // true console.log(cat instanceof Cat); // true 特点： 弥补了方式2的缺陷，可以继承实例属性/方法，也可以继承原型属性/方法 既是子类的实例，也是父类的实例 不存在引用属性共享问题 可传参 函数可复用 缺点： 调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了） 推荐指数：★★★★（仅仅多消耗了一点内存） 6、寄生组合继承核心：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点 function Cat(name){ Animal.call(this); this.name = name || &apos;Tom&apos;; } (function(){ // 创建一个没有实例方法的类 var Super = function(){}; Super.prototype = Animal.prototype; //将实例作为子类的原型 Cat.prototype = new Super(); })(); // Test Code var cat = new Cat(); console.log(cat.name); console.log(cat.sleep()); console.log(cat instanceof Animal); // true console.log(cat instanceof Cat); //true 特点： 堪称完美 缺点： 实现较为复杂 推荐指数：★★★★（实现复杂，扣掉一颗星） 附录代码：示例一： function Animal (name) { // 属性 this.name = name || &apos;Animal&apos;; // 实例方法 this.sleep = function(){ console.log(this.name + &apos;正在睡觉！&apos;); } //实例引用属性 this.features = []; } function Cat(name){ } Cat.prototype = new Animal(); var tom = new Cat(&apos;Tom&apos;); var kissy = new Cat(&apos;Kissy&apos;); console.log(tom.name); // &quot;Animal&quot; console.log(kissy.name); // &quot;Animal&quot; console.log(tom.features); // [] console.log(kissy.features); // [] tom.name = &apos;Tom-New Name&apos;; tom.features.push(&apos;eat&apos;); //针对父类实例值类型成员的更改，不影响 console.log(tom.name); // &quot;Tom-New Name&quot; console.log(kissy.name); // &quot;Animal&quot; //针对父类实例引用类型成员的更改，会通过影响其他子类实例 console.log(tom.features); // [&apos;eat&apos;] console.log(kissy.features); // [&apos;eat&apos;] 原因分析： 关键点：属性查找过程 执行tom.features.push，首先找tom对象的实例属性（找不到）， 那么去原型对象中找，也就是Animal的实例。发现有，那么就直接在这个对象的 features属性中插入值。 在console.log(kissy.features); 的时候。同上，kissy实例上没有，那么去原型上找。 刚好原型上有，就直接返回，但是注意，这个原型对象中features属性值已经变化了。"},{"title":"ES6 Class如何管理私有数据","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/JS札记/ES6 Class如何管理私有数据/","text":"0、前言在ES5时代，要模拟对象的私有变量，是比较容易的，代码如下： 123456789function Person()&#123; var _age = 20; //定义一个私有变量，外部无法访问。 this.setAge = function(value)&#123; _age = value; &#125; this.getAge = function()&#123; return _age; &#125;&#125; 在ES6中，虽然可以在 Class 的 constructor 中实现类似function的私有方法，但是实际上，ES6中并不推荐这种做法。这样极大的加重了对象的实例。 那我们就来看看在ES6中有多少方法可以实现私有数据管理。 1、在构造函数中存储私有数据该方式，和在ES5中，没有什么区别。 1234567class Person&#123; constructor()&#123; var _age = 20; this.setAge = value =&gt; _age = value; this.getAge = _ =&gt; _age; &#125;&#125; 该方式有一个变种，就是利用构造参数来存储，减少重新定义变量。 123456class Person&#123; constructor(age)&#123; this.setAge = value =&gt; age = value; this.getAge = _ =&gt; age; &#125;&#125; 优点： 数据绝对安全，外部无法直接通过属性访问到。 不会与其他私有属性有任何冲突。如 123let p = new Person(); p.age = 10; p.getAge(); //20 缺点： 代码不怎么优雅，需要把方法设置为实例方法，才能访问到私有数据。 实例方法，比较浪费内存（每个实例都会拷贝一份）。 2、通过命名约定来使用私有数据该方式是在ES6 Class 中，我个人比较推荐的一个方式，实现代码如下： 123456789101112class Person&#123; constructor()&#123; this._age = 0; &#125; setAge(value)&#123; this._age = value; &#125; getAge()&#123; return this._age; &#125;&#125; 优点： 代码看起来非常不错，简单易懂。 能否在原型方法中访问。 缺点： 并不安全，如果不遵守约定，直接操作_age，也是可行的，如： 123let p = new Person();p._age = 555;p.getAge(); // 555 如果在对象上设置同名属性，会覆盖掉原本是私有属性。 3、利用WeakMap来存储私有数据该方式是利用WeakMap可以用Object来做key的特点，把this当做key来存储具体的私有属性。具体实现如下： 12345678910111213141516let dataStore = new WeakMap();class Person&#123; constructor()&#123; dataStore.set(this, &#123;age: 20&#125;); &#125; setAge(value)&#123; let oldObj = dataStore.get(this); let newObj = Object.assign(oldObj, &#123;age: value&#125;); dataStore.set(this, newObj); &#125; getAge()&#123; return dataStore.get(this).age; &#125;&#125; 如何使用？ 1234let p1 = new Person();p1.getAge(); // 20p1.setAge(25);p1.getAge(); // 25 优点： 能够使用原型方法，内存占用小； 比命名约定属性名称安全性更高； 不会有命名冲突（允许同名实例属性）； 缺点： 代码没有命名约定方式（方式2）优雅； 依赖外部对象； 4、利用Symbol来生成私有属性key。该方式和命名约定方式没有本质区别，只是用 Symbol 来生成key，提高了key的安全性。具体实现代码如下： 1234567891011121314const keyForAge = Symbol('age'); class Person&#123; constructor()&#123; this[keyForAge] = 20; &#125; setAge(value)&#123; this[keyForAge] = value; &#125; getAge()&#123; return this[keyForAge]; &#125;&#125; 优点： 能够使用原型方法，内存占用小； 比命名约定属性名称安全性更高，但也并不安全； 12345let p1 = new Person();Object.keys(p1); // []，无法直接访问到属性名p1[keyForAge] = 30;p1.getAge(); // 30Reflect.ownKeys(p1); // [Symbol(age)]，通过能方式能遍历Key 不会有命名冲突（允许同名实例属性）； 缺点： 代码没有命名约定方式（方式2）优雅； 依赖外部对象； 不是绝对安全； 5、Other能够达到的目的的方式有很多，也没有那个有绝对优势，根据实际的需求，来选择合适的方式才是最佳的方式。 参考资料 http://www.2ality.com/2016/01/private-data-classes.html"},{"title":"JavaScript之毒瘤","permalink":"http://hstarorg.github.io/blog/blog/2017/02/21/JS札记/JavaScript之毒瘤/","text":"0、导言JavaScript中有许多难以避免的问题特性。接下来就一一揭示。 1、全局变量在所有JavaScript的糟糕特性中，最为糟糕的就是全局变量的依赖。全局变量使得在同一个程序中运行独立的子程序变得更难。 2、作用域JavaScript是类C的语法，但是却没有提供类C的块级作用域。 3、自动插入分号JavaScript有一个自动修复机制，会试图通过自动插入分号来修正有缺损的程序，但是它有可能掩盖更为严重的错误。 4、保留字有太多的单词在JavaScript中被保留，它们不能用来命名变量或者函数（在大部分执行环境下，部分关键字是可用的）。 5、Unicode字符JavaScript设计之初，Unicode预计只会有65536个字符。实际上，到现在Unicode有多大百万个字符。这也就导致了JavaScript会认为一对字符是两个不同的字符（Unicode把一对字符视为一个单一的字符） 6、typeof不要指望typeof返回的类型。比如null或者是检测对象，另外检测正则可能会返回function或者是object。 7、parseIntparseInt把一个字符串转换为整数，会在遇到非数字时停止解析。另外如果第一个字符是0，还会按照8进制来取值。 8、运算符（+）+运算符可以用于加法运算或者是字符串连接，究竟如何执行会取决于其参数类型。 9、 浮点数二进制浮点数不能正确的处理十进制小数，因此0.1+0.2 不等于0.3。 10、NaNNaN是一个特殊的数量值，它表示不是一个数字。也是唯一一个不等于自身的JavaScript数值。 11、伪数组JavaScript没有真正的数组，就连Array也是通过object来模拟的，如果完全达不到真正的数组的地步。同时typeof运算符也不能辨别数组和对象。 12、假值JavaScript中包含诸多的假值，如: 0, NaN, ‘’, false, null, undefined 13、hasOwnPropertyhasOwnProperty方法被用做一个过滤器来避开for..in语句的隐患，但hasOwnProperty是一个普通的方法，所以是可以被重写的。 14、对象JavaScript的对象，永远不会是真的空对象，因为可以从原形链取得成员属性。"},{"title":"前端构建之gulp与常用插件","permalink":"http://hstarorg.github.io/blog/blog/2015/03/14/前端相关/[20140311]前端构建之gulp与常用插件/","text":"##gulp是什么？ http://gulpjs.com/ 相信你会明白的！ 与著名的构建工具grunt相比，有什么优势呢？ 易于使用，代码优于配置 高效，不会产生过多的中间文件，减少I/O压力 易于学习，API非常少，你能在很短的事件内学会gulp ##那些常用的gulp插件 ###No.1、run-sequence Links: https://www.npmjs.com/package/run-sequence 作用：让gulp任务，可以相互独立，解除任务间的依赖，增强task复用 推荐指数：★★★★★ ###No.2、browser-sync Links: http://www.browsersync.io/ 作用：静态文件服务器，同时也支持浏览器自动刷新 推荐指数：★★★★★ ###No.3、del Links：https://www.npmjs.com/package/del 作用：删除文件/文件夹 推荐指数：★★★★★ ###No.4、gulp-coffee Links: https://github.com/wearefractal/gulp-coffee 作用：编译coffee代码为Js代码，使用coffeescript必备 推荐指数：★★★★ ###No.5、coffee-script Links: https://www.npmjs.com/package/coffee-script 作用：gulpfile默认采用js后缀，如果要使用gulpfile.coffee来编写，那么需要此模块 推荐指数：★★★ ###No.6、gulp-nodemon Links: https://www.npmjs.com/package/gulp-nodemon 作用：自动启动/重启你的node程序，开发node服务端程序必备 推荐指数：★★★★★ ###No.7、yargs Links: https://www.npmjs.com/package/yargs 作用：用于获取启动参数，针对不同参数，切换任务执行过程时需要 推荐指数：★★★ ###No.8、gulp-util Links: https://www.npmjs.com/package/gulp-util 作用：gulp常用的工具库 推荐指数：★★★★★ ###No.9、gulp-uglify Links: https://www.npmjs.com/package/gulp-uglify 作用：通过UglifyJS来压缩JS文件 推荐指数：★★★★ ###No.9、gulp-concat Links: https://www.npmjs.com/package/gulp-concat 作用：合并JS 推荐指数：★★★★ ###No.10、gulp-sourcemaps Links: https://www.npmjs.com/package/gulp-sourcemaps 作用：处理JS时，生成SourceMap 推荐指数：★★★★ ###No.11、gulp-less Links：https://www.npmjs.com/package/gulp-less 作用：将less预处理为css 推荐指数：★★★★ ###No.12、gulp-sass Links：https://www.npmjs.com/package/gulp-sass 作用：将sass预处理为css 推荐指数：★★★★ ###No.13、gulp-autoprefixer Links：https://www.npmjs.com/package/gulp-autoprefixer 作用：使用Autoprefixer来补全浏览器兼容的css。 推荐指数：★★★★ ###No.14、gulp-minify-css Links：https://www.npmjs.com/package/gulp-minify-css 作用：压缩css。 推荐指数：★★★★ ###No.15、connect-history-api-fallback Links：https://www.npmjs.com/package/connect-history-api-fallback 作用：开发angular应用必须，用于支持HTML5 history API. 推荐指数：★★★ ##一般的gulpfile文件（采用coffee编写） 首先是，node应用程序： gulp = require(&apos;gulp&apos;) runSequence = require(&apos;run-sequence&apos;) coffee = require(&apos;gulp-coffee&apos;) gutil = require(&apos;gulp-util&apos;) del = require(&apos;del&apos;) nodemon = require(&apos;gulp-nodemon&apos;) argv = require(&apos;yargs&apos;).argv rename = require(&apos;gulp-rename&apos;) browserSync = require(&apos;browser-sync&apos;) reload = browserSync.reload # 处理参数 isDebug = not (argv.r || false) # --入口任务----------------------------------------------------------------- gulp.task(&apos;default&apos;, (callback)-&gt; runSequence( [&apos;clean&apos;] [&apos;coffee-server&apos;, &apos;copy-server&apos;, &apos;copy-client&apos;, &apos;coffee-client&apos;, &apos;copy-views&apos;] &apos;serve&apos; [&apos;browserSync&apos;, &apos;watch&apos;] callback ) ) # --构建相关任务--------------------------------------- gulp.task(&apos;clean&apos;, (callback)-&gt; del([&apos;./dist/&apos;], callback) ) gulp.task(&apos;coffee-server&apos;, -&gt; gulp.src([ &apos;./src/**/*.coffee&apos; &apos;!./src/public/**/*.coffee&apos; &apos;!./src/views/**&apos; ]) .pipe(coffee({bare: true}).on(&apos;error&apos;, gutil.log)) .pipe(gulp.dest(&apos;./dist/&apos;)) ) gulp.task(&apos;copy-server&apos;, -&gt; gulp.src([ &apos;./src/config*/*.json&apos; &apos;./src/database*/*.*&apos; ]) .pipe(gulp.dest(&apos;./dist/&apos;)) ) gulp.task(&apos;copy-client&apos;, -&gt; gulp.src([ &apos;./src/public*/**/*&apos; &apos;!./src/public*/**/*.coffee&apos; ]) .pipe(gulp.dest(&apos;./dist/&apos;)) ) gulp.task(&apos;coffee-client&apos;, -&gt; gulp.src([ &apos;./src/public*/**/*.coffee&apos; ]) .pipe(coffee({bare: true}).on(&apos;error&apos;, gutil.log)) .pipe(gulp.dest(&apos;./dist/&apos;)) ) gulp.task(&apos;copy-views&apos;, -&gt; gulp.src(&apos;./src/views/**/*.html&apos;) .pipe(rename({extname: &apos;.vash&apos;})) .pipe(gulp.dest(&apos;./dist/views&apos;)) ) # --启动程序,打开浏览器任务---------------------------------------------------- nodemon_instance = undefined gulp.task(&apos;serve&apos;, (callback)-&gt; called = false if not nodemon_instance nodemon_instance = nodemon({ script: &apos;./dist/index.js&apos; ext: &apos;none&apos; }) .on(&apos;restart&apos;, -&gt; console.log(&apos;restart server......................&apos;) ) .on(&apos;start&apos;, -&gt; if not called called = true callback() ) else nodemon_instance.emit(&quot;restart&quot;) callback() nodemon_instance ) gulp.task(&apos;browserSync&apos;, -&gt; browserSync({ proxy: &apos;localhost:3000&apos; port: 8888 #files: [&apos;./src/public/**/*&apos;] open: true notify: true reloadDelay: 500 # 延迟刷新 }) ) # --监视任务------------------------------------------------ gulp.task(&apos;watch&apos;, -&gt; gulp.watch([ &apos;./src/**/*.*&apos; &apos;!./src/**/*.coffee&apos; ], [&apos;reload-client&apos;]) gulp.watch(&apos;./src/**/*.coffee&apos;, [&apos;reload-server&apos;]) ) gulp.task(&apos;reload-client&apos;, (callback) -&gt; runSequence( [&apos;copy-client&apos;, &apos;coffee-client&apos;, &apos;copy-views&apos;] &apos;bs-reload&apos; callback ) ) gulp.task(&apos;reload-server&apos;, (callback) -&gt; runSequence( [&apos;copy-server&apos;, &apos;coffee-server&apos;] &apos;serve&apos; &apos;bs-reload&apos; callback ) ) gulp.task(&apos;bs-reload&apos;, -&gt; browserSync.reload() ) 接下来是前端网站： gulp = require(&apos;gulp&apos;) gutil = require(&apos;gulp-util&apos;) coffee = require(&apos;gulp-coffee&apos;) del = require(&apos;del&apos;) runSequence = require(&apos;run-sequence&apos;) browserSync = require(&apos;browser-sync&apos;) historyApiFallback = require(&apos;connect-history-api-fallback&apos;) # 入口点 gulp.task(&apos;default&apos;, -&gt; runSequence( [&apos;clean&apos;] [&apos;copy&apos;] [&apos;serve&apos;] ) ) gulp.task(&apos;copy&apos;, -&gt; gulp.src([ &apos;./src/**/*.*&apos; &apos;!./src/**/*.coffee&apos; &apos;!./src/**/*.less&apos; ]) .pipe(gulp.dest(&apos;./dist&apos;)) ) gulp.task(&apos;clean&apos;, (callback)-&gt; del([&apos;./dist/&apos;], callback) ) gulp.task(&apos;serve&apos;, -&gt; browserSync({ server: { baseDir: &quot;./dist&quot; middleware: [historyApiFallback] } port: 2222 }) ) gulp.task(&apos;watch&apos;, -&gt; # do something... )"},{"title":"Angular：指令、Controller数据共享","permalink":"http://hstarorg.github.io/blog/blog/2015/03/13/Angular相关/Angular：指令、Controller数据共享/","text":"1、Directive与Controller数据共享在指令中，不仅仅需要指令配置信息，很多时候也需要获取$scope的相关数据。那么，如何在指令中拿到$scope的数据呢？ 1.1、Directive和Controller使用同一个scope&lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;Angular Demo&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div ng-controller=&quot;DemoCtrl&quot;&gt; &lt;d1&gt;&lt;/d1&gt; &lt;/div&gt; &lt;!-- 脚本区域 --&gt; &lt;script src=&quot;https://ajax.googleapis.com/ajax/libs/angularjs/1.3.15/angular.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; angular.module(&apos;app&apos;, []) .directive(&apos;d1&apos;, [function(){ return { restrict: &apos;E&apos;, scope: false, //defualt value is false template: &apos;&lt;h1&gt;Hi,{{name}}&lt;/h1&gt;&apos;, link: function(scope, iElement, iAttrs){ console.log(&apos;directive scope id = &apos; + scope.$id); } } }]) .controller(&apos;DemoCtrl&apos;, [&apos;$scope&apos;, function($scope){ console.log(&apos;controller scope id = &apos; + $scope.$id); $scope.name = &apos;Jay&apos;; }]); //可以采用如此方式启动angular扫描，或者直接使用ng-app=&quot;app&quot; angular.bootstrap(document.body, [&apos;app&apos;]); &lt;/script&gt; &lt;!-- 脚本区域 End --&gt; &lt;/body&gt; &lt;/html&gt; 执行以上代码，页面显示Hi Jay，并在控制台打印 controller scope id = 2 directive scope id = 2 在指令中，默认会直接使用上级的scope，从控制台来看，先执行controller的scope，再执行directive的scope。因为id一致，所以是同一个scope。既然是同一个scope，那么共享数据自然就不是问题了。该方式，适合业务性质的directive，如果是公共的directive，不建议使用此方式，可能会导致scope杂乱。 1.2、在指令作用域中使用@，将当前属性作为字符串传递&lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;Angular Demo&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div ng-controller=&quot;DemoCtrl&quot;&gt; &lt;d1 name=&quot;{{key}}&quot;&gt;&lt;/d1&gt; &lt;/div&gt; &lt;!-- 脚本区域 --&gt; &lt;script src=&quot;https://ajax.googleapis.com/ajax/libs/angularjs/1.3.15/angular.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; angular.module(&apos;app&apos;, []) .directive(&apos;d1&apos;, [function(){ return { restrict: &apos;E&apos;, scope: { name: &apos;@&apos; }, template: &apos;&lt;h1&gt;Hi,{{name}}&lt;/h1&gt;&apos;, link: function(scope, iElement, iAttrs){ console.log(&apos;directive scope id = &apos; + scope.$id); } } }]) .controller(&apos;DemoCtrl&apos;, [&apos;$scope&apos;, function($scope){ console.log(&apos;controller scope id = &apos; + $scope.$id); $scope.key = &apos;Jay&apos;; }]); //可以采用如此方式启动angular扫描，或者直接使用ng-app=&quot;app&quot; angular.bootstrap(document.body, [&apos;app&apos;]); &lt;/script&gt; &lt;!-- 脚本区域 End --&gt; &lt;/body&gt; &lt;/html&gt; 以上代码，主要修改了指令的scope，从输出来看，指令和controller各自是自己独有的作用域。 scope = {name: &#39;@&#39;}，等价于 link:function(scope, iElement, iAttrs){ scope.name = iAttrs.name; } Controller中的key的变化，会即时影响到Directive的变化，但是Directive的变化并不会反向影响到Controller，结果近似于单向绑定。 1.3、在指令的作用域中使用=，进行数据的双向绑定&lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;Angular Demo&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div ng-controller=&quot;DemoCtrl&quot;&gt; key = {{key}} &lt;d1 name=&quot;key&quot;&gt;&lt;/d1&gt; &lt;/div&gt; &lt;!-- 脚本区域 --&gt; &lt;script src=&quot;https://ajax.googleapis.com/ajax/libs/angularjs/1.3.15/angular.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; angular.module(&apos;app&apos;, []) .directive(&apos;d1&apos;, [function(){ return { restrict: &apos;E&apos;, scope: { name: &apos;=&apos; }, template: &apos;&lt;h1&gt;Hi,{{name}}&lt;/h1&gt;&lt;input type=&quot;text&quot; ng-model=&quot;name&quot; /&gt;&apos;, link: function(scope, iElement, iAttrs){ console.log(&apos;directive scope id = &apos; + scope.$id); } } }]) .controller(&apos;DemoCtrl&apos;, [&apos;$scope&apos;, function($scope){ console.log(&apos;controller scope id = &apos; + $scope.$id); $scope.key = &apos;Jay&apos;; }]); //可以采用如此方式启动angular扫描，或者直接使用ng-app=&quot;app&quot; angular.bootstrap(document.body, [&apos;app&apos;]); &lt;/script&gt; &lt;!-- 脚本区域 End --&gt; &lt;/body&gt; &lt;/html&gt; 以上代码的变化在于，使用了scope: {name: ‘=’}，该代码将父作用域的属性和指令的属性进行双向绑定。所以指令中文本框的值的变化，将会同步影响controller中key的变化。 注意：在使用指令的时候，html代码，并不是和示例1.1一致了，如果是双向绑定，那么应该使用&lt;d1 name=”key” /&gt;，而不是&lt;d1 name=”“&gt;。 1.4、在Directive中调用Controller的方法&lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;Angular Demo&lt;/title&gt; &lt;/head&gt; &lt;body ng-app=&quot;app&quot;&gt; &lt;div ng-controller=&quot;DemoCtrl&quot;&gt; key = {{key}} &lt;d1 name=&quot;key&quot; show-name=&quot;show(key)&quot;&gt;&lt;/d1&gt; &lt;/div&gt; &lt;!-- 脚本区域 --&gt; &lt;script src=&quot;https://ajax.googleapis.com/ajax/libs/angularjs/1.3.15/angular.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; angular.module(&apos;app&apos;, []) .directive(&apos;d1&apos;, [function(){ return { restrict: &apos;E&apos;, scope: { name: &apos;=&apos;, showName: &apos;&amp;&apos; }, template: &apos;&lt;h1&gt;Hi,{{name}}&lt;/h1&gt;&lt;input type=&quot;text&quot; ng-model=&quot;name&quot; /&gt;&apos; + &apos;&lt;button ng-click=&quot;showName(name)&quot;&gt;Show&lt;/button&gt;&apos;, link: function(scope, iElement, iAttrs){ console.log(&apos;directive scope id = &apos; + scope.$id); } } }]) .controller(&apos;DemoCtrl&apos;, [&apos;$scope&apos;, function($scope){ console.log(&apos;controller scope id = &apos; + $scope.$id); $scope.key = &apos;Jay&apos;; $scope.show = function(name){ alert(name); }; }]); &lt;/script&gt; &lt;!-- 脚本区域 End --&gt; &lt;/body&gt; &lt;/html&gt; 点击指令生成的按钮，会执行controller的show方法，利用在scope: {showName: ‘&amp;’}，可以将父级作用域的方法绑定到指令中。 注意，一定要注意属性命令，在html中书写showName，那么在iAttrs中对应showname，只有在html中书写show-name,在会在iAttrs中对应showName。 2、在controller中，拿到directive的作用域2.1、拿到scope的元素，调用isolateScope获取scope&lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;Angular Demo&lt;/title&gt; &lt;/head&gt; &lt;body ng-app=&quot;app&quot;&gt; &lt;div ng-controller=&quot;DemoCtrl&quot;&gt; key = {{key}} &lt;button ng-click=&quot;click()&quot;&gt;Click&lt;/button&gt; &lt;hr /&gt; &lt;d1 id=&quot;d1&quot; name=&quot;key&quot; show-name=&quot;show(key)&quot;&gt;&lt;/d1&gt; &lt;/div&gt; &lt;!-- 脚本区域 --&gt; &lt;script src=&quot;//ajax.aspnetcdn.com/ajax/jQuery/jquery-2.1.3.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://ajax.googleapis.com/ajax/libs/angularjs/1.3.15/angular.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; angular.module(&apos;app&apos;, []) .directive(&apos;d1&apos;, [function(){ return { restrict: &apos;E&apos;, scope: {}, //等价于 scope: true template: &apos;&lt;h1&gt;Hi,{{name}}&apos;, link: function(scope, iElement, iAttrs){ scope.name = &apos;directive name&apos;; console.log(&apos;directive scope id = &apos; + scope.$id); } } }]) .controller(&apos;DemoCtrl&apos;, [&apos;$scope&apos;, function($scope){ console.log(&apos;controller scope id = &apos; + $scope.$id); $scope.click = function(){ var dirScope = $(&apos;#d1&apos;).isolateScope(); alert(dirScope.name); } }]); &lt;/script&gt; &lt;!-- 脚本区域 End --&gt; &lt;/body&gt; &lt;/html&gt; 此代码中，利用$(‘#d1’).isolateScope，拿到了该指令的scope，所以可以随时方式，该方式在多种指令中也有效。 如果判断应该用isolateScope()还是scope()获取作用域？一个最简单的方式，用F12查看源码，找到该元素，然后查看class是ng-isolate-scope还是ng-scope 3、 指令之间相互获取数据3.1、通过directive依赖来共享数据&lt;script&gt; angular.module(&apos;app&apos;, []) .directive(&apos;d1&apos;, [function(){ return { restrict: &apos;E&apos;, require: &apos;^ngModel&apos;, scope: {}, //等价于 scope: true template: false, link: function(scope, iElement, iAttrs, ngModelCtrl){ } } }]) .controller(&apos;DemoCtrl&apos;, [&apos;$scope&apos;, function($scope){ }]); &lt;/script&gt; 3.2、通过如2.1的方式获取数据4、 其他Hacky的方式 通过$parent访问父级作用域 通过$$prevSibling访问该作用域的上一个兄弟作用域 通过$$nextSibling访问该作用域的下一个兄弟作用域 通过$$childHead访问儿子作用域的第一个 通过$$childTail访问儿子作用域的最后一个 5、参考资料 SHARING DATA BETWEEN CHILD AND PARENT DIRECTIVES AND SCOPES (IN ANGULARJS) directive和controller如何通信"},{"title":"Angular：如何编写一个指令","permalink":"http://hstarorg.github.io/blog/blog/2015/03/13/Angular相关/[20140917]Angular：如何编写一个指令/","text":"Angular是什么？AngularJS是一个用JavaScript编写的客户端MVC框架，它运行于Web浏览器，能够极大的帮助我们（开发者）编写模块化，单页面，Ajax风格的Web Applications。 PS：AngularJS适合开发CRUD的SPA Angular Directive是什么？Angular Directive是构建在DOM元素（属性、标签名、注释和CSS类）上的标记，告诉AngularJS的HTML编译器($compile) 附加指定的行为到元素或者甚至变换这个元素和它的子集。 PS：通过扩展HTML标签的方式提供可复用的web组件 PS2：指令的作用：提供语义化标签 完整的Directive参数var directiveModule=angular.module(&apos;Newkit.negHotkeys&apos;); directiveModule.directive(&apos;negHotkeys&apos;,function(injectables){ var directiveDefineObject={ restrict:(string), priority:(number), template:(string), templateUrl:(string), replace:(bool), transclude:(bool), scope:(bool or object), controller:(function), require:(string), link:(function) compile:(function) }; return directiveDefineObject; }); 参数说明 restrict：(string)指令的使用方式，可选值：元素[E]、属性[A]、样式类[C]、注释[M]，并且可以采用组合的方式使用，示例：’AE’ priority：(number)优先级，描述了多个指令时，指令的执行顺序。数字越大，优先级越高，默认值0。 template：(string)文本模板 templateUrl：(string)模板文件地址，如果设置了该属性，那么将会忽略template的配置。 replace：(bool)指示是否替换元素，如果设置为true,则替换，否则（设置为false或不设置）追加到元素内部 transclude：(bool)是否将指令的子节点移动到一个新模板内部，如果在模板中指定了ng-transclude，那么会将元素原本的内容移动到新的模板内部，具体看示例二 scope：(bool or object)设置作用域，如果设置为false[默认值]，则使用现有的作用域；如果设置为true，则创建一个新的作用域。设置为object时，设定作用域绑定策略 controller：创建一个控制器，它会暴露一个API，实现在多个指令之间进行通信 require：设置依赖的指令。不设置，则无依赖，示例：’?\\^testDirective’，其中，?表示该指令可选，^表示需要遍历DOM树查找指令 link：链接函数，function(scope,iElement,iAttrs){}，其中的i表示实例，所以在link中接收的是实例元素和实例元素属性 compile：编译函数，function(tElement,tAttrs,transclude){}，其中t表示模板，所以在compile中使用的是模板元素。在编译过程中，可以返回preLink(链接前)，postLink(链接后)函数，compile函数只会调用一次，而link函数的调用次数等于things中的元素个数，所以多余共同的东西，那么最好放在compile函数中实现（出于效率考虑） 注：设置了compile属性之后，指令将忽略link属性，同时compile函数的返回值将作为link函数使用 Angular Directive 示例示例一(简单指令)12345678910111213141516171819202122&lt;!--demo1指令定义--&gt;angular.module('app').directive('demo1',function()&#123; return &#123; restrict:'AE',/*标签或者属性*/ template:'&lt;div&gt;Hello&lt;/div&gt;', replace:true &#125;&#125;);&lt;!--使用--&gt;&lt;html ng-app=\"app\"&gt; &lt;head&gt;...&lt;/head&gt; &lt;body&gt; &lt;demo1&gt;&lt;/demo1&gt; &lt;div data-demo1&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;!--结果(指令将满足条件的元素替换为了新的内容)--&gt;&lt;body&gt; &lt;div&gt;Hello World!&lt;/div&gt; &lt;div demo1=\"\"&gt;Hello World!&lt;/div&gt;&lt;/body&gt; 操作步骤分析 定义一个模块app，并创建了一个指令demo1。 设定该指令可采用元素的标签和属性申明，并设置了一个文本模板，同时设置了replace=true。 在html中，采用标签如&lt;demo1&gt;&lt;/demo1&gt;和属性&lt;div demo1&gt;&lt;/div&gt;来实现调用 示例二（变换）123456789101112131415161718192021222324252627282930&lt;!--demo2指令定义--&gt;angular.module('app.directive.demo2',[]).directive('demo2',function()&#123; return &#123; restrict:'E', template:'&lt;div&gt;This is Demo2&lt;div ng-transclude&gt;&lt;/div&gt;&lt;/div&gt;', transclude:true &#125;&#125;);&lt;!--使用--&gt;&lt;demo2&gt; &lt;span&gt;原始的内容，&lt;/span&gt;&lt;br/&gt; &lt;span&gt;还会在这里。&lt;/span&gt;&lt;/demo2&gt;&lt;demo2&gt;&lt;/demo2&gt;&lt;!--页面生成的HTML--&gt; &lt;demo2&gt; &lt;div&gt;This is Demo2 &lt;div ng-transclude=\"\"&gt; &lt;span class=\"ng-scope\"&gt;原始的内容，&lt;/span&gt;&lt;br class=\"ng-scope\"&gt; &lt;span class=\"ng-scope\"&gt;还会在这里。&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;/demo2&gt;&lt;demo2&gt; &lt;div&gt;This is Demo2 &lt;div ng-transclude=\"\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/demo2&gt; 分析 通过在指令中设置transclude=true，同时在template中包含&lt;div ng-transclude&gt;，实现了将元素内部元素移动到了ng-transclude元素内部，并创建了新的作用域 示例三（link与compile）12345678910111213141516171819202122232425262728293031/*指令*/angular.module('app.directive.demo3',[]).directive('demo3Link',function()&#123; return &#123; restrict:'E', template:'&lt;div&gt;This is Demo3Link&lt;/div&gt;', link:function(scope,iElement,iAttrs)&#123; iElement.html('&lt;div&gt;good link&lt;/div&gt;'); &#125; &#125;&#125;).directive('demo3Compile',function()&#123; return &#123; restrict:'E', template:'&lt;div&gt;This is Demo3Compile&lt;/div&gt;', compile:function(tElement,tAttrs,transclude)&#123; tElement.html('&lt;div&gt;test demo3 compile&lt;/div&gt;'); return function(scope,iElement,iAttrs)&#123; //iElement.html('&lt;div&gt;good compile&lt;/div&gt;'); &#125;; &#125; &#125; &#125;);/*使用*/&lt;demo3-link&gt;&lt;/demo3-link&gt; &lt;demo3-link&gt;&lt;/demo3-link&gt; &lt;demo3-compile&gt;&lt;/demo3-compile&gt;/*页面生成的HTML*/ &lt;demo3-link&gt;&lt;div&gt;good link&lt;/div&gt;&lt;/demo3-link&gt; &lt;demo3-link&gt;&lt;div&gt;good link&lt;/div&gt;&lt;/demo3-link&gt; &lt;demo3-compile&gt;&lt;div&gt;test demo3 compile&lt;/div&gt;&lt;/demo3-compile&gt; 分析compile用于在编译期处理模板内容，并能设置preLink和postLink函数，此时将不能设置link函数，代码如下： 1234567891011compile:function(tElement,tAttrs,transclude)&#123; tElement.html(&apos;&lt;div&gt;test demo3 compile&lt;/div&gt;&apos;); return &#123; pre:function preLink(scope,iElement,iAttrs)&#123; console.log(&apos;preLink&apos;); &#125;, post:function postLink(scope,iElement,iAttrs)&#123; console.log(&apos;postLink&apos;); &#125; &#125;;&#125; link用于对替换后的元素进行操作，如果参数是iElement。 示例四（简单加法计算器）1234567891011121314151617181920212223/*代码在这里*/angular.module(&apos;app.directive.demo4&apos;,[]).directive(&apos;demo4&apos;,function()&#123; return &#123; restrict:&apos;E&apos;, template:&apos;&lt;fieldset&gt;&lt;legend&gt;计算两个数之和&lt;/legend&gt;&apos; + &apos;&lt;div&gt;&lt;input type=&quot;text&quot; ng-model=&quot;num1&quot;&gt;+&lt;input type=&quot;text&quot; ng-model=&quot;num2&quot;&gt;=&lt;span&gt;&#123;&#123;total&#125;&#125;&lt;/span&gt;&lt;/div&gt;&apos; + &apos;&lt;/fieldset&gt;&apos;, replace:true, link:function(scope,iElement,iAttrs)&#123; scope.num1=0; scope.num2=0; scope.total=0; scope.$watch(&apos;num1+num2&apos;,function(to,from)&#123; scope.total=+scope.num1+(+scope.num2) &#125;) &#125; &#125;&#125;);/*HTML在这里*/&lt;demo4&gt;&lt;/demo4&gt;、/*效果请自行测试*/ 分析可以利用指令完成特定的功能了。 示例五（negHotkeys指令代码）代码在这里 总结 指令依附于模块 一个模块可以有多个指令，但是需要采用示例三的写法 指令可以语义化标签，实现html组件化 其他…"},{"title":"AngularJS：Looking under the hood","permalink":"http://hstarorg.github.io/blog/blog/2015/03/13/Angular相关/AngularJS：Looking under the hood/","text":"原文地址：https://www.binpress.com/tutorial/angular-js-looking-under-the-hood/153 用AngularJS写得越多，你就越惊叹于它的神奇。我对Angular能做的一些奇妙的事情非常好奇，然后我决定分析它的源代码，看看我能否揭示它的一些秘密。我记录了我在23000多行Angular源码中发现的真正有用的，能够解释Angular先进（和隐藏）的方面的一些内容。 1、Dependency Injection annotation process依赖注入（DI）是除开用代码获取或创建依赖之外的一条不同的请求依赖的方式。简单的说，依赖是作为一个注入对象传递给我们的。Angular允许我们在我们的应用程序中通过像Controllers和Directives的方法来使用DI。我们能创建自己的依赖，同时允许Angular在请求它们的时候被注入。 在Angular中，一个最常用的被请求的依赖是 $scope。例如： function MainCtrl ($scope){ //access to $scope } angular.module(&apos;app&apos;).controller(&apos;MainCtrl&apos;, MainCtrl); 对于没有使用过Angular提供的依赖注入的JavaScript开发者来说，这看起来像一个局部变量名。实际上，它仅仅是我们所请求的依赖名称的一个占位符。Angular查找这些占位符，然后通过DI将它们转换为真正的依赖对象，让我们来仔细看看。 方法参数直到我们压缩我们的应用前，方法参数都运行正常。当你压缩你的代码，你的方法定义将会用字符表示参数而不是单词-这意味着Angular不能找到你想要的！Angular使用了一个方式来解决，调用function的 toString() 方法。这将返回函数的字符串形式！接下来我们就能访问正在被请求的参数。Angular var FN_ARGS = /^function\\s*[^\\(]*\\(\\s*([^\\)]*)\\)/m; var FN_ARG_SPLIT = /,/; var FN_ARG = /^\\s*(_?)(\\S+?)\\1\\s*$/; var STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg; Angular做的第一件事就是将函数转换为字符串，这是JavaScript中非常有用的一个特性。这将给我们一个字符串类型的函数，如： &apos;function MainCtrl ($scope) {...}&apos; 接下来，Angular使用如下方法，移除所有的注释： fnText = fn.toString().replace(STRIP_COMMENTS, &apos;&apos;); 紧接着，Angular从处理好的function中分割参数来创建真正有用的部分， argDecl = fnText.match(FN_ARGS); Angular接下来使用 .split() 来移除空白字符，同时返回我们请求的参数数组。为了更完美，Angular使用了一个内部的forEach方法来迭代这个数组，并匹配参数名称然后将它们添加到 $inject 数组中。 forEach(argDecl[1].split(FN_ARG_SPLIT), function(arg) { arg.replace(FN_ARG, function(all, underscore, name) { $inject.push(name); }); }); 这是你能想象的一个昂贵的处理流程。对每个函数的4个正则查找和一很多转换会造成性能损耗。当我们得到了Angular抽象的 $inject 数组，我们可以直接切入且田填充 $inject 数组来保存Angular困难和开销时间长的操作。 $inject 对象我们可以通过在函数上添加 $inject属性来指定依赖自身，其中，如果存在的话，Angular使用DI注解。这是很容易的最可读的语法。例子如下： function SomeCtrl ($scope) { } SomeCtrl.$inject = [&apos;$scope&apos;]; angular.module(&apos;app&apos;, []) .controller(&apos;SomeCtrl&apos;, [&apos;$scope&apos;, SomeCtrl]); 这样节省了Angular的许多工作-替代了检查方法参数，或者是操纵数组（详情请查看下一章节：Array Arguments）,它仅仅返回和运行指定的 $inject 数组。简单，高性能。 理想情况下，由于依赖注入在我们自己的时间和Angular的转换时间上开销很大，我们可以使用任务运行工具如Grunt.js或者是Gulp.js 来自动化注入任务或者是数组语法。 Note：这个并没有实例化被依赖的所有服务，Angular所做的只是标注相关的名字-框架的其他部分关心对象注入。 Array Arguments最后一个例子使用了我们通常看见的数组索引对应函数参数序号的语法，例如： [&apos;$scope&apos;, function($scope){}] 数组的顺序是非常重要的，因为函数的参数将会按照同样的顺序，以此来避免依赖被错误的实例化和可能引发的错误。 function SomeCtrl ($scope, $rootScope) { } angular.module(&apos;app&apos;, []) .controller(&apos;SomeCtrl&apos;, [&apos;$scope&apos;, ‘$rootScope’, SomeCtrl]); 我们需要做的是传递函数作为数组的最后一个项，Angular会删除这个函数，并遍历数组所注明的依赖名称，就好像我们创建的 $inject 属性。当Angular解析一个方法的时候，它会检查参数是不是一个数组，如果是，那么最后一项是函数，其他的则是依赖。 else if (isArray(fn)) { last = fn.length - 1; assertArgFn(fn[last], &apos;fn&apos;); $inject = fn.slice(0, last); } 2、Factory vs ServiceFactory 和 Service 非常类似，但往往开发人员都难以理解它们。 当 .service() 已经实例化，那么 new Service() 将被引擎调用，返回一个新实例给我们。本质上，。.service() 是作为构造函数被使用的。 service 基本上是一个 factory，然而它是创建时被实例化，因为，你需要在 service 中使用this来注册变量和函数，来替代在factory中返回一个对象的方式。 factory 是非常接近面向对象中的“工厂模式”，当你注入了这个 factory ,你就获得了完整的方法，允许你创建你需要的新的实例-本质上是通过一个对象创建多个新对象。 你可以看下在Angular源码中的内部的工作： function factory(name, factoryFn) { return provider(name, { $get: factoryFn }); } function service(name, constructor) { return factory(name, [&apos;$injector&apos;, function($injector) { return $injector.instantiate(constructor); }]); } 3、New $scope creation from $rootScopeAngular中所有的scope都是 $rootScope 的下级。 $rootScope 是通过 new Scope()创建的，进一步的子 scope 是通过 $scope.$new() 创建的。 var $rootScope = new Scope(); 在 $new 方法里面，Angular设置了一个原型链来允许允许 scope 引用它们的父亲，它们的自己跟踪（作为生命周期），和以前的兄弟 scope 。 从下面的代码，如果你请求了一个隔离的 scope ，它会创建一个 new Scope() ,否则，它会创建一个从父级继承的子 scope 。 我省略了一些不必要的代码，但这里的是重点： $new: function(isolate) { var child; if (isolate) { child = new Scope(); child.$root = this.$root; } else { // Only create a child scope class if somebody asks for one, // but cache it to allow the VM to optimize lookups. if (!this.$$ChildScope) { this.$$ChildScope = function ChildScope() { this.$$watchers = null; }; this.$$ChildScope.prototype = this; } child = new this.$$ChildScope(); } child[&apos;this&apos;] = child; child.$parent = this; return child; } 当你使用$scope.$new()来测试Controller的时候，这也是非常好的能了解测试目的。这有助于明确对我来说Angular是如何创建新的scope的，为什么用Angular mocks 模块来嘲笑测试驱动开发（TDD）。 4、Digest CycleDigest Cycle 经常作为 $digest 被我们看到，这是Angular双向绑定的能力。当一个模型值更新的时候，它会运行，检查它最后已知的值，如果值有变化，呼叫适当的监听器。这是基本的脏检查 - 它针对所有有可能的值来检查，如果是脏值，那么呼叫相关的监听器，直到他没有脏值。我们快速看一下它是如何工作的： $scope.name = &apos;Todd&apos;; $scope.$watch(function() { return $scope.name; }, function (newValue, oldValue) { console.log(&apos;$scope.name was updated!&apos;); } ); 当你调用 $scope.$watch，你注册了两件事。参数一是一个函数，返回你想要监视的值（当你提供一个字符串的时候，Angualr会将他转换为函数）。当 $digest 运行时，监视的参数将被调用，返回任何你想要的值。参数二是当你的参数一变化时，想要执行的函数。看一下Angular是怎样注册watch的。 $watch: function(watchExp, listener, objectEquality) { var get = $parse(watchExp); if (get.$$watchDelegate) { return get.$$watchDelegate(this, listener, objectEquality, get); } var scope = this, array = scope.$$watchers, watcher = { fn: listener, last: initWatchVal, get: get, exp: watchExp, eq: !!objectEquality }; lastDirtyWatch = null; if (!isFunction(listener)) { watcher.fn = noop; } if (!array) { array = scope.$$watchers = []; } // we use unshift since we use a while loop in $digest for speed. // the while loop reads in reverse order. array.unshift(watcher); return function deregisterWatch() { arrayRemove(array, watcher); lastDirtyWatch = null; }; } 这个函数推送你提供的参数到 scope 的 $$watchers 数组中，同时，返回一个方法允许你停止watch。 然后，每当$scope.$apply或者$scope.$digest 运行时，digest cycle将被运行。 未完…待续…"},{"title":"AngularJS官方FAQ","permalink":"http://hstarorg.github.io/blog/blog/2015/03/13/Angular相关/AngularJS官方FAQ/","text":"相关：最佳实践，反模式1、为什么会觉得jQuery插件缺失？请记住：当你在使用jQuery插件时，请在AngularJS之前加载jQuery库 分析： 因为AngularJS自带jqLite（可以理解为jQuery的精简版），如果先引入AngularJS的话，那么AngularJS会采用jqLite，而不是完整的jQuery库。 2、如何从一个Controller中访问DOM元素？不要从Controller中执行DOM的选择/遍历。HTML还没有被渲染。查一查”directive“ 3、为什么Angular说 controller/directive等缺失？调用 angular.module(&#39;myApp&#39;,[]) 总是会创建一个新的模块（同时干掉已有的重名模块）。相反，使用一个参数的方式调用 angular.module(‘myApp’) 来引用已经存在的模块。 4、如何渲染未转义的数据？12345$sce.trustAsHtml(data)如何禁用$sce?app.config(['$sceProvider', function($sceProvider) &#123; $sceProvider.enabled(false);&#125;]); 5、当array/object/$resource-result变化时，应该如何监视？123$scope.$watch 有第三个参数设置来监视值变化（非引用变化）$watch(watchExpression, listener, [objectEquality]);[objectEquality]设置为true，则使用angular.equals对象相等，而不是使用引用相等比较。 6、怎样才能序列化表单数据提交？不要这么做！ 不要尝试手动收集输入框值。仅仅只需要在每一个表单元素上附加 ng-model=&quot;data.myField，在需要使用的地方，使用 $scope.data 即可 7、总是在 ng-models 上使用(.) =&gt;最佳实践12&lt;any ng-model=\"book.price\" /&gt;&lt;any ng-model=\"book.name\" /&gt; 8、应该如何从 service 中访问 scope ？$rootScope 相当于 ng-app 标记，它能够被引导或者是服务注入，可以用于在所有的 scopes 上添加新功能和值 注意：避免这样做–这相当于定义全局变量 9、module().factory() 和 module().service() 不同点是什么？查看讨论信息 10、如何防止无样式的内容闪现（页面显示双大括号绑定表达式）？在一些地方使用 ng-bind 来替换双括号表达式 11、为什么 &lt;a ng-click=&quot;go()&quot;&gt; 不工作？仅有的 ng-* 属性中，需要 的只有 ng-src 和 ng-href，因为最终的结果必须是一个字符串，不是一个表达式。所以其他的不能工作。 12、嵌套 routes/views?或许吧 13、可以在行内指定模板或者是分部视图吗？可以。可以采用 &lt;script id=&quot;some/partial.html&quot; type=&quot;text/ng-template&quot;&gt;&lt;/script&gt; ，Angular会使用它来替换。 14、 如何在 ngResource 地址中使用端口？如下：$resource(&apos;example.com\\\\:8080&apos;) 15、为什么插件触发的change事件似乎不工作？Angular监视 input 事件，不是’change’ 事件。 16、不要使用jQuery来切换crap(待定：无效元素)，在行内使用一些变量标记。1&lt;a ng-click=\"flags.open=!flags.open\"&gt;...&lt;div ng-class=\"&#123;active:flags.open&#125;\"&gt; 17、如何从DOM检查上查看 scope ？Google Chrome:安装 Batarang extension,检查一个DOM元素，然后在console中键入$scope Firefox/Firebug：检查一个DOM元素，然后在console中键入 angular.element($0).scope()或者 $($0).scope() IE10+: 使用F12工具，检查一个元素。然后在console中键入 angular.element($0).scope()或者 $($0).scope() 18、你有一些好的指令示例/库吗？AngularUI 是非常棒的AngularJS工具集合（甚至是更好的示例代码） 19、IE？针对IE8.0或者更早，你需要阅读这个和使用这个 20、必须对路由使用#?参考 $locationProvider 21、你应该在尝试用指令包装jQuery插件前，优先尝试使用AngularUI Passthru Directive (uiJq) 22、为什么我的 $scope.$watch() 递归触发?如果你在 $scope.$watch(newVal,oldVal)中改变 newVal ，它会重复触发。在 $watch 运行后，$scope 会重新评估，被观察对象将被重新触发。 23、何时我需要使用 $scope.$apply() ?仅仅需要在没有angular 事件/回调时 使用 $scope.$apply()。它通常不属于任何地方。 24、启用了 html5Mode ，如何获取&lt;a href /&gt;的后退行为？如果你想一个链接能够全页面刷新，那么只需要在a标记上添加 target=”_self” 25、如何 .preventDefualt() 或 .stopPropagation() ?所有的 ng-click 和相关的绑定都注入了 $event 事件对象，你可以用它来调用 .preventDefualt()，甚至是对象传递给你的方法。 26、AngularJS在我的Chrome扩展中不工作！你需要使用 ng-csp 27、如何缓存 $http 和html 分部视图123456789101112//使用装饰器，添加缓存功能myAppModule.config(function($routeProvider, $provide) &#123; $provide.decorator('$http', function($delegate)&#123; var get = $delegate.get; $delegate.get = function(url, config)&#123; url += (url.indexOf('?') !== -1) ? '?' : '&amp;'; url += 'v=' + cacheBustVersion; return get(url, config); &#125;; return $delegate; &#125;);&#125;); 测试1、拒绝/解决一个 $q.defer() 不通过你必须在处理它们的时候添加 $scope.$apply() 2、Jasmine spyOn() 不执行 spy’d 功能不一定是AngularJS的问题，但是你需要追加 .addCallThrough()"},{"title":"用AngularJS开发Web应用程序","permalink":"http://hstarorg.github.io/blog/blog/2015/03/13/Angular相关/用AngularJS开发Web应用程序/","text":"##章节一：Angular 禅道## ###本章生词### serve = 提供 take a brief = 先简要的 introduction = 介绍 concept = 概念 a lot of = 许多 material = 材料 cover = 概括 painless = 无痛的 plenty = 丰富、大量 unique = 独特的 doubt = 疑问 shape = 塑造 explain = 解释 expect = 预计 get familiar with = 熟悉 become aware = 察觉 sophisticated = 复杂 dependency injection = 依赖注入nuance nuance = 细微之处 general = 一般 purpose = 目的 shines = 耀眼 recent = 最近 addition = 此外 mostly = 主要的 due = 由于 innovative = 创新 yet = 但 attract = 吸引 ease = 缓解 solid = 扎实 engineering = 工程 practice = 实践 indeed = 的确 respects = 方面 explicit = 明确的 capable = 能 figure out = 弄清楚 interesting = 有趣的 interpret = 解析 mistaken = 错误，谬 several = 几个，数个 typically = 通常 treasure = 宝藏 testability = 可测试性 built-in support 内置支持 thoroughly = 彻底的 relatively = 比较的 actor = 演员 personal = 个人的 turned out = 横空出世 这个章节介绍了AngularJS，包括框架和它背后的项目。首先，我们先简要的了解项目本身：谁become aware驱动了它，在哪儿可以找到源代码和文档，如何寻求帮助等等。 这个章节的大部分是介绍AngularJS框架，它的核心概念和编码模式。包含有许多概括（总结）性的材料，使得学习进程快速无障碍，同时也有丰富的代码示例。 AngularJS是一个独特的框架，毫无疑问的引领一个Web开发潮流。这也是为什么章节的最后部分解释了是什么让AngularJS如此特别，它和其它外部框架之间的差异和我们能在未来如何设想它。 这个章节包含了以下几个主题： 如何用AngularJS书写一个简单的Hello World 程序。在做这个的过程中，你将了解到在哪儿找到框架源代码、文档以及社区。 熟悉AngularJS应用程序的基本构造块：Templates、Directives、Scopes和Controllers。 察觉AngularJS复杂的依赖注入系统以及它所有的细微之处。 理解AngularJS与其他框架或库（特别是jQuery）之间的差异，是什么使得它如此特别。 ###AngularJS简介###AngularJS是一个用JavaScript编写的客户端MVC框架，它运行于Web浏览器，能够极大的帮助我们（开发者）编写模块化，单页面，Ajax风格的Web Applications。它是一个平常的框架，不过如果用于编写CRUD类型的web app，那么它将非常耀眼。 ###熟悉框架###AngularJS是最近的客户端mvc框架的例外，但是它吸引了许多注意力，主要是由于它创新的模板系统，减轻了开发，同时有很扎实的工程实践。的确，它的模板系统独特于许多方面： 使用HTML作为模板语言 不要求明确的DOM刷新，AngularJS 能跟踪用户操作、浏览器事件和模型变化，来选择何时和那个模板将被刷新 它有非常有趣的和可扩展的组件子系统，它能教会浏览器如何解析新的HTML标签和属性 模板子系统可能是AngularJS中最常见的部分，但是不要错误的认为AngularJS是单页Web程序所需要的包含数个工具和常用服务的完整框架包。 AngularJS同样有一些隐藏的宝藏，依赖注入（DI=dependency injection）和可测试特性的强烈关注。DI的内置支持能够非常容易的访问从一个极小的、彻底的可测试服务创建的web app。 ###项目发展路线###AngularJS是客户端MVC框架中比较新的成员；它的1.0版本发布于2012年6月。实际上，这个框架作为谷歌雇员Misko Hevery的个人项目开始于2009年。最初的idea是如此的好，在写作本文的同时，这个项目已经被Google正式支持，并且有Google的完整团队全职维护这个框架。 AngularJS是托管在GitHub上的，基于MIT协议的开源项目 ###社区###"},{"title":"AngularJS教程：1W字综合指南","permalink":"http://hstarorg.github.io/blog/blog/2015/03/13/Angular相关/AngularJS教程：1W字综合指南/","text":"AngularJSj教程：1W字指南（译）原文地址：http://www.airpair.com/angularjs 1、AngularJS简介Angular 是用于编写引人注目的Web应用程序的是客户端 MVW JavaScript框架。它由Google创建好维护，（offers a futuristic spin on the web and its upcoming features and standards.Read more at http://www.airpair.com/angularjs#tY7q00WpGrTLB71Z.99） MVW 即 Model-View-Whatever,它是能在开发应用程序时，为我们提供灵活性的一种设计模式。我们可以选择MVC(Model-View-Controller)或者是MVVM(Model-View-ViewModel)方式。 本教程可以作为一个最终的资源来开始学习AngularJS,它的概念和它背后的API，同时能帮助您学习如何实现现代的Web应用程序。 AngularJS自身作为增强HTML的一个框架。它从多种语言包括JavaScript和服务端语言中获得灵感，使得HTML也成为了动态语言。这意味着我们获得了一个完全的数据数据方式来开发应用程序，不再需要刷新实体，更新DOM和其他费时任务如浏览器bug和不一致。我们可以只关注数据，让数据关心HTML的方式来编写我们的应用程序。 2、JavaScript框架中的工程概念AngularJS在处理提供数据绑定和其他工程概念上，和其他框架如Backbone.js和Ember.js采取了不同了做法。我们坚持使用熟悉的、令人喜欢的HTML，使Angular拦截它，并增强它。Angular将纯粹的JavaScript对象用于数据绑定，保证任何模型变化都会更新DOM。当模型值更新了一次，Angular会更新来自应用程序的状态来源对象。 2.1、MVC 和 MVVM如果你已经习惯了构建静态网站，你可能更熟悉手动一块一块的构建HTML，通过数据一遍一遍的打印相同的HTML。这可能是grid中的列，一个导航结构，一个链接列表或者是图片等等。在这个实例中，你需要习惯一点小东西的变化都需要手动更新HTML的痛苦，你必须更新模板来保持其他用途的一致性。你还要为每个导航项目杜绝相同的HTML。 深呼吸一下，通过Angular我们能实现恰当的关注点分离以及动态HTML。这意味着数据在模Model中，HTML是作为一个微小的模板被渲染为View，我们能使用Controller来连接它们两个，并驱动Model和View值的变化。"},{"title":"编写高质量JS代码的68个有效方法（十三）","permalink":"http://hstarorg.github.io/blog/blog/2015/03/12/编写高质量JS代码的68个有效方法-读书笔记/[20150312]编写高质量JS代码的68个有效方法（十三）/","text":"##No.61、不要阻塞I/O事件队列 Tips：： 异步API使用回调函数来延缓处理代价高昂的操作以避免阻塞主应用程序 JavaScript并发的接收事件，但会使用一个事件队列按序地处理事件处理程序 在应用程序事件队列中绝不要使用阻塞的I/O JavaScript程序是构建在事件之上的。在其他一些语言中，我们可能常常会实现如下代码： var result = downFileSync(&apos;http://xxx.com&apos;); console.log(result); 以上代码，如果downFileSync需要5分钟，那么程序就会停下来等待5分钟。这样的函数就被称为同步函数（或阻塞函数）。如果在浏览器中实现这样的函数，那么结果就是浏览器卡住，等待下载完成后，再继续响应。那么，这将极大的影响体验。所以，在JavaScript中，一般使用如下方式： downFileAsync(&apos;http://xxx.com&apos;, function(result){ console.log(result); }); console.log(&apos;async&apos;); 以上代码执行中，就算下载文件要5分钟，那么程序也会立马打印出“async”，然后在下载完成的时候，打印result出来。这样才能保证执行环境能正确响应客户的操作。 JavaScript并发的一个最重要的规则是绝不要在应用程序事件队列中使用阻塞I/O的API。在浏览器中，甚至基本没有任何阻塞的API是可用的。其中XMLHttpRequest库有一个同步版本的实现，被认为是一种不好的实现，影响Web应用程序的交互性。 在现代浏览器（IE10+(含)、Chrome、FireFox）中，提供了Worker的API，该API使得产生大量的并行计算称为可能。 如何使用？ 首先，编写两个文件,第一个是task.js,如下： //task.js console.time(&apos;t1&apos;); var sum = 0; for(var i = 0; i &lt; 500000000; i++){ sum += i; } console.log(&apos;test&apos;); console.timeEnd(&apos;t1&apos;); postMessage(&apos;worker result:&apos; + sum); 然后是index.html，用于调用worker，代码如下： // index.html &lt;button onclick=&quot;alert(&apos;aa&apos;)&quot;&gt;Test&lt;/button&gt; &lt;script&gt; var worker = new Worker(&apos;test.js&apos;); worker.onmessage = function(evt){ console.log(evt.data); }; &lt;/script&gt; 在index.html的JavaScript脚本中。使用var worker = new Worker(&#39;test.js&#39;);来实例化一个Worker，Worker的构造为：new Worker([string] url),然后注册一个onmessage事件，用于处理test.js的通知，就是test.js中的postMessage函数。test.js中的每一次执行postMessage函数都会触发一次Worker的onmessage回调。 在静态服务器中访问index.html,可以看到输出为： test t1: 2348.633ms worker result:124999999567108900 再来看看Worker的优缺点，我们可以做什么： 可以加载一个JS进行大量的复杂计算而不挂起主进程，并通过postMessage，onmessage进行通信 可以在worker中通过importScripts(url)加载另外的脚本文件 可以使用 setTimeout(), clearTimeout(), setInterval(), and clearInterval() 可以使用XMLHttpRequest来发送请求 可以访问navigator的部分属性 有那些局限性： 不能跨域加载JS worker内代码不能访问DOM 各个浏览器对Worker的实现不大一致，例如FF里允许worker中创建新的worker,而Chrome中就不行 不是每个浏览器都支持这个新特性 更多信息，请参考： https://developer.mozilla.org/zh-CN/docs/Web/Guide/Performance/Using_web_workers http://www.cnblogs.com/feng_013/archive/2011/09/20/2175007.html ##No.62、在异步序列中使用嵌套或命名的回调函数Tips：： 使用嵌套或命名的回调函数按顺序地执行多个异步操作 尝试在过多的嵌套的回调函数和尴尬的命名的非嵌套回调函数之间取得平衡 避免将可被并行执行的操作顺序化 想象一下如下需求，异步请数据库查找一个地址，并异步下载。由于是异步，我们不可能发起两个连续请求，那么js代码很可能是这样的： db.lookupAsync(&apos;url&apos;, function(url){ downloadAsync(url, function(result){ console.log(result); }); }); 我们使用嵌套，成功解决了这个问题，但是当这样的依赖很多时，我们的代码可能是这样： db.lookupAsync(&apos;url&apos;, function(url){ downloadAsync(&apos;1.txt&apos;, function(){ downloadAsync(&apos;2.txt&apos;, function(){ downloadAsync(&apos;3.txt&apos;, function(){ //do something... }); }); }); }); 这样就陷入了回调地狱。要减少过多的嵌套的方法之一就是将回调函数作为命名的函数，并将它们需要的附加数据作为额外的参数传递。比如： db.lookupAsync(&apos;url&apos;, downloadUrl); function downloadUrl(url){ downloadAsync(url, printResult); } function printResult(result){ console.log(result); } 这样能控制嵌套回调的规模，但是还是不够直观。实际上，在node中解决此类问题是用现有的模块，如async。 ##No.63、当心丢弃错误Tips：： 通过编写共享的错误处理函数来避免复制和粘贴错误处理代码 确保明确地处理所有的错误条件以避免丢弃错误 一般情况下，我们的错误处理代码如下： try{ a(); b(); c(); }catch(ex){ //处理错误 } 对于异步的代码，不可能将错误包装在一个try中，事实上，异步的API甚至根本不可能抛出异常。异步的API倾向于将错误表示为回调函数的特定参数，或使用一个附加的错误处理回调函数（有时被称为errbacks）。代码如下: downloadAsync(url, function(result){ console.log(result); }, function(err){ //提供一个单独的错误处理函数 console.log(&apos;Error:&apos; + err); }); 多次嵌套时，错误处理函数会被多次复制，所以可以将错误处理函数提取出来，减少重复代码，代码如下： downloadAsync(&apos;1.txt&apos;, function(result){ downloadAsync(&apos;2.txt&apos;, function(result2){ console.log(result + result2); }, onError); }, onError); 在node中，异步API的回调函数第一个参数表示err，这已经成为一个大众标准 ##No.64、对异步循环使用递归Tips：： 循环不能是异步的 使用递归函数在时间循环的单独轮次中执行迭代 在事件循环的单独伦次中执行递归，并不会导致调用栈溢出 针对异步下载文件，如果要使用循环，大概是如下代码： function downloadFilesSync(urls){ for(var i = 0, len = urls.length; i &lt; len; i++){ try{ return downloadSync(urls[i]); }catch(ex){ } } } 以上代码并不能正确工作，因为方法一调用，就会启动所有的下载，并不能等待一个完成，再继续下一个。 要实现功能，看看下面的递归代码： function downloadFilesSync(urls){ var len = urls.length; function tryNextURL(i) { if (i &gt;= n) { console.log(&apos;Error&apos;); return; //退出 } downloadAsync(urls[i], function(result){ console.log(result); //下载成功后，尝试下一个。 tryNextURL(i + 1); }); } tryNextURL(0);// 启动递归 } 类似这样的实现，就能解决批量下载的问题了。 ##No.65、不要再计算时阻塞事件队列Tips：： 避免在主事件队列中执行代码高昂的算法 在支持Worker API的平台，该API可以用来在一个独立的事件队列中运行长计算程序 在Worker API 不可用或代价高昂的环境中，考虑将计算程序分解到事件循环的多个轮次中 打开浏览器控制台，执行 while(true){}，会是什么效果？ 好吧，浏览器卡死了！！！ 如果有这样的需求，那么优先选择使用Worker实现吧。由于有些平台不支持类似Worker的API，那么可选的方案是将算法分解为多个步骤。代码如下： //首先，将逻辑分为几个步骤 function step1(){console.log(1);} function step2(){console.log(2);} function step3(){console.log(3);} var taskArr = [step1, step2, step3]; var doWork = function(tasks){ function next(){ if(tasks.length === 0){ console.log(&apos;Tasks finished.&apos;); return; } var task = tasks.shift(); if(task){ task(); setTimeout(next, 0); } } setTimeout(next, 0); } //启动任务 doWork(taskArr); ##No.66、使用计数器来执行并行操作Tips：： JavaScript应用程序中的事件发生是不确定的，即顺序是不可预测的 使用计数器避免并行操作中的数据竞争 先看一个简单的示例： function downFiles(urls){ var result = [],len = urls.length; if(len === 0){ console.log(&apos;urls argument is a empty array.&apos;); return; } urls.forEach(function(url){ downloadAsync(url, function(text){ result.push(text); if(result.length === len){ console.log(&apos;download all files.&apos;); } }); }); } 有什么问题呢？result的结果和urls是顺序并不匹配，所以，我们不知道怎么使用这个result。 如何改进？请看如下代码，使用计数器，代码如下： function downFiles(urls){ var result = [],len = urls.length; var count = 0;// 定义计数器 if(len === 0){ console.log(&apos;urls argument is a empty array.&apos;); return; } urls.forEach(function(url, i){ downloadAsync(url, function(text){ result[i] = text; count++; //计数器等于url个数，那么退出 if(count === len){ console.log(&apos;download all files.&apos;); } }); }); } ##No.67、绝不要同步地调用异步的回调函数Tips：： 即使可以立即得到数据，也绝不要同步地调用异步回调函数 同步地调用异步的回调函数扰乱了预期的操作序列，并可能导致意想不到的交错代码 同步地调用异步的回调函数可能导致栈溢出或错误的处理异常 使用异步的API，比如setTimeout函数来调用异步回调函数，使其运行于另外一个回合 如果异步下载代码，优先从缓存拿数据，那么代码很可能是： var cache = new Dict(); function downFileWithCache(url, onsuccess){ if (cache.has(url)){ onsuccess(cache.get(url)); return; } return downloadAsync(url, function(text){ cache.set(url, text); onsuccess(text); }); } 以上代码，同步的调用了回调函数，可能会导致一些微妙的问题，异步的回调函数本质上是以空的调用栈来调用，因此将异步的循环实现为递归函数是安全的，完全没有累计赵越调用栈控件的危险。同步的调用不能保证这一点，所以，更好的代码如下： var cache = new Dict(); function downFileWithCache(url, onsuccess){ if (cache.has(url)){ setTimeout(onsuccess.bind(null, cache.get(url)), 0) return; } return downloadAsync(url, function(text){ cache.set(url, text); onsuccess(text); }); } ##No.68、使用promise模式清洁异步逻辑Tips：： promise代表最终值，即并行操作完成时最终产生的结果 使用promise组合不同的并行操作 使用promise模式的API避免数据竞争 在要求有意的竞争条件时使用select（也被称为choose） 一直以来，JavaScript处理异步的方式都是callback，当异步任务很多的时候，维护大量的callback将是一场灾难。所以Promise规范也应运而生，http://www.ituring.com.cn/article/66566 。 Promise已经纳入了ES6，而且高版本的Chrome、Firefox都已经实现了Promise，只不过和现如今流行的类Promise类库相比少些API。 看下最简单的Promise代码（猜猜最后输出啥？）： var p1 = new Promise(function(resolve, reject){ setTimeout(function(){ console.log(&apos;1&apos;); resolve(&apos;2&apos;); }, 3000); }); p1.then(function(val){ console.log(val); }); 如果代码是这样呢？ var p1 = new Promise(function(resolve, reject){ setTimeout(function(){ console.log(&apos;1&apos;); //resolve(&apos;2&apos;); reject(&apos;3&apos;); }, 3000); }); p1.then(function(val){ console.log(val); }, function(val){ console.log(val); }); 再来看一个Promise.all的示例： Promise.all([new Promise(function(resolve, reject){ setTimeout(function(){ console.log(1); resolve(1); }, 2000); }), new Promise(function(resolve, reject){ setTimeout(function(){ console.log(2); resolve(2); }, 1000); }), Promise.reject(3)]) .then(function(values){ console.log(values); }); Promise.all([]).then(fn)只有当所有的异步任务执行完成之后，才会执行then。 接着看一个Promise.race的示例： Promise.race([new Promise(function(resolve, reject){ setTimeout(function(){ console.log(&apos;p1&apos;); resolve(1); }, 2000); }), new Promise(function(resolve, reject){ setTimeout(function(){ console.log(&apos;p2&apos;); resolve(2); }, 1000); })]) .then(function(value){ console.log(&apos;value = &apos; + value); }); 结果是： p2 value = 2 p1 Promise.race([]).then(fn)会同时执行所有的异步任务，但是只要完成一个异步任务，那么就调用then。 promise.catch(onRejected)是promise.then(undefined, onRejected) 的语法糖。 更多关于Promise的资料请参考：https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise 第三方Promise库有许多，如：Q, when.js 等"},{"title":"编写高质量JS代码的68个有效方法（十二）","permalink":"http://hstarorg.github.io/blog/blog/2015/03/04/编写高质量JS代码的68个有效方法-读书笔记/[20150304]编写高质量JS代码的68个有效方法（十二）/","text":"##No.56、避免不必要的状态Tips： 尽可能地使用无状态的API 如果API是有状态的，标示出每个操作与哪些状态有关联 无状态的API简洁，更容易学习和使用，也不需要考虑其他的状态。如： &apos;test&apos;.toUpperCase(); // &apos;TEST&apos; 有状态的API往往会导致额外的声明，并增加复杂度。 ##No.57、使用结构类型设计灵活的接口Tips： 使用结构类型（也称为鸭子类型）来设计灵活的对象接口 结构接口更灵活、更轻量，所以应该避免使用继承 针对单元测试，使用mock对象即接口的替代实现来提供可复验的行为 直接上代码： function Wiki(format){ this.format = format; } Wiki.prototype.show = function(source){ var page = this.format(source); return { title: page.getTitle(), author: page.getAuthor(), content: page.getContent() } } 将format设计为结构类型，可以极大的增加设计的灵活性。 ##No.58、区分数组对象和类数组对象Tips： 绝不重载与其他类型有重叠的结构类型 当重载一个结构类型与其他类型时，先测试其他类型 当重载其他对象类型时，接收真数组而不是类数组对象 API绝不应该重载与其他类型有重叠的类型 最简单的判断数组与类数组，代码如下： x instanceof Array 但是，在一些允许多个全局对象的环境中可能会有标准的Array构造函数和原型对象的多份副本。那么就有可能导致以上的测试结果不可信，所以在ES5引入了Array.isArray函数来判断是否是Array对象，通过检查对象内部[[Class]]属性值是否为Array来判定。在不支持ES5的环境中，可以使用标准的Object.prototype.toString方法测试一个对象是否为数组。 function isArray(x){ return toString.call(x) === &apos;[object Array]&apos;; } ##No.59、避免过度的强制转换Tips： 避免强制转换和重载的混用 考虑防御性地监视非预期的输入 看以下的函数： function square(x){ return x*x; } console.log(square(&apos;3&apos;)); // 9 强制转换无疑是很方便的。但很多时候却会导致含糊不清。 function fun(x){ x = Number(x); if(typeof x === &apos;number&apos;){ return x-1; }else{ return x; } } 由于进行了Number(x)，那么后面的else是无法执行到的。如果不知道这个函数的细节，那么使用该函数则具有一定的模糊性。事实上，如果我们要更小心的设计API，我们可以强制只接受数字和对象。 function fun(x){ if(typeof x === &apos;number&apos;){ return x-1; }else if(typeof x === &apos;object&apos; &amp;&amp; x){ return x; }else{ throw new TypeError(&apos;expected number or array-like.&apos;); } } 这种风格更加谨慎的示例，被称为防御性编程。 ##No.60、支持方法链Tips： 使用方法链来连接无状态的操作 通过在无状态的方法中返回新对象来支持方法链 通过在有状态的方法中返回this来支持方法链 无状态的API部分能力是讲复杂操作分解为更小的操作。如replace： function escapeHtml(str){ return str.replace(/&amp;/g, &apos;&amp;amp;&apos;) .replace(/&lt;/g, &apos;&amp;lt;&apos;); } 如果不采用方法链方式，代码应该是以下这样： function escapeHtml(str){ var str1 = str.replace(/&amp;/g, &apos;&amp;amp;&apos;); var str2 = str1.replace(/&lt;/g, &apos;&amp;lt;&apos;); return str2; } 同样的功能，将会产生多个临时变量。消除临时变量使得代码更加可读，中间结果只是得到最终结果中的一个重要步骤而已。 在有状态的API中设置方法链也是可行的。技巧是方法在更新对象时返回this，而不是undefined。如： element.setBackgroundColor(&apos;gray&apos;) .setColor(&apos;red&apos;) .setFontweight(&apos;bold&apos;);"},{"title":"编写高质量JS代码的68个有效方法（十一）","permalink":"http://hstarorg.github.io/blog/blog/2015/02/14/编写高质量JS代码的68个有效方法-读书笔记/[20150214]编写高质量JS代码的68个有效方法（十一）/","text":"##No.51、在类数组对象上附庸通用的数组方法Tips: 对于类数组对象，通过提取方法对象并使用其call方法来复用通用的Array方法 任意一个具有索引属性和恰当length属性的对象都可以使用通用的Array方法 Array.proteotype中的标准方法被设计成其他对象可复用的方法，即使这些对象没有继承Array。很实际的一个例子就是 arguments ,示例如下： //define function fun(){ console.log(arguments); // [1, 2, 3] console.log(arguments instanceof Array) // false arguments.forEach(function(argv){ //TypeError console.log(argv) }); } //call fun(1, 2, 3); 从结果来看，输出arguments和数组非常相似，通过instanceof来看，确实不是数组，所以arguments是类数组对象，但是在执行forEach的时候却TypeError。why？ 因为 arguments 没有继承Array.prototype,所以并不能直接调用forEach方法，但是可以提取forEach方法的引用并使用其call来调用，代码如下： //define function fun(){ [].forEach.call(arguments, function(argv){ console.log(argv); }); } //call fun(1, 2, 3); 除了arguments之外，dom的NodeList也是类数组对象： var nodes = document.getElementsByTagName(&apos;a&apos;); console.log(nodes); console.log(nodes instanceof Array); // false 那么，到底怎样使得一个对象“看起来像数组”呢？有以下两个规则： 具有一个范围在0到2^32 - 1 的整型length属性 length属性大于该对象的最大索引。索引是一个范围在0到2^32 -2 的整数，它的字符串表示的是该对象的一个key。 鉴于以上规则，那么我们可以自己创建类数组对象： var arrayLike = {0: &apos;a&apos;, 1: &apos;b&apos;, 2: &apos;c&apos;, length: 3}; var result = [].map.call(arrayLike, function(el){ return el.toUpperCase(); }); console.log(result); // [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;] 特例，数组连接方法concat不是完全通用的。因为它会检查对象的[[Class]]属性，要想连接类数组对象，我们就需要先将类数组处理为数组： var arrLike = {0: &apos;a&apos;, length: 1}; var arr = [].slice.call(arrLike); console.log([&apos;A&apos;].concat(arr)); // [&apos;A&apos;, &apos;a&apos;] ##No.52、数组字面量优于数组构造函数Tips: 如果数组构造函数的第一个参数是数字则数组的构造函数行为是不同的 使用数组字面量替代数组构造函数 原因如下： [] 比 new Array简洁 var arr = []; var arr = new Array(); 使用new Array()，必须要确保没有人重新包转过Array变量 funciton f(Array){ return new Array(1, 2, 3, 4, 5); } f(String); //new String(1) 使用new Array()，必须要确保没有人修改过全局的Array变量 Array = String new Array(1, 2, 3); // new String(1) 使用new Array时，由于第一个参数类型不同，会导致二义性 new Array(&apos;hello&apos;) 和 [&apos;hello&apos;] 等价 [1] 和 new Array(1) 不等价，前者创建包含元素的1的数组，后则创建长度为1的数组。 所以，优先使用字面量，因为数组字面量具有更规范、更一致的语义。 ##No.53、保持一致的约定Tips： 在变量命名和函数签名中使用一致的约定 不要偏离用户在他们的开发平台中很可能遇到的约定 有良好的编码习惯，使用业界常规的编码规范，同时注意参数的顺序等。一句话概述：保持代码的一致性。 ##No.54、将undefined看做“没有值”Tips： 避免使用undefined表示任何非特定值 使用描述性的字符串值或命名布尔属性的对象，而不要使用undefined 或 null来代表特定应用标志 提供参数默认值应该采用测试undefined的方式，而不是检查arguments.length。 在允许0、NaN或空字符串为有效参数的地方，绝不要通过真值测试来实现参数默认值。 undefined很特殊，当JavaScript无法提供具体的值时没救产生undefined。如只定义变量，不赋值；或者是对象中不存在属性；再者，函数无return语句都会产生undefined。 var x; console.log(x); //undefined var o = {}; console.log(o.p1); //undefined function fun(){ } console.log(fun()); //undefined 未给函数参数提供实参则该函数参数值为undefined function fun(x){ return x; } console.log(fun()); //undefined 将undefined看做缺少某个特定的值是公约。将它用于其他目的具有很高的风险： //假设highlight为设置元素高亮 element.highlight(&apos;yellow&apos;); //设置为黄色 //如果要设置为随机颜色 //方式一、如果遇到undefined则设置为随机 element.highlight(undefined); //这样的方式通常会产生歧义 element.highlight(config.highlightColor); //使用如上语句时，我们的期望一般是没有提供配置则使用默认色，但是由于undefined代表随机，那么破坏了这种常规思维。让代码变得难以理解。 //更好的做法 element.highlight(&apos;random&apos;); //或者是 element.highlight({random: true}); 另一个提防undefined的地方是可选参数的实现。 function fun(a, b){ if(arguments.length &lt; 2){ b = &apos;xx&apos;; } } 如果使用 fun(a);调用，基本符合预期；但是如果使用fun(a, ‘undefind’);则不会执行if之内的语句，导致结果错误，如果测试是否为undefined有助于打造更为健壮的API。 针对可选参数这个问题，另外一个合理的替代方案是： function fun(a, b){ b = b || &apos;xxx&apos;; } 但是要注意，真值测试并不总是安全的。如果一个函数应该接受空字符串，0，NaN为合法值，那么真值测试就不该使用了。 //Bad Use function Point(x, y){ this.x = x || 200; this.y = y || 200; } 以上代码有什么问题呢，因为使用 new Point(0, 0);会导致使用默认值，这样就偏离了预期。所以需要更严格的测试： function Point(x, y){ this.x = x === undefined ? 200 : x; this.y = y === undefined ? 200 : y; } ##No.55、接收关键字参数的选项对象Tips： 使用选项对象似的API更具可读性、更容易记忆 所有通过选项对象提供的参数应当被视为可选的 使用extend函数抽象出从选项对象中提取值的逻辑 首先来看一个复杂的函数调用： fun(200, 200, &apos;action&apos;, &apos;green&apos;, true); 一眼望去，完全不知所云。在体会到C#的可选参数的便利性的时候，肯定会想JavaScript要是有这样的用法就好了。 幸运的是，JavaScript提供了一个简单、轻量的惯用法：选项对象。基本达到了可选参数的效果。 fun({ width: 200, height: 200, action: &apos;action&apos;, color: &apos;green&apos;, ignoreError: true }); 相对来说，更繁琐一点，但是更易于阅读。另外一个好处就是，参数都是可选的。 如果有必选参数，那么在设计API的时候。建议将它们独立于选项之外，其他语言也可借鉴这种思路。 // options 为可选参数 function fun(width, height, options){ } 通过extend组合可选参数和默认参数，可以让函数变得简洁和健壮。 function fun(width, height, options){ var defaults = { color: &apos;green&apos;, ignoreError: false, action: &apos;&apos; } //$.extend 可以理解为jQuery的方法 options = $.extend({}, defaults, options); //do something... }"},{"title":"编写高质量JS代码的68个有效方法（十）","permalink":"http://hstarorg.github.io/blog/blog/2015/01/23/编写高质量JS代码的68个有效方法-读书笔记/[20150123]编写高质量JS代码的68个有效方法（十）/","text":"##No.46、使用数组而不要使用字典来存储有序集合Tips: 使用for…in 循环来枚举对象属性应当与顺序无关 如果聚集运算字典中的数据，确保聚集操作与顺序无关 使用数组而不是字典来存储有序集合 由于标准允许JavaScript引擎自由选择顺序，那么如果用字典存储有序数据，就会导致兼容性问题。 ##No.47、绝不要在Object.prototype中增加可枚举的属性Tips： 避免在Object.prototype中增加属性 考虑编写一个函数代理Object.prototype方法 如果你是在需要在prototype中增加属性，请使用ES5中的Object.defineProperty方法将它们定义为不可枚举的属性 for...in循环非常便利，但是容易受到原型污染。如果在Object.prorotype中增加可枚举属性的话，将会导致大多数for...in循环受到污染。 如果是在是要在Object.prototype上定义属性的话，可以使用如下代码： Object.defineProperty(Object.prototype, &apos;allKeys&apos;, { value: function(){ var arr = []; for(var key in this){ arr.push(key); } return arr; }, writable: true, enumerable: false, //设置属性为不可枚举 configurable: true }); 测试代码： var obj = {a: 1, b: 2}; console.log(obj.allKeys()); // [&apos;a&apos;, &apos;b&apos;] ##No.48、避免在枚举期间修改对象Tips： 当使用for...in 循环枚举一个对象的属性时，确保不要修改该对象 当迭代一个对象时，如果该对象的内容可能会在循环期间被改变，应该使用while循环或经典的for循环来代替for...in 为了在不断变化的数据结构中能够预测枚举，考虑使用一个有序的数据结构，例如数组，而不要使用字典 在大部分编译型语言中，如果在迭代时修改对象属性，是会出现编译错误的。在js中，没有这样的编译机制，但是也尽量保证不要修改迭代对象。 如果在被枚举时添加了新对象，并不一定能保证新添加的对象能被访问到： var obj = {a: 1, b: 2}; for(var p in obj){ console.log(p); obj[p + &apos;1&apos;] = obj[p] + 1; } 遇到这样的场景，应当使用while和标准的for循环。 ##No.49、数组迭代要优先使用for循环而不是for...in循环Tips: 迭代数组的索引属性应当总是使用for循环而不是for...in循环 考虑在循环之前将数组的长度存储在一个局部变量中以避免重新计算数组长度 猜测下面一段代码的结果？ var arr = [5, 6, 8, 10, 9]; var sum = 0; for(var a in arr){ sum += a; } console.log(sum); 要达到正确的结果，那么应该使用for循环 var arr = [5, 6, 8, 10, 9]; var sum = 0; for(var i = 0, len = arr.length; i &lt; len; i++){ sum += arr[i]; } console.log(sum); //38 再看一个比较极端的例子： var arr = [5, 6, 8, 10, 9]; arr.len = 4; for(var p in arr){ console.log(p); } 这个时候用for...in,完全是达不到预期效果的 再来看一个对于数组长度缓存的测试代码： var count = 0; console.time(&apos;t1&apos;); while(count &lt; 10000){ var arr = [5, 6, 8, 10, 9]; var sum = 0; count++; for(var i = 0, len = arr.length; i &lt; len; i++){ sum += arr[i]; } } console.timeEnd(&apos;t1&apos;); count = 0; console.time(&apos;t2&apos;); while(count &lt; 10000){ var arr = [5, 6, 8, 10, 9]; var sum = 0; count++; for(var i = 0; i &lt; arr.length; i++){ sum += arr[i]; } } console.timeEnd(&apos;t2&apos;); 结果，请自行复制代码执行。。。 ##No.50、迭代方法优于循环Tips： 使用迭代方法（如Array.prototype.forEach和Array.prototype.map）替换for循环使得代码更可读，并且避免了重复循环控制逻辑 使用自定义的迭代函数来抽象未被标准库支持的常见循环模式 在需要提前终止循环的情况下，仍然推荐使用传统的循环。另外some和every方法也可用于提前退出 在使用循环的时候，在确定循环的终止条件时容易引入一些简单的错误： for(var i = 0; i &lt;= n; i++){} for(var i = 1; i&lt; n; i++){} 比较庆幸的是，闭包是一种为这些模式建立迭代抽象方便的、富有表现力的手法。 我们可以用以下代码来代替： var arr = [1, 2, 3]; arr.forEach(function(v, i){ console.log(v); }); 如果要创建新数组，那么可以用以下方式： var arr = [1, 2, 3]; var arrNew = []; //方式一 arr.forEach(function(v, i){ arrNew.push(v); }); //方式二 for(var i = 0, len = arr.length; i &lt; len; i++){ arrNew.push(arr[i]); } 为了简化这种普遍操作，ES5中引入了Array.prototype.map方法： var arr = [1, 2, 3]; var arrNew = arr.map(function(v){ return v; }); 同样，如果想提取满足条件的元素，ES5也提供了filter方法： var arr = [1, 2, 3]; var arrNew = arr.filter(function(v){ return v &gt; 1; }); console.log(arrNew); 在ES5中，针对数组也提供了some和every ,可以用来终止循环，但是实际意义等同于C#的Linq方法All和Any： var arr = [1, 2, 3]; //数组元素有一个&gt;1就返回true，并终止循环 var b = arr.some(function(a){ return a&gt;1; }); console.log(b); //true //数组元素每个都&lt;3，则返回true，否则返回false，并提前终止循环 b = arr.every(function(a){ return a&lt;3; }); console.log(b); //false"},{"title":"编写高质量JS代码的68个有效方法（九）","permalink":"http://hstarorg.github.io/blog/blog/2015/01/10/编写高质量JS代码的68个有效方法-读书笔记/[20150110]编写高质量JS代码的68个有效方法（九）/","text":"##No.41、将原型视为实现细节Tips： 对象是接口，原型是实现 避免检查你无法控制的对象的原型结构 避免检查实现在你无法控制的对象内部的属性 我们可以获取对象的属性值和调用其方法，这些操作都不是特别在意属性存储在原型继承结构的哪个位置。只要其属性值保存很定，那么这些操作的行为也不变。简言之，原型是一种对象行为的实现细节。 正是由于以上的特性，所以如果修改了实现细节，那么依赖于这些对象的使用者就会被破坏，而且还很难诊断这类bug。所以一般来说，对于使用者，最好不要干涉那些属性。 ##No.42、避免使用轻率的猴子补丁Tips： 避免使用轻率的猴子补丁 记录程序库所执行的所有猴子补丁 考虑通过将修改设置于一个导出函数中，使猴子补丁成为可选的 使用猴子补丁为缺失的标准API提供polyfills 何为猴子补丁？ 由于对象共享原型，因为每一个对象都可以增加、删除或修改原型的属性。这个有争议的实践通常被称为猴子补丁。 猴子补丁的吸引力在于它的强大，如果数组缺少一个有用的方法，那么我们可以自己扩展它。但是在多个库同时对数组进行不兼容扩展时，问题就来了，有可能调用方法之后的结果和预期不一致。 危险的猴子补丁有一个特别可靠而且有价值的使用场景：polyfill。补齐标准所支持的方法。 ##No.43、使用Object的直接实例构造轻量级的字典Tips: 使用对象字面量构建轻量级字典 轻量级字典应该是Object.prototype的直接子类，以使for…in循环免受原型污染 JavaScript对象的核心是一个字符串属性名称与属性值的映射表。 var dict = { key1: &apos;value1&apos;, key2: &apos;value2&apos; }; for(var key in dict){ console.log(&apos;key=&apos;+ key + &apos;,value=&apos; + dict[key]); } 在使用for…in时，要小心原型污染。 function Dict(){ Dict.prototype.count = function(){ var c = 0; for(var p in this){ c++; } return c; } } var dict = new Dict(); dict.name = &apos;jay&apos;; console.log(dict.count()); //结果是2，因为for...in会枚举出所有的属性，包括原型上的。 所有人都不应当增加属性到Object.prototype上，因为这样做可能会污染for…in循环，那么我们通过使用Object的直接实例，可以将风险仅仅局限于Object.prototype。 ##No.44、使用null原型以防止原型污染Tips： 在ES5中，使用Object.create(null)创建的自由原型的空对象是不太容易被污染的 在一些较老的环境中，考虑使用{proto: null} 要注意__proto__既不标准，也不是完全可移植的，并且可能会在未来的JavaScript环境中去除 绝不要使用__proto__名作为字典的key，因为一些环境将其作为特殊的属性对待 对构造函数的原型属性设置null或者是undefined是无效的： function Dict(){ } Dict.prototype = null; var dict = new Dict(); console.log(Object.getPrototypeOf(dict) === null); // false console.log(Object.getPrototypeOf(dict) === Object.prototype); //true 在ES5中，提供了标准方法来创建一个没有原型的对象： var dict = Object.create(null); console.log(Object.getPrototypeOf(dict) === null); // true 在不支持Object.create函数的旧的JS环境中，可以使用如下方式创建没有原型的对象： var dict = {__proto__: null} console.log(Object.getPrototypeOf(dict) === null); // true 注意：在支持Object.create函数的环境中，尽可能的坚持使用标准的Object.create函数 ##No.45、使用hasOwnProperty方法来避免原型污染Tips： 使用hasOwnProperty方法避免原型污染 使用词法作用域和call方法避免覆盖hasOwnProperty方法 考虑在封装hasOwnProperty测试样板代码的类中实现字典操作 使用字典类避免将__proto__作为key来使用 即使是一个空的对象字面量也继承了Object.prototype的大量属性： var dict = {} console.log(&apos;a&apos; in dict); // false console.log(&apos;toString&apos; in dict); // true console.log(&apos;valueOf&apos; in dict); // true 不过，Object.prototype提供了方法来测试字典条目： var dict = {} console.log(dict.hasOwnProperty(&apos;a&apos;)); // false console.log(dict.hasOwnProperty(&apos;toString&apos;)); // false console.log(dict.hasOwnProperty(&apos;valueOf&apos;)); // false 但是，如果在字典中存储一个同为“hasOwnProperty”的属性，那么： var dict = { hasOwnProperty: null } console.log(dict.hasOwnProperty(&apos;a&apos;)); // TypeError 最安全的方法则是使用call： var dict = { hasOwnProperty: null } console.log({}.hasOwnProperty.call(dict, &apos;hasOwnProperty&apos;)); // true、 最后，我们来看一个复杂的但更安全的字典类： function Dict(elements){ this.elements = elements || {}; this.hasSpecialProto = false; this.specialProto = undefined; } Dict.prototype.has = function(key){ if(key === &apos;__proto__&apos;){ return this.hasSpecialProto; } return {}.hasOwnProperty.call(this.elements, key); }; Dict.prototype.get = function(key){ if(key === &apos;__proto__&apos;){ return this.specialProto; } return this.has(key) ? this.elements[key] : undefined; }; Dict.prototype.set = function(key, value){ if(key === &apos;__proto__&apos;){ this.hasSpecialProto = true; this.specialProto = value; }else{ this.elements[key] = value; } }; Dict.prototype.remove = function(key){ if(key === &apos;__proto__&apos;){ this.hasSpecialProto = false; this.specialProto = undefined; }else{ delete this.elements[key]; } }; // 测试代码 var dict = new Dict(); console.log(dict.has(&apos;__proto__&apos;)); // false"},{"title":"Web离线存储的几种方式","permalink":"http://hstarorg.github.io/blog/blog/2015/01/07/前端相关/[20150107]Web离线存储的几种方式/","text":"随着HTML5的正式定稿，我们也可以大量使用HTML离线网络应用程序的特性。 #1、Application CacheApplication Cache 可以很简单让我们的WebApp具有离线的能力。 支持的浏览器：IE10+，FireFox，Chrome，Safari，Opera 优点： 离线浏览 – 用户可以再离线时使用Application 速度 – 由于缓存了资源，如果加载很快 减少服务端数据加载 – 浏览器只需要从服务器加载更新过的数据 缺点： Manifest文件有变化时才更新 一次必须更新Manifest中的所有文件，下次才生效 如何使用？ Step1:在html上指定manifest文件 (index.html) &lt;html manifest=&quot;appCacheList.manifest&quot;&gt; &lt;/html&gt; Step2:设定manifest文件内容 (appCache.manifest) CACHE MANIFEST # 离线缓存的内容 ./all.css ./1.jpg ./index.js # NETWORK:*，表示其他内容从网络获取 NETWORK: * # 第一个uri是资源，第二个是fallback FALLBACK: /html/ /offline.html 手动更新缓存： if ( window.applicationCache.status == window.applicationCache.UPDATEREADY ){ window.applicationCache.update(); } 注意： 不同的浏览器对Application Cache的大小不一致，请注意。 更多细节可参考http://kayosite.com/web-app-by-jquery-mobile-and-html5-offline-web-applications.html #2、Local StorageLocal Storage使得我们可以在浏览器中保存数据。 支持的浏览器：IE10+，FireFox，Chrome，Safari，Opera 优点： 容量大 易用 强大 原生支持 仅存在本地，不会与服务器发生交互 缺点： 浏览器兼容性差 安全性差（不要存储敏感数据） 如何使用？ 首先通过 window.localStorage 来判断浏览器是否支持Local Storage。然后由于该方式具有浏览器兼容性，建议用一个通用的库，来屏蔽兼容性。 // 对基本方法的封装，需要判断浏览器，屏蔽它们的细节差异。 (function(window){ if(!window.localStorage){ throw new Error(&apos;Your brower can\\&apos;t support local storage!&apos;); } var ls = window.localStorage; var localStorageKit = { getLength: function(){ return ls.length; }, clear: function(){ ls.clear(); return true; }, set: function(k, v){ ls.setItem(k, v); }, get: function(k){ return ls.getItem(k); }, remove: function(k){ ls.removeItem(k); }, getKeyByIndex: function(index){ return ls.key(index); } }; window.lsKit = localStorageKit; })(window); 基本操作方式与cookie无太多差异。 Session Storage：Session Storage和Local Storage非常类似，操作方式也一致。由于其中保存的存只是当前会话有效，那么此处就不细说。 #3、Web SQLWeb Sql Database，是html5环境下可以用js执行CRUD的web数据库。数据库核心是SQLite。 优点： 本地数据库 可以处理复杂的关系型数据 缺点： 暂时只有chrome才支持，对于Android大行其道的移动端，这应该是可以避免的缺点(貌似最新版本的Opera和Safari也支持了) 如何使用？ 首先，先介绍Web sql的三个核心方法： openDatabase：这个方法使用现有数据库或创建新数据库创建数据库对象。 transaction：这个方法允许我们根据情况控制事务提交或回滚。 executeSql：这个方法用于执行真实的SQL查询。 var db = openDatabase(‘mydb’, ‘1.0’, ‘Test DB’, 2 1024 1024); var msg; db.transaction(function (tx) { tx.executeSql(‘CREATE TABLE IF NOT EXISTS LOGS (id unique, log)’); tx.executeSql(‘INSERT INTO LOGS (id, log) VALUES (1, “foobar”)’); tx.executeSql(‘INSERT INTO LOGS (id, log) VALUES (2, “logmsg”)’); console.log(‘Log message created and row inserted.’); }); db.transaction(function (tx) { tx.executeSql(‘SELECT * FROM LOGS’, [], function (tx, results) { var len = results.rows.length, i; console.log(&apos;Found rows: &apos; + len); for (i = 0; i &lt; len; i++){ console.log(results.rows.item(i).log) } }, null); }); 当成数据库用，就行。 #4、IndexedDBIndexedDB是结构化的本地数据存储。是基于平面文件的数据库，采用了分层的键值存储和基本的索引。 优点： 标准化 存储复杂数据 支持索引 缺点： 不支持SQL 相对来说，操作较复杂 如何使用？ // 打开数据库，第一个参数为数据库名，第二个为数据库版本号 var dbRequest = window.indexedDB.open(&apos;testDb&apos;, 2); dbRequest.onupgradeneeded=function(e){ // 创建数据仓库 var db=e.target.result; if(!db.objectStoreNames.contains(&apos;users&apos;)){ var store=db.createObjectStore(&apos;users&apos;,{keyPath: &apos;id&apos;}); store.createIndex(&apos;nameIndex&apos;,&apos;name&apos;,{unique:true}); store.createIndex(&apos;ageIndex&apos;,&apos;age&apos;,{unique:false}); } console.log(&apos;upgrade successfully!&apos;); }; dbRequest.onsuccess = function(e){ console.log(&apos;Open database successfully!&apos;); // 这里拿到了数据库 var db = e.target.result; var storeName = &apos;users&apos;; // 写入数据 var tran = db.transaction(storeName, &apos;readwrite&apos;); var users = tran.objectStore(storeName); for(var i = 0; i &lt; 5; i++){ users.add({ id: i, name: &apos;user&apos; + i, age: Math.floor(Math.random() * 10) + 18 }); } //查询数据 var userStore = db.transaction(storeName).objectStore(storeName); var request = userStore.openCursor(); request.onsuccess = function(e){ var cursor = e.target.result; if(cursor){ console.log(cursor.key); console.log(cursor.value); cursor.continue(); } } } 其他HTML 5中几种用于在客户端本地存储数据的API之间的比较 HTML5本地存储——IndexedDB（一：基本使用） HTML5本地存储——IndexedDB（二：索引）"},{"title":"编写高质量JS代码的68个有效方法（八）","permalink":"http://hstarorg.github.io/blog/blog/2014/12/27/编写高质量JS代码的68个有效方法-读书笔记/[20141227]编写高质量JS代码的68个有效方法（八）/","text":"##NO.36、只将实例状态存储在实例对象中Tips： 共享可变数据可能会出问题，因为原型是被其所有的实例共享的 将可变的实例存储在实例对象中 一般来说，由于原型属性指向的对象是所有实例共享的。所以不建议在原型指向的对象中存储共享数据。下面给一个简单的例子： var Person = function(name){ this.name = name; }; Person.prototype = { children: [], addChild: function(childName){ this.children.push(childName); }, getChildren: function(){ return this.children; } }; var p1 = new Person(&apos;P1&apos;); var p2 = new Person(&apos;P2&apos;); p2.addChild(&apos;P2_C1&apos;); console.log(p1.getChildren()); 结果比较明显。p2的孩子成p1的了。标准做法是将children存储在实例对象中。 var Person = function(name){ this.name = name; this.children = []; }; Person.prototype = { addChild: function(childName){ this.children.push(childName); }, getChildren: function(){ return this.children; } }; ##No.37、认识到this变量的隐式绑定问题Tips： this变量的作用域总是有其最近的封闭函数所确定 使用一个局部变量（通常命名为self,me,that）使得this的绑定对于内部函数是可用的。 老规矩，看一个简单的示例： var testObj = { a1: 0, fun1: function(){ function fun2(){ console.log(this.a1); } fun2(); } }; testObj.fun1(); 为什么会这样呢？因为this变量是以不同的方式被绑定的。每个函数都有一个this变量的隐式绑定。this变量是隐式的绑定到最近的封闭函数。针对以上的问题，可以有集中方法来处理，参考如下： //通过将this用变量self保存的方式实现 var testObj = { a1: 0, fun1: function(){ var self = this; function fun2(){ console.log(self.a1); } fun2(); } }; testObj.fun1(); //通过call方法指定接收者（也可以用apply） var testObj = { a1: 0, fun1: function(){ function fun2(){ console.log(this.a1); } fun2.call(this); } }; testObj.fun1(); //通过bind来实现 var testObj = { a1: 1, fun1: function(){ function fun2(){ console.log(this.a1); } fun2.bind(this)(); } }; testObj.fun1(); ##No.38、在子类的构造函数中调用父类的构造函数Tips： 在子类构造函数中显式地传入this作为显式的接收者调用父类的构造函数 使用Object.create函数来构造子类的原型对象以避免调用父类的构造 JS中实现的继承： var Animal = function(){ this.weight = 50; }; Animal.prototype.eat = function(){ console.log(&apos;eat food...&apos;); }; var Dog = function(){ Animal.call(this); Dog.prototype = Object.create(Animal.prototype); }; var dog = new Dog(); console.log(dog.weight); ##No.39、不要重用父类的属性名Tips： 留意父类使用的所有属性名 不要再子类中重用父类的属性名 由于JS中，属性都是key-value存储，那么同名的属性指向同样的地址，所以以下代码： var Animal = function(){ this.weight = 50; this.id = ++Animal.nextId; }; Animal.nextId = 0; Animal.prototype.eat = function(){ console.log(&apos;eat food...&apos;); }; var Dog = function(){ Animal.call(this); this.id = ++ Dog.nextId; Dog.prototype = Object.create(Animal.prototype); }; Dog.nextId = 0; var dog = new Dog(); console.log(dog.id); 两个类都试图给实例属性id写数据。 ##No.40、避免继承标准类Tips： 继承标准类往往会由于一些特殊的内部属性（如[[Class]]）而被破坏 使用属性委托优于继承标准类 扩展标注库使得其功能更强大是很有诱惑力的，但不幸的是它们的定义具有很多特殊的行为，所以很难写出正确的子类。 var ArrayEx = function(){ for(var i = 0, len = arguments.length; i&lt;len ; i++){ this[i] = arguments[i]; } }; ArrayEx.prototype = Object.create(Array.prototype); var ar = new ArrayEx(&apos;1&apos;, &apos;2&apos;); console.log(ar.length) //猜猜结果是什么？ 原因分析：length属性只对在内部标记为“真正的”数组对象才起作用。直接继承的对象并没有继承Array的标记标签属性[[Class]]。测试如下： var ar = new ArrayEx(&apos;1&apos;, &apos;2&apos;); console.log(Object.prototype.toString.call(ar)); //[object Object] console.log(Object.prototype.toString.call([])); //[object Array] ECMAScript标准库中干掉大多数构造函数都有类似的问题。基于这个原因，最好避免继承一下的标准类：Array,Boolean,Date,Function,Number,RegExp或String。 要想实现类似的功能，可以采用属性委托的方式： var ArrayEx = function(){ this.array = [] for(var i = 0, len = arguments.length; i&lt;len ; i++){ this.array[i] = arguments[i]; } }; ArrayEx.prototype.forEach = function(f, thisArg){ if(typeof thisArg === &apos;undefined&apos;){ thisArg = this; } this.array.forEach(f, thisArg); }; var ar = new ArrayEx(&apos;1sfdfsd&apos;, &apos;2fdsfs&apos;); ar.forEach(function(item, i){ console.log(item); });"},{"title":"编写高质量JS代码的68个有效方法（七）","permalink":"http://hstarorg.github.io/blog/blog/2014/12/20/编写高质量JS代码的68个有效方法-读书笔记/[20141220]编写高质量JS代码的68个有效方法（七）/","text":"##No.30、理解prototype、getPrototypeOf和proto之间的不同Tips： C.prototype属性是new C() 创建的对象的原型 Object.getPrototypeOf(obj)是ES5中检索对象原型的标准函数 obj. proto是检索对象原型的非标准方法 类是由一个构造函数和一个关联的原型组成的一种设计模式 简单点说，就是prototype属性直接是创建的对象的原型；getPrototypeOf()是一个标准函数，来获取对象原型；而 proto则是不标准的原型属性。 //定义一个类型 function User(name, age){ this.name = name; this.age = age; } //实例化类型 var user = new User(&apos;Jay&apos;, 23); //原型属性prototype作用在类对象上 User.prototype //非标准__proto__作用在对象实例上 user.__proto__ //getPrototypeOf则是Object的一个方法，参数为实例对象 Object.getPrototypeOf(user) Object.getPrototypeOf(user) === User.prototype; // true User.prototype === user.__proto__; // true ##No.31、使用Object.getPrototypeOf()函数而不要使用 proto属性Tips： 使用符合标准的Object.getPrototypeOf()函数而不要使用非标准的 proto属性 在支持 proto属性的非ES5环境中实现Object.getPrototypeOf()函数 由于非标准属性不具有完全兼容性，所以容易出一些奇奇怪怪的问题，不建议使用。在支持 proto的非ES5标准环境下，使用下面代码来实现Object.getPrototypeOf()函数： if(typeof Object.getPrototypeOf === &apos;undefined&apos;){ Object.getPrototypeOf = function(obj){ var t = typeof obj; if(!obj || (t !== &apos;object&apos; &amp;&amp; t !== &apos;function&apos;)){ throw new TypeError(&apos;Not an object.&apos;); } return obj.__proto__; } } ##No.32、始终不要修改 proto属性Tips： 始终不要修改 proto属性 使用Object.create函数给对象设置自定义原型 proto很特殊，具有修改对象原型链的能力。修改了 proto属性可能会造成以下几个问题： 可移植性问题。并不是所有平台都支持改变对象原型的特性 性能问题。会使得引擎对JS代码的优化失效 行为不可预测。修改了 proto可能会破坏原有的继承体系 ##No.33、使构造函数和new操作符无关Tips： 通过使用new操作符或Object.create方法在构造函数中调用自身使得该构造函数与调用语法无关 当一个函数期望使用new操作符调用时，清晰地文档化该函数 同31，我们来看一下User对象： function User(name, age){ this.name = name; this.age = age; } //如果使用new，那么会创建全新对象 var user = new User(&apos;Jay&apos;, 23); //如果忘记使用new呢？ var user = User(&apos;Jay&apos;, 23) //这个时候，该句代码，相当于调用函数，此时this在一般情况下是window，在ES5严格模式下是undefined。 //当是window的时候，则会污染全局变量name和age，造成无法预期的问题。 //当是undefined的时候，则会直接导致一个即时错误。 //由于User没有显式return，导致等号左边的user的值为undefined。 为了避免以上问题，可能使用以下两种方式： //方式一： //通过在函数体判断，然后调用自身的方式来实现，一定会使用new。缺点是它需要额外的函数调用，对性能有影响。 function User(name, age){ if(!(this instanceof User)){ return new User(name, age); } this.name = name; this.age = age; } //方式二： //通过判断this，将正确的接收者赋值给self，其他函数体内需要用this的地方，全部用self代替。缺点是使用了再ES5环境中有效的Object.create()。 function User(name, age){ var self = this instaceof User ? this : Object.create(User.prototype); self.name = name; self.age =age; } //方式二补充，由于Object.create()只在ES5中生效，为了在旧环境中使用的话，可以使用以下方式扩充Object.create()。 if(typeof Object.create === &apos;undefined&apos;){ Object.create = function(prototype){ function C(){} C.prototype = prototype; return new C(); } } ##No.34、在原型中存储方法Tips： 将方法存储在实例对象中将创建该函数的多个副本，因为每个实例都有一份副本 将方法存储于原型中优于存储在实例对象中 将方法存储在原型上，那么多个实例对象会共享该原型方法。如果存储在实例上的，每创建一个实例则会创建一个函数副本，会占用更多的内存。 ##No.35、使用闭包存储私有数据Tips： 闭包变量是私有的，只能通过局部引用获取 将局部变量作为私有数据从而通过方法实现信息隐藏 不多说，直接上代码： function User(name, age){ // 私有对象 var privateObj = { name: name, age: age, sex: &apos;男&apos; } // 公开属性 return { name: privateObj.name, age: privateObj.age, setAge: function(age){ privateObj.age = age; } } } var user = new User(&apos;Jay&apos;, 23); console.log(user.name); // &apos;Jay&apos; console.log(user.age); // 23 console.log(user.sex); // undefined user.setAge(25); console.log(user.age); // 23 思考：为什么最后一个user.age 是 23？？？ 修改如下呢： function User(name, age){ // 私有对象 var privateObj = { name: name, age: age, sex: &apos;男&apos; } // 公开属性 return { name: privateObj.name, age: function(){ return privateObj.age; } setAge: function(age){ privateObj.age = age; } } }"},{"title":"编写高质量JS代码的68个有效方法（六）","permalink":"http://hstarorg.github.io/blog/blog/2014/12/13/编写高质量JS代码的68个有效方法-读书笔记/[20141213]编写高质量JS代码的68个有效方法（六）/","text":"##No.26、使用bind方法实现函数柯里化Tips： 使用bind方法实现函数柯里化，即创建一个固定需求参数子集的委托函数 传入null或undefined作为接收者的参数来实现函数柯里化，从而忽略其接收者 什么是函数柯里化？ 将函数与其参数的一个子集绑定的技术称为函数柯里化，它是一种简洁的、使用更少引用来实现函数委托的方式。 //有一个组装URL的JS函数 function bulidURL(protocol, domain, path){ return protocol + &apos;://&apos; + domain + &apos;/&apos; + path; } //需要一个path数组转换为url数组，那么一般做法是： var urls = paths.map(function(path){ return bulidURL(&apos;http&apos;, &apos;www.hstar.org&apos;, path); }); 如果用bind实现函数柯里化，则是： var buildURL2 = buildURL.bind(null, &apos;http&apos;, &apos;www.hstar.org&apos;); var urls = paths.map(buildURL2); 其中由于buildURL不引用this，那么在bind中使用null，忽略函数本身的接收者，然后用bind实现柯里化。 使用buildURL.bind的参数+buildURL2的参数结合起来调用buildURL方法。 可以在bulidURL中写console(arguments)来查看参数合集。 ##No.27、使用闭包而不是字符串来封装代码Tips： 当将字符串传递给eval函数以执行它们的API时，绝不要在字符串中包含局部变量引用 接受函数调用的API优于使用eval函数执行字符串的API JS中，函数是一个将代码作为数据结构存储的便利方式，这些代码可以后面被执行。所以可以在JS中编写富有表现力的高阶函数，如map，forEach。 比较不好的设计，使用eval函数执行字符串。 //定义一个函数，使用eval执行字符串 function fun1(code){ eval(code); } //用法一： var val = 0; fun1(&apos;console.log(val)&apos;); //用法二： function fun2(){ var val = 1; fun1(&apos;console.log(val)&apos;); } fun2(); //Error:val is not defined 警告：在使用eval的时候，作用域是全局作用域（window），如用法一的调用，刚好能够出正常结果；如果转移到函数体内，如用法二的调用，则会出现错误；最坏的情况是用法二调用时，全局作用域上刚好有个同名的变量（本例中为val），那么将会让结果无法预期。 好的做法，就是直接传递函数 function fun1(){ } function fun2(p, action){ if(p === 1){ action(); } } fun2(); ##No.28、不要依赖函数对象的toString方法Tips： 调用函数的toString方法时，并没有要求JavaScript引擎能够精确的获取到函数的源代码 由于在不同的引擎下调用toString方法的结果可能不同，所以绝不要信赖函数源代码的详细细节 toString方法的执行结果并不会暴露存储在闭包中的局部变量值 通常情况下，应该避免使用函数对象的toString方法 JavaScript函数有一个非凡的特性，即将其源代码重现为字符串的能力。但是ECMAScript标准对toString返回的字符串没有任何要求，所以不同引擎产生的结果可能不同。甚至返回到字符串和该函数并不相关 ##No.29、避免使用非标准的栈检查属性Tips： 避免使用非标准的arguments.caller和arguments.callee属性，因为它们不具备良好的移植性 避免使用非标准的函数对象caller属性，因为在包含全部栈信息方面，它是不可靠的 基本错误（不推荐使用） function getCallStack(){ var stack = []; for(var f = getCallStack.caller; f; f = f.caller){ stack.push(f); } return stack; } 警告：该函数非常脆弱，如果某函数叜调用栈中出现了不止一次，那么栈检查会陷入死循环。同时使用caller在ES5的严格模式下会error。"},{"title":"编写高质量JS代码的68个有效方法（五）","permalink":"http://hstarorg.github.io/blog/blog/2014/12/05/编写高质量JS代码的68个有效方法-读书笔记/[20141205]编写高质量JS代码的68个有效方法（五）/","text":"##No.21、使用apply方法通过不同数量的参数调用函数Tips： 使用apply方法自定一个可计算的参数数组来调用可变参数的函数 使用apply方法的第一个参数给可变参数的方法提供一个接收者 //示例：计算给定数据的最大值 function getMaxNum(){ var max = arguments[0]; for(var i = 1, len = arguments.length;i &lt; len; i++){ if(max &lt; arguments[i]){ max = arguments[i]; } } return max; } getMaxNum.apply(null,[1,3,4]); 该方法和call()方法功能基本类似，差别在于参数写法不一样。 ##No.22、使用arguments创建可变参数的函数Tips: 使用隐式的arguments对象实现可变参数的函数 考虑对可变参数的函数提供一个额外的固定元数的版本，从而使用者无需借助apply方法。 每一个函数内部都有一个arguments对象包含所有传递的参数 function fun1(){ console.log(arguments); } fun1(&apos;1&apos;); fun1(1,&apos;2&apos;,&apos;str&apos;); ##No.23、永远不要修改arguments的值Tips： 永远不要修改arguments的值 使用[].slice.call(arguments)将arguments对象赋值到一个真正的数组中再进行修改 arguments看起来像是数组，但是它并不是标准的数组，所以不支持数组的原型方法 function fun1(nums){ var lastParam = arguments.pop(); //报错，undefined is not a function。 console.log(arguments); } fun1([1, 2, 3]); 正确的做法是，将arguments转换为真正的数组，再进行操作，代码如下： function fun1(nums){ var argArr = [].slice.call(arguments); var lastParam = argArr.pop(); console.log(arguments); } fun1([1, 2, 3]); 注意：永远不要修改arguments对象是更为安全的。 ##No.24、使用变量保存arguments的引用Tips： 当引用arguments时当心函数嵌套层级 绑定一个明确作用域的引用到arguments变量，从而可以再嵌套的函数中引用它 首先，先来看一段代码的输出： function fun1(){ var i = 0; console.log(arguments); return { next:function(){ return arguments[i++]; } } } var f = fun1(1,2,3,4); console.log(f.next()); //猜猜是啥？ arguments是函数中的隐式变量，每个函数都会有这样的一个隐式对象。所以最后一个console的结果可想而知。所以遇到这种场景，是建议用变量保存arguments的引用，也能让嵌套函数正确的进行对象引用，正确代码如下： function fun1(){ var i = 0; var args = arguments; return { next:function(){ return args[i++]; } } } var f = fun1(1,2,3,4); console.log(f.next()); ##No.25、使用bind方法提取具有确定接收者的方法Tips： 要注意，提取一个方法不会将方法的接收者绑定到该方法的对象上 当给高阶函数传递对象方法时，使用匿名函数在适当的接收者上调用该方法 使用bind方法创建绑定到适当接收者的函数 老规矩，看代码：（代码1） var buffer = { entries: [], add: function(value){ this.entries.push(value); }, concat: function(){ return this.entries.join(&apos;&apos;); } }; 该代码在直接使用时是没有问题的，思考下，由于高阶函数将函数/方法作为变量传递，那么可以有如下用法：（代码2） var arr = [&apos;Jay&apos;, &apos;.M&apos;, &apos;.Hu&apos;]; arr.forEach(buffer.add); console.log(buffer.concat()); //思考下这个结果是什么？ 以上代码在arr.forEach处已经报错，Cannot read property ‘push’ of undefined。因为这个时候的涉及到this的指向问题。我们可以改造下buffer代码，输出this让我们看看：（代码3） var buffer = { entries: [], add: function(value){ console.log(this); this.entries.push(value); }, concat: function(){ return this.entries.join(&apos;&apos;); } }; 从输出结果我们可以看到这个this，在（代码2）的执行环境中，指向的是window对象，所以导致了报错，那么如何避免这样的问题呢？针对forEach，我们有三个方法：(代码4) //方式一，去掉this，直接用buffer对象引用 var buffer = { entries: [], add: function(value){ buffer.entries.push(value); }, concat: function(){ return buffer.entries.join(&apos;&apos;); } }; //方式二，指定接收者，forEach方法提供，其他方法不一定提供 var arr = [&apos;Jay&apos;, &apos;.M&apos;, &apos;.Hu&apos;]; arr.forEach(buffer.add, buffer); console.log(buffer.concat()); //方式三，通过用函数包装调用，来实现指定接收者 var arr = [&apos;Jay&apos;, &apos;.M&apos;, &apos;.Hu&apos;]; arr.forEach(function(s){ buffer.add(s); }); console.log(buffer.concat()); 针对这样的问题，ES5标准库中提供了一个bind()函数来实现这样的方法。只需要如下代码： var arr = [&apos;Jay&apos;, &apos;.M&apos;, &apos;.Hu&apos;]; arr.forEach(buffer.add.bind(buffer)); console.log(buffer.concat()); 该bind()函数，利用buffer.add.bind(buffer)创建了一个新函数而不是修改了buffer.add函数。新函数行为就像原来函数的行为，但它的接收者被重新指定了。所以调用bind方法是安全的，即使是一个可能在程序的其他部分被共享的函数。"},{"title":"编写高质量JS代码的68个有效方法（四）","permalink":"http://hstarorg.github.io/blog/blog/2014/11/29/编写高质量JS代码的68个有效方法-读书笔记/[20141129]编写高质量JS代码的68个有效方法（四）/","text":"##No.16、避免使用eval创建局部变量Tips： 避免使用eval函数创建的变量污染调用者作用域。 如果eval函数代码可能创建全局变量，将此调用封装到嵌套的函数中已防止作用域污染。 执行eval时，eval中的变量才会被加到作用域中（函数作用域） function fun1(){ eval(&apos;var y = 1;&apos;); console.log(&apos;fun1-&gt;y:&apos;+y); // &apos;fun-&gt;y:1&apos; } fun1(); console.log(&apos;global-&gt;y:&apos;+y); //throw Error 不要直接将不可控参数交给eval执行，可能会改变作用域对象。 //Bad code var g = &apos;global&apos;; function fun2(code){ eval(code); } fun2(&apos;var g=&quot;local&quot;&apos;); console.log(g) //&apos;local&apos; //Right code var g = &apos;global&apos;; function fun2(code){ (function(){ eval(code); })(); } fun2(&apos;var g=&quot;local&quot;&apos;); console.log(g) //&apos;global&apos;,嵌套作用域 以上Right Code，如果执行不带var的变量申明，那么也是会影响全局的g对象的。 No.17、间接调用eval函数优于直接调用Tips： 将eval函数同一个毫无意义的字面量包裹在序列表达式中以达到强制使用间接调用eval函数的目的 尽可能间接调用eval函数，而不要直接调用eval函数 直接调用eval，那么编译器无法优化JS代码。如何间接调用eval？ (0,eval)(code) ##No.18、理解函数的调用、方法调用及构造函数调用之间的不同Tips： 方法调用将被查找方法属性的对象作用调用接收者 函数调用将全局对象作为其接受者。一般很少使用该函数调用语法来调用方法 构造函数需要通过new运算符调用，并产生一个新的对象作为其接收者 在全局对象上直接定义的function被称为函数，调用则是函数调用 var fun1 = function(p){ console.log(p); }; function fun2(p){ console.log(p); } //函数调用 fun1(&apos;p1&apos;); fun2(&apos;p2&apos;); 如果对象的属性是函数，那么称之为方法，使用模式则是方法调用 var obj = { name: &apos;Hello &apos;, fun1: function(name){ console.log(this.name + name); } }; //方法调用 obj.fun1(&apos;Jay&apos;); 注意：fun1中通过this来访问obj的name属性 构造函数调用将一个全新的对象作为this变量的值 fucntion User(name, age){ this.Name = name; this.Age = age; } //此时，user是一个全新的对象 var user = new User(&apos;Jay&apos;, 23); ##No.19、熟练掌握高阶函数Tips： 高阶函数是那些将函数作为参数或返回值的函数 熟练掌握现有库的高阶函数 学会发现可以被高阶函数所取代的常见编码模式 需求：将数组元素全部转换为大写 //常规做法 var arr = [&apos;abc&apos;, &apos;test&apos;, &apos;123&apos;]; for(var i =0, len = arr.length; i &lt; len; i++){ arr[i] = arr[i].toUpperCase(); } console.log(arr); //高阶函数 var arr = [&apos;abc&apos;, &apos;test&apos;, &apos;123&apos;]; arr = arr.map(function(item){ return item.toUpperCase(); }); console.log(arr); 注意：需要注意高阶函数使用时的返回值，有些是更改原始对象，有些是返回新对象 ##No.20、使用call方法自定义接收者来调用方法Tips： 使用call方法自定义接收者（个人理解为作用域）来调用函数 使用call方法可以调用在给定对象中不存在的方法 使用call方法定义高阶函数允许使用者给回调函数指定接收者 function fun1(){ this.name = &apos;Test&apos;; } var obj = { name: &apos;Jay&apos; }; console.log(obj.name); fun1.call(obj); console.log(obj.name); call函数的调用方式： f.call(obj, p1, p2, p3);"},{"title":"JavaScript之Array常用功能汇总","permalink":"http://hstarorg.github.io/blog/blog/2014/11/21/JS札记/[20141121]JavaScript之Array常用功能汇总/","text":"导语：在JavaScript中，Array是一个使用比较频繁的对象，那么它到底有哪些常用的方法呢？ 首先，我们先看一下Array对象的类型： typeof Array // &apos;function&apos; Array instanceof Object // true 从上可以看出，Array本质是一个function，同样派生自Object，定义如下： function Array(args) {} ###接下来，我们来看Array自身的方法： #1、concat()定义：原型方法，连接两个或更多的数组，并返回结果（新数组）。 Array.prototype.concat = function(items) {}; 示例： var arr1 = [1, 2]; var arr2 = arr1.concat([3, 4]); var arr3 = arr2.concat([5, 6], [7, 8] ,10, {}); console.log(arr1); // [1, 2] console.log(arr2); // [1, 2, 3, 4] console.log(arr3); // [1, 2, 3, 4, 5, 6, 7, 8, 10, Object] 注意：concat不仅可以连接单个对象，也可以连接多个对象，同时如果是参数为数组，那么会将数组元素拆分并连接，如果是对象，则直接将对象连接。该方法不会改变原始数组 #2、join()定义：原型方法，把数组的所有元素放入一个字符串。元素通过指定的分隔符进行分隔。 Array.prototype.join = function(separator) {}; 示例： var arr = [1, 2, 3]; console.log(arr.join(&apos;|&apos;)); // &apos;1|2|3&apos; console.log(arr.join(&apos;&apos;)); // &apos;123&apos; console.log(arr.join(&apos;---&apos;)); // &apos;1---2---3&apos; 注意：太常用了，没什么可注意的~ #3、pop()定义：原型方法，删除并返回数组的最后一个元素。 Array.prototype.pop = function() {}; 示例： var arr1 = [1, 2, 3, 4]; var lastOne = arr1.pop(); console.log(lastOne); // 4 console.log(arr1); // [1, 2, 3] 注意：该方法无参数，有返回值，返回数组最后一个元素。该方法会改变原始数组 #4、push()定义：原型方法，向数组的末尾添加一个或更多元素，并返回新的长度。 Array.prototype.push = function(items) {}; 示例： var arr1 = [1, 2]; var len = arr1.push(3); var arr2 = arr1.push(4, 5); console.log(len); console.log(arr1); console.log(arr2); 注意：该方法的返回值会返回数组的新长度。该方法会改变原始数组 #5、reverse()定义：原型方法，颠倒数组中元素的顺序。 Array.prototype.reverse = function() {}; 示例： var arr1 = [1, 2, 3, 4, 5]; var res = arr1.reverse(); console.log(res); console.log(arr1); 注意：该方法的返回值为自身（翻转后的值），该方法会改变原始数组 6、shift()定义：原型方法，删除并返回数组的第一个元素。 Array.prototype.shift = function() {}; 示例： var arr1 = [1, 2, 3]; var res = arr1.shift(); console.log(res); console.log(arr1); 注意：该方法返回数组第一个元素，和pop()方法对应（返回并删除最后一个元素）。该方法会改变原始数组 #7、slice()定义：原型方法，从某个已有的数组返回选定的元素。 Array.prototype.slice = function(start,end) {}; 示例： var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]; var res1 = arr.slice(0, 3); var res2 = arr.slice(0, 100); var res3 = arr.slice(-1,-6); var res4 = arr.slice(-6, -1); console.log(res1); console.log(res2); console.log(res3); console.log(res4); console.log(arr) 注意：该方法支持逆向索引，同时索引采取区间左闭右开的原则。该方法不会改变原始数组 #8、sort()定义：原型方法，对数组的元素进行排序。 Array.prototype.sort = function(compareFn) {}; 示例： var arr = [1, 5, 2, 3, 4, 7, 8, 6, 9]; var res1 = arr.sort(); //如果是数字，默认从小到大排序 console.log(res1); var arr2 = [&apos;a&apos;, &apos;c&apos;, &apos;b&apos;]; var res2 = arr2.sort();//如果是字符，按照字符顺序（ASCII，字符串同）排序 console.log(res2); //遇到复杂数据，经过测试是按照数组&lt;正则&lt;数字&lt;对象&lt;字符串&lt;函数 这个顺序 var arr3 = [{name:&apos;name&apos;}, 134, &apos;aaa&apos;, function(){}, [], /a/]; var res3 = arr3.sort(); console.log(arr3); //可以通过自定义规则实现复杂的排序 var res4 = arr.sort(function(a1, a2){ if(a1 === a2){ // 两者相等，那么就算想等 return 0; } if(a1%3 === 0){ //如果a1被3整除，那么a1小 return -1; } if(a2%3 === 0){ //如果a2被3整除，那么a2小 return 1; } return a2%3-a2%3; //不满足以上条件，那么根据余数比大小，余数小的元素小 }) console.log(res4); 注意：该方法返回自身（排序后数组）。可通过function(a1, a2){}实现非常复杂的排序规则。该方法会改变原始数组 #9、splice()定义：原型方法，删除元素，并向数组添加新元素。（该方法相等较复杂，悠着点用） Array.prototype.splice = function(start,deleteCount,items) {}; 示例： var arr1 = [1, 2, 3, 4, 5, 6, 7, 8, 9]; var res1 = arr1.splice(0, 3, &apos;new1&apos;, &apos;new2&apos;); console.log(res1); // [1, 2, 3] console.log(arr1); // [&apos;new1&apos;, &apos;new2&apos;, 4, 5, 6, 7, 8, 9] arr1 = [1, 2, 3, 4, 5, 6, 7, 8, 9]; res1 = arr1.splice(-6, 3, &apos;new1&apos;, &apos;new2&apos;); console.log(res1); // [4, 5, 6] console.log(arr1); // [1, 2, 3, &apos;new1&apos;, &apos;new2&apos;, 7, 8, 9] 注意：splice()函数支持倒叙索引，同时第二个参数是长度（不是下标），新插入的数据会插入在start下标位置。返回值为删除的元素数组。该方法会改变原始数组 #10、unshift()定义：原型方法，向数组的开头添加一个或更多元素，并返回新的长度。 Array.prototype.unshift = function(items) {}; 示例： var arr1= [1, 2, 3]; var res1 = arr1.unshift(&apos;new1&apos;, &apos;new2&apos;); console.log(res1); // 5 console.log(arr1); // [&quot;new1&quot;, &quot;new2&quot;, 1, 2, 3] 注意：该方法和push相对(在末尾添加元素，返回新长度)，该方法的返回值是新数组长度。该方法会改变原始数组 我们还可以为Array添加更多的常用功能，比如：Array.prototype.where = function(predicateFn){ var parameterIsFn = typeof predicateFn === &apos;function&apos; var result = []; for(var i = 0, len = this.length; i &lt; len; i++){ if(!parameterIsFn || predicateFn(this[i])){ result.push(this[i]); } } return result; }; var arr = [&apos;new1&apos;, &apos;new2&apos;, 1, 2, 3]; var res = arr.where(function(item){ return typeof item === &apos;number&apos;; }); console.log(res);"},{"title":"这些年你需要注意的SQL","permalink":"http://hstarorg.github.io/blog/blog/2014/11/14/SQL SERVER/[20141114]这些年你需要注意的SQL/","text":"#1、使用对象时，请显式的指定对象的架构者（默认为dbo）分析： 在SQL SERVER中，如果用户User1访问表table1，那么查询分析器必须决定是检索 User1.table1 还是 dbo.table1 。所以每次User1访问同一张表table1时，查询分析器都必须对查询计划重编译，影响执行速度。 #2、尽量避免使用SELECT *，建议使用 SELECT 分析： 采用SELECT * 语法会导致DB对列进行一个遍历，同时可能会查询多余字段数据(本着用啥查啥的原则，建议使用SELECT &lt;Field List&gt;)，导致查询性能下降。 #3、如果一个T-SQL语句涉及到多个表，则引用的每个列必须制定该列所属的对象分析： 避免造成数据查询异常 #4、Insert语句中必须指定插入列的列表分析： 避免表列变化导致插入语句失败 #5、在非事物和特别要求完整性的上下文中，使用NOLOCK查询分析： 考虑到并发性，提高查询效率 示例： 1SELECT TOP 100 COL1,COL2 FROM TABLE1 t1 WITH (NOLOCK) #6、通过SELECT语句对变量赋值时，如果未使用聚合函数，请加上TOP 1分析： 防止结果非预期 示例： (预期结果为2，因为第二次Name2是后添加的。) 123456789101112131415161718192021222324252627282930313233343536373839404142CREATE TABLE test6( Id int ,Name nvarchar(32) )INSERT INTO test6 (Id, Name)SELECT 1, N'Name1'UNION allSELECT 2, N'Name2' INSERT INTO test6 (Id, Name)SELECT 3, N'Name2'--错误的写法DECLARE @Id intSELECT @Id=Id FROM test6 WHERE Name = 'Name2'--正确的写法DECLARE @Id intSELECT TOP 1 @Id=Id FROM test6 WHERE Name = 'Name2'``` ## #7、对于排序后取字段TOP 1的值，建议使用聚合**分析:** 可以用上索引，而且不需要Table Scan**示例：**```sql--错误的写法SELECT TOP 1 col1 FROM table1 ORDER BY col1 DESC--正确的写法SELECT MAX(col1) FROM table1 #8、有关char和varchar，char和nchar,varchar和nvarchar的区别分析： char是固定长度，如果数据不够，会在存储时自动补空格 varchar是可变长度，会有三个字节来存储字段信息，可以设置最大长度 nchar和varchar这种以N开头的表示存储unicode编码字符 在特定字符集下，如果定义数据格式为char或者是varchar，那么存储特殊字符（包括中文）会乱码 关于数据库函数LEN()，是用于返回指定字符串表达式的字符数，其中不包含尾随空格。 关于DATALENGTH函数，返回用于表示任何表达式的字节数。 示例： 1234567891011121314151617181920212223242526272829303132333435363738DECLARE @s1 CHAR(5) ,@s2 VARCHAR(5) ,@s3 NCHAR(5) ,@s4 NVARCHAR(5)--看看这个结果是什么？SET @s1 = 'test'SET @s2 = 'test'SET @s3 = 'test'SET @s4 = 'test'SELECT LEN(@s1) ,LEN(@s2) ,LEN(@s3) ,Len(@s4)SELECT DATALENGTH(@s1) ,DATALENGTH(@s2) ,DATALENGTH(@s3) ,DATALENGTH(@s4)--如果这样呢？SET @s1 = '我是中文'SET @s2 = '我是中文'SET @s3 = '我是中文'SET @s4 = '我是中文'SELECT LEN(@s1) ,LEN(@s2) ,LEN(@s3) ,Len(@s4)SELECT DATALENGTH(@s1) ,DATALENGTH(@s2) ,DATALENGTH(@s3) ,DATALENGTH(@s4)--一般情况下，SELECT @s1,@s2,@s3,@s4不会显示乱码，是由于安装SQL SERVER的时候后默认字符集是支持unicode字符的。如果遇到不支持的字符集，就需要显示定义字段类型为带N的类型，同时在赋值的时候使用N'中文'这种形式。 #9、禁止在使用了事物的情况下，不编写防止造成未提交或者未回滚事务的情况的处理代码分析： 数据库阻塞，你懂的…罪过大大的！ #10、警惕表变量的使用示例： 12345678910--思考下结果是什么？IF NOT exists (SELECT 1)BEGIN PRINT 'enter' DECLARE @table TABLE ( name nvarchar(32) )ENDSELECT name FROM @table 分析： 在表变量的使用中，会出现如JavaScript一样的定义前置，相当于不管你在哪个条件（也不关心是否能走到这个分支）中定义表变量，那么这个表变量在整个作用域中都是有效的。 临时表表现正常 表变量和一般的变量有点不一样的地方，表变量也会在tempdb中创建表。示例如下： 123456CREATE TABLE #TempTable (TT_Col1 INT)DECLARE @TableVariable TABLE (TV_Col1 INT)SELECT TOP 2 * FROM tempdb.sys.tablesORDER BY create_date DESC #11、判断是否存在（或者不存在）符合条件的记录使用 EXISTS 关键字。分析： 123456789IF (SELECT COUNT(*) FROM Table WITH (NOLOCK))&gt;0BEGIN --Do somethingEND--应该用：IF EXISTS(SELECT TOP 1 1 FROM Table WITH (NOLOCK)BEGIN --Do somethingEND #12、字符串比较时，SQL SERVER会忽略末尾的空格。示例： 12SELECT 1 WHERE 't' ='t ' #13、注意NULL的特殊性分析： 1.NULL既不能被=匹配，也不能被&lt;&gt;(!=)匹配，只能用IS NULL 或者是 ISNULL() 示例： 123456789101112CREATE TABLE #tb(col1 int)INSERT INTO #tb(col1)SELECT NULL UNION SELECT 1 UNIONSELECT 2SELECT COUNT(*) FROM #tb WHERE col1 &lt;&gt; 1 OR col1 = 1 --2SELECT COUNT(*) FROM #tb --3 14、COUNT(0),COUNT(*),COUNT(column)的区别分析： COUNT(0),COUNT(*)计数时会包含NULL值 COUNT(column)计数时，如果需要该列为NULL，则会忽略计数 示例:1234567891011CREATE TABLE #tb(col1 int)INSERT INTO #tb(col1)SELECT NULL UNION SELECT 1 UNIONSELECT 2SELECT COUNT(*) FROM #tb --3SELECT COUNT(0) FROM #tb --3SELECT COUNT(col1) FROM #tb --2 #15、通过合理的方法避免在 SELECT 语句中使用 DISTINCT分析： DISTINCT 是数据查询中一个非常慢的操作，所以尽可能的避免 示例：123456789101112131415SELECT DISTINCT A.au_fname ,A.au_lnameFROM dbo.authors AS A WITH (NOLOCK) INNER JOIN dbo.titleAuthor AS T WITH (NOLOCK) --一对多的关系ON T.au_id = A.au_id--避免DISTINCT的写法SELECT au_fname ,au_lnameFROM dbo.authors AS A WITH (NOLOCK) WHERE EXISTS ( SELECT TOP 1 1 FROM dbo.titleAuthor AS T WITH (NOLOCK) WHERE T.au_id = A.au_id"},{"title":"编写高质量JS代码的68个有效方法（三）","permalink":"http://hstarorg.github.io/blog/blog/2014/10/30/编写高质量JS代码的68个有效方法-读书笔记/[20141030]编写高质量JS代码的68个有效方法（三）/","text":"##No.11、熟练掌握闭包Tips： 函数可以引用定义在其外部的作用域变量。 闭包比创建它们的函数有更长的生命周期。 闭包在内部存储其外部变量的引用，并能读写这些变量。 //第一个事实：JavaScript允许你引用在当前函数以外定义的变量。 function testClosures(){ var all = &apos;Test&apos;; function test(m){ return all + &apos; and &apos; + m; } return test(&apos;closures&apos;); } testClosures(); //‘Test and closures’ //第二个事实：即使外部函数已返回，当前函数仍然可以引用在外部函数所定义的变量。 function testClosures(){ var all = &apos;Test&apos;; function test(m){ return all + &apos; and &apos; + m; } return test; } var t = testClosures(); t(‘closures’); //‘Test and closures’ //第三个事实：闭包可以更新外部变量的值 function TestClass(){ var all; return { set: function(value){ all = value; }, get: function(){ return all; } }; } var t = new TestClass(); t.set(‘555’); t.get(); 闭包的优缺点：优点： 变量保护、封装性，能够实现字段的可访问性(示例如下) function ModelClass(){ //Property var name,age=23; return { setName: function(value){ //设置名称 name = value; }, getName: function(){ //获取名称 return name; }, getAge: function(){ //只读 return age; } }; } 缺点： 常驻内存，会增加内存使用量，使用不当和容易造成内存泄露。 No.12、理解变量申明提升 代码块中的函数申明会提升到函数顶部 重复申明变量被视为单个变量 考虑手动提升局部变量的申明，避免混淆（将函数内所需变量集中申明到函数顶部） JavaScript支持词法作用域，而不支持块级作用域 function test(){ alert(a); //undefined var a = 1; alert(a); //1 } test(); 以上代码等价于： function test(){ var a; alert(a); //undefined a = 1; alert(a); //1 } test(); 一个例外是 try…catch :catch块中的变量作用域只在catch中。 function test(){ var x = &apos;1&apos;; try{ throw &apos;&apos; }catch(x){ alert(&apos;error&apos;); x = &apos;2&apos;; } alert(x); // 1 } test(); No.13、使用立即调用的函数表达式创建局部作用域 理解绑定与赋值的区别 闭包通过引用而不是值捕获它们的外部变量 使用立即调用的函数表达式（IIFE）来创建具有作用域 当心在立即调用的函数表达式中包裹代码块可能改变其行为的情形 看看以下代码段输出什么？ function test(){ var arr = [1,2,3,4,5]; var result = []; for(var i = 0, len = arr.length; i &lt; len; i++){ result[i] = function(){ return arr[i]; } } return result; } var result = test(); result[0](); 可以通过立即调用表达式来解决JavaScript缺少块级作用域。如上代码可修改为: function test(){ var arr = [1,2,3,4,5]; var result = []; for(var i = 0, len = arr.length; i &lt; len; i++){ (function(){ var j = i; result[i] = function(){ return arr[j]; } })(i); } return result } var result = test(); result[0](); ##No.14、当心命名函数表达式笨拙的作用域 在Error对象和调试器中使用命名函数表达式改进栈跟踪 在ES3和有问题的JS环境中，函数表达式作用域会被Object.prototype污染 谨记在错误百出的JS环境中会提升命名函数表达式声明，并导致命名函数表达式的重复存储 考虑避免使用命名函数表达式或在发布前删除函数名 如果将代码发布到正确实现的ES5的环境中，没什么好担心的 匿名和命名函数表达式的官方区别在于后者会绑定到与其函数名相同的变量上，该变量将作为该函数内部的一个局部变量。这可以用来写递归函数表达式。 var f = function find(tree, key){ if(!tree){ return null; } if(tree.key === key){ return tree.value; } //函数内部可以访问find return find(tree.left, key) || find(tree.right, key); } 结论：尽量避免使用命名函数表达式 No.15、当心局部块函数声明笨拙的作用域 始终将函数声明置于程序或被包含的函数的最外层以避免不可移植的行为 使用var声明和有条件赋值语句替代有条件的函数声明 function f(){ return &apos;global&apos;; } function test(x){ var result = []; if(x){ function f(){ return &apos;local&apos;; } result.push(f()); } result.push(f()); return result; } test(true); test(false); 结论：尽量将函数块定义为变量，防止函数提前"},{"title":"从0开始Grunt","permalink":"http://hstarorg.github.io/blog/blog/2014/10/25/前端相关/[20141025]从0开始Grunt/","text":"首先，Grunt是什么？Grunt是JavaScript任务运行工具。使用它可以自动化诸如文件(夹)操作、代码压缩、代码编译、单元测试、代码规范校验等等重复的任务。 如何安装Grunt？（Windows）Step1、Grunt依赖Node扩展包，那么必须要安装Node： 打开Node官网：http://nodejs.org/ 点击 INSTALL 按钮，会自动适配环境，下载一个安装包，双击安装即可 打开cmd命令行，输入命令代码： node -v ，如果输出一个具体的版本号，如 v0.10.xx ，则表示安装成功。 Step2、安装grunt的命令行工具： 打开cmd命令行，输入命令代码：npm install -g grunt-cli ,该命令表示全局安装grunt的命令行 到此，Grunt算是安装完成。 如何使用？（以一个SPA为例）首先，创建该项目SPADemo，目录结构如下： SPADemo src images //图片文件夹 styles //样式表文件夹 scripts //脚本文件夹 vendor //存放第三方组件 index.html //默认页 第二步，书写package.json 文件，确定依赖项。放在src同级目录,内容如下： { &quot;name&quot;: &quot;SPADemo&quot;, &quot;version&quot;: &quot;0.1.0&quot;, &quot;devDependencies&quot;: { &quot;grunt&quot;: &quot;~0.4.2&quot; } } 第三步，打开SPADemo根文件夹，在路径栏输入cmd，进入当前目录的cmd模式，输入 npm i ,初始化依赖项。当更该package.json后，可重复执行该命令。将依赖项重新初始化。会生成一个node_modules文件夹。 第四步，进行Grunt配置。默认配置文件名为Gruntfile.js（.coffee也可以，但是Gruntfile不能更改，同时必须放在src同级目录） 第五步，配置Gruntfile.js/coffee module.exports = function(grunt){ //初始化Grunt grunt.initConfig({}); // registerTask(taskName,taskDescription,taskFunc/childTaskArray) grunt.registerTask(&apos;default&apos;,&apos;任务入口&apos;,function(){ grunt.log.write(&apos;任务已启动！&apos;); }); }; 到现在，一个Grunt已经完整配置好了。进入SPADemo目录的cmd命令行，输入grunt，会显示“任务已启动！” 如何使用插件？文件清理插件 grunt-contrib-clean该插件用于清除目录/文件 首先在package.json中添加该依赖包。变化后配置如下： { &quot;name&quot;: &quot;SPADemo&quot;, &quot;version&quot;: &quot;0.1.0&quot;, &quot;devDependencies&quot;: { &quot;grunt&quot;: &quot;~0.4.2&quot;, &quot;grunt-contrib-clean&quot;: &quot;~0.6.0&quot; } } 然后在Gruntfile.js中增加该插件的配置，代码如下（更详细的配置请参考插件地址）： module.exports = function(grunt){ grunt.initConfig({ //clean插件的配置项，名字不能变化。 //插件地址：https://github.com/gruntjs/grunt-contrib-clean clean: { //任务具体配置，清除dist文件夹 cleanDist: { force: true, //允许操作当前工作目录之外的目录 src: &apos;dist/**/*&apos; //dist下的所有文件和目录 } } }); grunt.loadNpmTasks(&apos;grunt-contrib-clean&apos;);// 必须，使用clean插件，必须要调用该方法，加载插件 // registerTask(taskName,taskDescription,taskFunc/childTaskArray) grunt.registerTask(&apos;default&apos;,&apos;任务入口&apos;,function(){ grunt.log.write(&apos;任务已启动！&apos;); grunt.task.run([ &apos;clean:cleanDist&apos; //使用clean任务的cleanDist配置运行任务 ]); }); }; 最后cmd运行grunt命令，就可以执行对dist目录的清理了。可以手动新建dist文件夹测试。 写在最后Grunt是一个庞大的生态系统，我们可以自由的选择数以百计的插件来帮助处理自动化任务。同时，如果发现没有合适的插件，我们还可以自己创建插件并通过npm发布，以供更多人使用和完善。"},{"title":"编写高质量JS代码的68个有效方法（二）","permalink":"http://hstarorg.github.io/blog/blog/2014/10/11/编写高质量JS代码的68个有效方法-读书笔记/[20141011]编写高质量JS代码的68个有效方法（二）/","text":"##No.6、了解分号插入的局限性Tips： 仅在“}”标记之前、一行的结束和程序的结束处推导分号 仅在紧接着的标记不能被解析的时候推导分号 在以(、[、+、-或/字符开头的语句前绝不能省略分号 当脚本连接的时候，在脚本之间显式的插入分号 在return、throw、break、continue、++或–的参数之前绝不能换行 分号不能作为for循环的头部和空语句的分隔符而被推导出 个人总结：尽量不要省略分号，不要让JS自动推导 分号仅在}标记之前、一个或多个换行之后和程序输入的结尾被插入，看代码： // 能自动推导分号 function square(x){ var n = +x return n*n } // Error，不能自动推导 function square(x){var n = +x return n*n} 分号仅在随后的输入标记不能被解析时插入，看代码： a=b (f()); 此时，代码等价于 ab(f()); 但是： a=b f() 则会被解析为a=b f(); 在以(、[、+、-或/字符开头的语句前，绝不能省略分号，看代码： a=b [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;].forEach(function(key){ console.log(key) }) 等价于 a=b[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;].forEach(function(key){ console.log(key); }); a=1 /Error/i.test(&apos;test&apos;) 等价于 a=1/Error/i.test(&apos;test&apos;); 合并脚本时不能省略分号，看代码： //file1.js (function(){console.log(&apos;file1&apos;)})() //file2.js (function(){console.log(&apos;file2&apos;)})() //合并后 --输出file1，然后报错 (function(){console.log(&apos;file1&apos;)})()(function(){console.log(&apos;file2&apos;)})() 为了防止自己写的库在合并时内其他代码干扰，所以一般写法为如下代码： ;(function(){ /*Code*/ })(); 在return、throw、break、continue、++或–的参数之前绝不能换行，看代码： a ++ b 等价于： a;++b; for循环中不要省略分号 //Parse Error var total=0 for(var i=0,total=1 i&lt;n i++){ total*=i } 综上，再次强调，不加分号看起来代码轻量，但稍不注意就会引起很多bug，所以，建议都加上分号，不要让JS环境自行推导 ##No.7、视字符串为16位的代码单元序列 待定... ##No.8、尽量少用全局对象Tips： 避免申明全局变量 尽量申明局部变量 避免对全局对象添加属性 使用全局对象来做平台特性检测 定义全局变量会污染共享的公命名空间，并可能导致意外的命名冲突。全局变量不利于模块化，因为它会导致程序中独立组件间的不必要耦合。 ##No.9、始终声明局部变量Tips： 始终使用var声明新的局部变量 考虑使用lint工具来帮助检查未绑定的变量 如果存在比全局变量更麻烦的事情，那就是意外的全局变量。由于不适用var申明的变量，统统为全局变量，所以一定要使用var来定义变量，防止变量污染。 function test(){ test=&apos;test&apos;; } test(); window.test;// &apos;test&apos; ##No.10、避免使用withTips： 避免使用with语句 使用简短的变量名代替重复访问的对象 显式地绑定局部变量到对象属性上，而不要使用with语句隐式地绑定他们"},{"title":"编写高质量JS代码的68个有效方法（一）","permalink":"http://hstarorg.github.io/blog/blog/2014/09/26/编写高质量JS代码的68个有效方法-读书笔记/[20140926]编写高质量JS代码的68个有效方法（一）/","text":"##No.1、了解你使用的JavaScript版本Tips： 决定你的应用程序支持JavaScript的哪些版本。 确保你使用的任何JavaScript的特性对于应用程序将要运行的所有环境都是支持的。 总是在执行严格模式检查的环境中测试严格代码。 当心连接那些在不同严格模式下有不同预期的脚本。 JavaScript的普及使得它在1997年成为国际标准，官方名称为ECMAScript。除了ECMAScript标准存在多个版本之外，还存在一些JavaScript实现支持非标准特性，其他JavaScript实现不支持的情况。所以需要注意你所写的JavaScript代码所支持的版本。 /*[Sample]如下代码，在IE下会Syntax error，但是在Chrome中则是定义常量*/ const PI=3.14;PI=3;PI 由于JavaScript的主要生态系统–Web浏览器并不支持让程序员指定某个JavaScript版本来执行代码。在ES5中，引入了另外一种版本控制的考量–严格格式（strict mode），这个特性允许你选择在受限制的JavaScript版本中禁用JavaScript语言中问题较多或易于出错的特性。由于JS语法涉及向后兼容，所以在没有严格检查的环境中也能执行严格代码。 /*[Sample]如何使用严格模式，在程序/函数体的开始处加入&apos;use strict&apos; 使用字符串字面量作为指令看起来比较怪异，但好处是可以向后兼容，因为执行字符串字面量没有任何副作用 /* function f(x){ &apos;use strict&apos;; var arguments=[];//SyntaxError:Unexpected eval or arguments in strict mode } “use strict”指令只有在脚本或者函数顶部才生效，这也是使用严格模式的一个陷进。脚本连接将变得颇为敏感。假如有多个js文件，一些需要执行在严格模式下，一些不需要执行在严格模式下，如何处理呢？ 将需要严格模式检查的文件和不需要严格模式检查的文件分开连接 通过将自身包裹在立即调用的函数表达式中的方式来连接多个文件 /file1.js/ function fun1(){ var arguments=[]; } /file2.js/ ‘use strict’; function fun2(){ console.log(&apos;strict mode!&apos;); } /按照方式二连接后的文件内容应该是/ /fileMerge.js/ (function(){ function fun1(){ var arguments=[]; } })(); (function(){ &apos;use strict&apos;; function fun2(){ console.log(&apos;strict mode!&apos;); } })(); ##No.2、理解JavaScript的浮点数Tips： JavaScript的数字都是双精度的浮点数。 JavaScript的整数仅仅是双精度浮点数的一个子集，而不是一个单独的数据类型。 位运算将数字视为32位的有符号整数。 当心浮点运算中的精度陷进。 大部分语言都有几种数值数据类型，但是JavaScript只有一种 typeof 1; //&apos;number&apos; typeof 1.1; //&apos;number&apos; typeof -1; //&apos;number&apos; 对于位运算，JavaScript不会直接将操作数作为浮点数运算，会先转换为32位整数再进行运算 8|1; //9 8.1|1; //9 如何快速从10进制转换到2~36进制？ (100).toString(2); //1100100 (100).toString(10); //100 (100).toString(35); //2u (100).toString(36); //2s 注意parseInt和parseFloat的用法 警告（以下为非标准特性，各浏览器执行有差异）： 如果要转换的字符串已0x或者0X开头，那么parseInt(‘0xAB’)等价于parseInt(‘0xAB’,16) 如果遇到0开头，那么parseInt(‘013’)等价于parseInt(‘013’,8) 强烈建议在使用parseInt时指定进制 parseInt(‘9x’); //9 会自动忽略不能转换的字符 parseInt(‘x9’); //NaN 发现第一个字符就不能转换，返回NaN parseInt(‘1100100’,2); //100 可以在parseInt的第二个参数指定当前字符串的进制 parseInt(‘2xxx’,2); //NaN 遇到无法转换的情况，返回NaN parseInt(‘08’); //IE下:0,Chrome35下:8 浮点数是出了名的不精确，你能知道以下代码的执行结果吗？ 0.1+0.2; //0.30000000000000004 (0.1+0.2)+0.3; //0.6000000000000001 0.1+(0.2+0.3); //0.6 0.3-0.2; //0.09999999999999998 当我们关心精度时，要小心浮点数的局限性。有效的方法是尽可能的采用整数值运算，整数在运算时不需要舍入。 ##No.3、当心隐式的强制转换Tips： 类型错误可能被隐式的强制转换所隐藏。 重载的运算符+是进行加法运算还是字符串连接取决于其参数类型。 对象通过valueOf方法强制转换为数字，通过toString方法强制转换为字符串。 具有valueOf方法的对象应该实现toString方法，返回一个有valueOf方法产生的数字的字符串表示。 测试一个值是否为未定义的值，应该使用typeof或者与undeined进行比较而不是使用真值运算。 3+true; //4 true转换为数字1 ‘fun’(1); //TypeError:string is not a function null.x; //TypeError: Cannot read property ‘x’ of null 2+3; //5 2+’3’; //‘23’ 偏爱字符串，遇到字符串，那么优先用字符串连接 1+2+’3’; //‘33’ 加法运算是从左到右，所以等价于(1+2)+’3’ 1+’2’+3; //‘123’ ‘17’*3; //51 ‘8’|’1’ //9 如何测试一个值是NaN？ var x=NaN; x===NaN; //false，NaN不等于自身 如果知道带测试的值是数字，那么可以使用标准库函数isNaN isNaN(NaN); //true 但是对于其他绝对不是NaN，但会被强制转换为NaN的值，使用isNaN方法是无法区分的。 isNaN(&apos;foo&apos;); //true isNaN(undefined); //true isNaN({}); //true isNaN({valueOf:&apos;foo&apos;}); //true 幸运的是，有一个既简单有可靠但有点不直观的方法测试它： JS中，NaN是唯一一个不等于其自身的值。 var x=NaN; x!==x //true /*测试x是否是NaN，是返回true，否则返回false*/ function isReallyNaN(x){ return x!==x; } 如何控制对象的强制转换？ &apos;J&apos;+{toString:function(){return &apos;S&apos;}}; //&apos;JS&apos; 2*{valueOf:function(){return 3;}}; //6 var obj={ toString:function(){ return &apos;[object Obj]&apos;; }, valueOf:function(){ return 1; } } &apos;object:&apos;+obj; //&apos;object:1&apos; 解释： 1. 在需要数字的场合，优先判断valueOf，没有的话，则采用toString。 2. 如果对象同时拥有valueOf和toString方法，同时又一定是需要数字的场合，那么JavaScript盲目的选择valueOf方法而不是toString方法来解决这种含糊的情况。 3. 针对2：最好避免使用valueOf方法，除非对象的确需要一个数字的抽象，并且obj.toString()能产生一个obj.valueOf()的字符串的表示。 关于真值运算： JavaScript中有7个假值：false、0、-0、’’、NaN、null和undefined，其他都为真值 ##No.4、原始类型优于封装对象Tips： 当做相等比较是，原始类型的封装对象与其原始值行为不一样。 获取和设置原始类型值的属性会隐式地创建封装对象。 除了对象以外，JavaScript有5个原始值类型：布尔值、数字、字符串、null和undefined。（令人困惑的是，对于null类型进行typeof操作得到的结果为”object”，然而，ECMAScript标准描述其为一个独特的类型。） var s=&apos;hello&apos;; var sObj=new String(s); typeof s; //&apos;string&apos; typeof sObj; //&apos;object&apos; 包装对象的类型是object var sObj1=new String(s); var sObj2=new String(s); sObj1==sObj2; //false sObj1===sObj2; //false 解释：可以理解为引用类型，每个对象是单独的对象，其引用是不一致的，所以只等于自身。 JavaScript对基本类型有隐式封装，所以我们可以如下书写代码： &apos;test&apos;.toUpperCase(); //&apos;TEST&apos; &apos;test&apos;.test=&apos;test&apos;; &apos;test&apos;.test; //undefined 解释：对基本类型调用方法/设置属性时，会产生隐式封装。 原始值-&gt;封装类型（产生封装对象）-&gt;封装对象执行方法/设置属性-&gt;返回原始值-&gt;抛弃封装对象。 所以更新封装不会造成持久的影响，同时对原始值设置属性是没有意义的。 ##No.5、避免对混合类型使用==运算符Tips： 当参数类型不同时，==运算符应用了一套难以理解的隐式强制转换规则。 使用===运算符，使读者不需要设计任何的隐式强制转换就能明白你的比较运算。 当比较不同类型的值时，使用你自己的显式强制转换使程序的行为更清晰。 看代码： &apos;1.0e0&apos;=={valueOf:function(){return true;}}; //true 因为通过隐式转换，就变成了1==1，所以结果为true。 转换为字符串：&apos;&apos;+1; //&apos;1&apos; 转换为数字 : +&apos;1&apos;; //1 var date=new Date(&apos;1999/12/31&apos;); date==&apos;1991/12/31&apos;;//false date==&apos;Fri Dec 31 1999 00:00:00 GMT+0800 (China Standard Time)&apos;;//true 解释：世界上有太多的数据表现形式，JS需要知道你使用的是哪一种，==运算符并不能推断和统一所有的数据格式，所以更好的策略是显式自定义应用程序转换的逻辑，并使用严格相等运算符。"},{"title":"C#可替代反射的几种方式","permalink":"http://hstarorg.github.io/blog/blog/2014/09/13/C#/[20140913]可替代反射的几种方式/","text":"##标准的反射代码## var type = obj.GetType(); var fieldInfo = type.GetField(&quot;age&quot;, BindingFlags.Instance | BindingFlags.NonPublic); fieldInfo.SetValue(obj, 20); // Console.WriteLine(&quot;设置年龄成功：{0}&quot;, (obj as ModelTest).Age); var s1 = type.InvokeMember(&quot;TestMethod1&quot;, BindingFlags.InvokeMethod, null, obj, null); var s2 = type.InvokeMember(&quot;TestMethod2&quot;, BindingFlags.InvokeMethod | BindingFlags.NonPublic | BindingFlags.Instance, null, obj, null); // Console.WriteLine(s1); // Console.WriteLine(s2); ###说明### 能动态获取对象属性、方法、字段等信息 能访问对象的私有字段，属性，方法等成员 能动态修改对象属性 注：访问public方法使用BindingFlags.InvokeMethod，访问私有方法时，必须加上BindingFlags.NonPublic|BindingFlags.Instance，否则会出现找不到方法的异常 ##采用dynamic对象达到发射的效果## dynamic d = obj; var s1 = d.TestMethod1(); Console.WriteLine(s1); ###说明### 可使用公开的属性，字段，方法等成员 代码足够简洁 注：不能访问非公开的成员 ##依赖Microsoft的测试组件Microsoft.VisualStudio.TestTools.UnitTesting来达到反射的效果## var privateObj = new PrivateObject(obj); privateObj.SetField(“age”, 20); var age = privateObj.GetProperty(“Age”); Console.WriteLine(age); privateObj.Invoke(“TestMethod1”); privateObj.Invoke(“TestMethod2”); ###说明### 采用第三方组件实现 ##性能说明##测试代码如下： private static void Main(string[] args) { RunSpecialTest(new SimpleReflection(), 1000); RunSpecialTest(new DynamicReflection(), 1000); RunSpecialTest(new PrivateObjectReflection(), 1000); Console.ReadKey(); } private static void RunSpecialTest(ITest test, int runCount) { var modelTest = new ModelTest(); var stopwatch = new Stopwatch(); stopwatch.Start(); for (int i = 0; i &lt; runCount; i++) { test.TestRun(modelTest); } stopwatch.Stop(); Console.WriteLine(&quot;运行{0} {1}次，共耗时：{2}ms&quot;, test.Name, runCount, stopwatch.ElapsedMilliseconds); } 结果： 运行SimpleReflection 1000次，共耗时：2ms 运行DynamicReflection 1000次，共耗时：717ms 运行PrivateObjectReflection 1000次，共耗时：14ms ##疑问## 采用标准的反射用法，除了第一次耗时较慢意外，后面耗时都很短，可以说是最快的方式，猜测是缓存，具体未知。 PrivateObjectReflection这个和发射有类似的情况，初次慢，后面快。何解？"}]}