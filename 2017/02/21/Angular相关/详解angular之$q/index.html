<!DOCTYPE html><html class="han-init" lang="zh-Hant"><head><meta name="author" content="Jay.M.Hu"><meta name="description" itemprop="description" content="0、什么的PromisePromise（承诺）是用于改善异步编程体验的一种编程模型，它提供了一些列的API的方法论，让你能更优雅的解决异步编程中出现的一些问题。
1、Promise的核心竞争力在处理有依赖性的回调的时候，我们的代码是这样写的：
step1(function (value1) {
  "><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>详解angular之$q · Love life, love coding~</title><link rel="stylesheet" type="text/css" href="/blog/font/fantasque_sans_mono/stylesheet.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/webicons/2.0.0/webicons.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/Han/3.3.0/han.min.css"><link rel="stylesheet" type="text/css" href="/blog/styles/screen.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/highlight.js/9.9.0/styles/gruvbox-dark.min.css"></head><body><header><a href="/blog/"><img class="logo" src="https://avatars1.githubusercontent.com/u/4043284?v=3&amp;s=460" alt="幻☆精灵的Blog" title="幻☆精灵的Blog"></a><h1><a href="/blog/" alt="幻☆精灵的Blog" title="幻☆精灵的Blog">幻☆精灵的Blog</a></h1><p>Love life, love coding~</p><nav><ul><li><a href="/" alt="首页" title="首页">首页</a></li><li><a href="pigeonhole" alt="归档" title="归档">归档</a></li><li><a href="links" alt="链接" title="链接">链接</a></li><li><a href="about" alt="关于" title="关于">关于</a></li></ul><div class="xnews-icon"><a target="_blank" href="https://github.com/hstarorg" style="position: relative; top: -2px;">&#xe735;</a><a target="_blank" href="https://twitter.com/Hstar19">&#xe71f;</a><a target="_blank" href="https://www.facebook.com/100015363883648">&#xe60b;</a><a target="_blank" href="https://www.zhihu.com/people/hstar">&#xe63f;</a><a target="_blank" href="https://weibo.com/hstarorg" style="position: relative; top: -2px;">&#xe603;</a></div></nav><div class="space"></div></header><main><article class="full"><h1>详解angular之$q</h1><span class="post-meta">写于<time> 2017 年 02 月 21 日 14 时 47 分</time><br>更新于<time> 2017 年 02 月 21 日 14 时 47 分</time></span><div class="article-toc"><strong>大纲</strong><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#0、什么的Promise"><span class="toc-number">1.</span> <span class="toc-text">0、什么的Promise</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1、Promise的核心竞争力"><span class="toc-number">2.</span> <span class="toc-text">1、Promise的核心竞争力</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2、Angular服务-q"><span class="toc-number">3.</span> <span class="toc-text">2、Angular服务$q</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1、Promise-then-将回调变成链式调用，then可以接两个参数，successCallback-errorCallback-示例如下："><span class="toc-number">3.0.1.</span> <span class="toc-text">1、Promise.then() 将回调变成链式调用，then可以接两个参数，successCallback, errorCallback,示例如下：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2、Promise-catch-捕获Promise异常，Promise-catch-errorCallback-等价于Promise-then-null-errorCallback"><span class="toc-number">3.0.2.</span> <span class="toc-text">2、Promise.catch 捕获Promise异常，Promise.catch(errorCallback)等价于Promise.then(null, errorCallback)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3、Promise-finally-callback-notifyCallback-promise结束后要做的事情和接收通知信息"><span class="toc-number">3.0.3.</span> <span class="toc-text">3、Promise.finally(callback, notifyCallback) promise结束后要做的事情和接收通知信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4、Deferred-resolve-val-通知promise请求处理完毕，并将处理结果传给回调函数（successCallback），示例如下："><span class="toc-number">3.0.4.</span> <span class="toc-text">4、Deferred.resolve(val) 通知promise请求处理完毕，并将处理结果传给回调函数（successCallback），示例如下：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5、Deferred-reject-msg-通知promise请求出现异常，将异常信息传给回调函数（errorCallback），示例如下："><span class="toc-number">3.0.5.</span> <span class="toc-text">5、Deferred.reject(msg) 通知promise请求出现异常，将异常信息传给回调函数（errorCallback），示例如下：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6、Deferred-notify-value-内部执行有变化时，对外发起通知。将会在Promise-finally中捕获到"><span class="toc-number">3.0.6.</span> <span class="toc-text">6、Deferred.notify(value) 内部执行有变化时，对外发起通知。将会在Promise.finally中捕获到</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7、-q-when-val-fn-将任意对象-函数包装成promise，返回包装好的promise。"><span class="toc-number">3.0.7.</span> <span class="toc-text">7、$q.when(val/fn) 将任意对象/函数包装成promise，返回包装好的promise。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8、-q-all-promises-then-当所有的promise都成功解析后，流程才继续往下走。示例如下"><span class="toc-number">3.0.8.</span> <span class="toc-text">8、$q.all(promises).then() 当所有的promise都成功解析后，流程才继续往下走。示例如下:</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3、-q的使用"><span class="toc-number">4.</span> <span class="toc-text">3、$q的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4、-q源码分解"><span class="toc-number">5.</span> <span class="toc-text">4、$q源码分解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5、-了解更多"><span class="toc-number">6.</span> <span class="toc-text">5、 了解更多</span></a></li></ol></div><h2 id="0、什么的Promise"><a href="#0、什么的Promise" class="headerlink" title="0、什么的Promise"></a>0、什么的Promise</h2><p>Promise（承诺）是用于改善异步编程体验的一种编程模型，它提供了一些列的API的方法论，让你能更优雅的解决异步编程中出现的一些问题。</p>
<h2 id="1、Promise的核心竞争力"><a href="#1、Promise的核心竞争力" class="headerlink" title="1、Promise的核心竞争力"></a>1、Promise的核心竞争力</h2><p>在处理有依赖性的回调的时候，我们的代码是这样写的：</p>
<pre><code>step1(function (value1) {
    step2(value1, function(value2) {
        step3(value2, function(value3) {
            step4(value3, function(value4) {
                // Do something with value4
            });
        });
    });
});
</code></pre><p>这就是我们所谓的回调地狱。</p>
<p>如果用Promise的方式来实现，是怎么样呢？</p>
<pre><code>step1().then(step2).then(step3).then(step4)
</code></pre><p>代码更简单逻辑也清晰，异步的回调嵌套变成了同步写法，孰优孰劣相信大家都一目了然。</p>
<h2 id="2、Angular服务-q"><a href="#2、Angular服务-q" class="headerlink" title="2、Angular服务$q"></a>2、Angular服务$q</h2><p>在angular中，基于nodejs中流行的Q提供了一个简化版本的Q,对外的话提供一个service $q。</p>
<p>以下列举出angular中的$q提供的API</p>
<h4 id="1、Promise-then-将回调变成链式调用，then可以接两个参数，successCallback-errorCallback-示例如下："><a href="#1、Promise-then-将回调变成链式调用，then可以接两个参数，successCallback-errorCallback-示例如下：" class="headerlink" title="1、Promise.then() 将回调变成链式调用，then可以接两个参数，successCallback, errorCallback,示例如下："></a>1、Promise.then() 将回调变成链式调用，then可以接两个参数，successCallback, errorCallback,示例如下：</h4><pre><code>var deferred = $q.defer();
var promise = deferred.promise;
promise.then(successCallback, errorCallback);
</code></pre><h4 id="2、Promise-catch-捕获Promise异常，Promise-catch-errorCallback-等价于Promise-then-null-errorCallback"><a href="#2、Promise-catch-捕获Promise异常，Promise-catch-errorCallback-等价于Promise-then-null-errorCallback" class="headerlink" title="2、Promise.catch 捕获Promise异常，Promise.catch(errorCallback)等价于Promise.then(null, errorCallback)"></a>2、Promise.catch 捕获Promise异常，Promise.catch(errorCallback)等价于Promise.then(null, errorCallback)</h4><h4 id="3、Promise-finally-callback-notifyCallback-promise结束后要做的事情和接收通知信息"><a href="#3、Promise-finally-callback-notifyCallback-promise结束后要做的事情和接收通知信息" class="headerlink" title="3、Promise.finally(callback, notifyCallback) promise结束后要做的事情和接收通知信息"></a>3、Promise.finally(callback, notifyCallback) promise结束后要做的事情和接收通知信息</h4><h4 id="4、Deferred-resolve-val-通知promise请求处理完毕，并将处理结果传给回调函数（successCallback），示例如下："><a href="#4、Deferred-resolve-val-通知promise请求处理完毕，并将处理结果传给回调函数（successCallback），示例如下：" class="headerlink" title="4、Deferred.resolve(val) 通知promise请求处理完毕，并将处理结果传给回调函数（successCallback），示例如下："></a>4、Deferred.resolve(val) 通知promise请求处理完毕，并将处理结果传给回调函数（successCallback），示例如下：</h4><pre><code>var deferred = $q.defer();
setTimeout(function(){
    deferred.resolve(&apos;abc&apos;); //会将abc传递给successCallback
}, 1000);
var promise = deferred.promise;
promise.then(successCallback, errorCallback);
</code></pre><h4 id="5、Deferred-reject-msg-通知promise请求出现异常，将异常信息传给回调函数（errorCallback），示例如下："><a href="#5、Deferred-reject-msg-通知promise请求出现异常，将异常信息传给回调函数（errorCallback），示例如下：" class="headerlink" title="5、Deferred.reject(msg) 通知promise请求出现异常，将异常信息传给回调函数（errorCallback），示例如下："></a>5、Deferred.reject(msg) 通知promise请求出现异常，将异常信息传给回调函数（errorCallback），示例如下：</h4><pre><code>var deferred = $q.defer();
setTimeout(function(){
    deferred.reject(&apos;abc&apos;); //会将abc传递给errorCallback
}, 1000);
var promise = deferred.promise;
promise.then(successCallback, errorCallback);
</code></pre><h4 id="6、Deferred-notify-value-内部执行有变化时，对外发起通知。将会在Promise-finally中捕获到"><a href="#6、Deferred-notify-value-内部执行有变化时，对外发起通知。将会在Promise-finally中捕获到" class="headerlink" title="6、Deferred.notify(value) 内部执行有变化时，对外发起通知。将会在Promise.finally中捕获到"></a>6、Deferred.notify(value) 内部执行有变化时，对外发起通知。将会在Promise.finally中捕获到</h4><pre><code>var deferred = $q.defer();
setTimeout(function(){
    deferred.reject(&apos;abc&apos;); //会将abc传递给errorCallback
}, 1000);
var promise = deferred.promise;
promise.then(successCallback, errorCallback);
</code></pre><h4 id="7、-q-when-val-fn-将任意对象-函数包装成promise，返回包装好的promise。"><a href="#7、-q-when-val-fn-将任意对象-函数包装成promise，返回包装好的promise。" class="headerlink" title="7、$q.when(val/fn) 将任意对象/函数包装成promise，返回包装好的promise。"></a>7、$q.when(val/fn) 将任意对象/函数包装成promise，返回包装好的promise。</h4><h4 id="8、-q-all-promises-then-当所有的promise都成功解析后，流程才继续往下走。示例如下"><a href="#8、-q-all-promises-then-当所有的promise都成功解析后，流程才继续往下走。示例如下" class="headerlink" title="8、$q.all(promises).then() 当所有的promise都成功解析后，流程才继续往下走。示例如下:"></a>8、$q.all(promises).then() 当所有的promise都成功解析后，流程才继续往下走。示例如下:</h4><pre><code>$q.all($http.get(&apos;xxx&apos;), $http.post(&apos;xxx&apos;,{}))
.then(successCallback, errorCallback);
</code></pre><h2 id="3、-q的使用"><a href="#3、-q的使用" class="headerlink" title="3、$q的使用"></a>3、$q的使用</h2><p>常规使用</p>
<pre><code>//定义开关变量
var canSuccess = false;
//定义一个Promise
var buildPromise = ()=&gt;{
  var deferred = $q.defer();
  setTimeout(()=&gt;{
    if(canSuccess){
      deferred.resolve(&apos;promise执行成功！&apos;)
    }else{
      deferred.reject(&apos;promise执行失败！&apos;)
    }
  },5000);
  return deferred.promise;
};

//使用它
var promise = buildPromise();
promise.then(()=&gt;{
  console.log(&apos;执行成功啦！&apos;);
}, ()=&gt;{
  console.log(&apos;执行失败了！&apos;);
})
</code></pre><p>使用$q.all</p>
<pre><code>var p1 = $http.get(&apos;xxxx&apos;);
var p2 = $http.get(&apos;xxxx2&apos;);
$q.all(p1, p2).then(() =&gt;{
  console.log(&apos;两次请求都成功了！&apos;);
});
</code></pre><h2 id="4、-q源码分解"><a href="#4、-q源码分解" class="headerlink" title="4、$q源码分解"></a>4、$q源码分解</h2><pre><code>//Deferred定义
function Deferred() {
  this.promise = new Promise();
  //Necessary to support unbound execution :/
  this.resolve = simpleBind(this, this.resolve);
  this.reject = simpleBind(this, this.reject);
  this.notify = simpleBind(this, this.notify);
}

//函数柯里化
function simpleBind(context, fn) {
  return function(value) {
    fn.call(context, value);
  };
}
</code></pre><p>通过这种方式，就能将resolve，reject和promise关联起来了。既然我们最终要返回promise，那我们来看已看Promise的实现：</p>
<pre><code>function Promise() {
  this.$$state = { status: 0 };
}

extend(Promise.prototype, {
  then: function(onFulfilled, onRejected, progressBack) {
    if (isUndefined(onFulfilled) &amp;&amp; isUndefined(onRejected) &amp;&amp; isUndefined(progressBack)) {
      return this;
    }
    var result = new Deferred();

    this.$$state.pending = this.$$state.pending || [];
    this.$$state.pending.push([result, onFulfilled, onRejected, progressBack]);
    if (this.$$state.status &gt; 0) scheduleProcessQueue(this.$$state);

    return result.promise;
  },

  &quot;catch&quot;: function(callback) {
    return this.then(null, callback);
  },

  &quot;finally&quot;: function(callback, progressBack) {
    return this.then(function(value) {
      return handleCallback(value, true, callback);
    }, function(error) {
      return handleCallback(error, false, callback);
    }, progressBack);
  }
});
</code></pre><p>从这里很明显可以看出，catch就是一个语法糖，调用的还是then。finally也是一个语法糖，就是不关成功，还是失败，都会调用callback。那这个时候，我们主要关注的方法就放到then这个方法的实现上。</p>
<p>为了实现链式调用，在then方法内部，又实例化了Deferred对象，并返回Defferrd.promise。</p>
<p>接下来就来看处理过程：</p>
<pre><code>this.$$state.pending = this.$$state.pending || [];
this.$$state.pending.push([result, onFulfilled, onRejected, progressBack]);
if (this.$$state.status &gt; 0) scheduleProcessQueue(this.$$state);

extend(Deferred.prototype, {
  resolve: function(val) {
    if (this.promise.$$state.status) return;
    if (val === this.promise) {
      this.$$reject($qMinErr(
        &apos;qcycle&apos;,
        &quot;Expected promise to be resolved with value other than itself &apos;{0}&apos;&quot;,
        val));
    } else {
      this.$$resolve(val);
    }

  },

  $$resolve: function(val) {
    var then, fns;

    fns = callOnce(this, this.$$resolve, this.$$reject);
    try {
      if ((isObject(val) || isFunction(val))) then = val &amp;&amp; val.then;
      if (isFunction(then)) {
        this.promise.$$state.status = -1;
        then.call(val, fns[0], fns[1], this.notify);
      } else {
        this.promise.$$state.value = val;
        this.promise.$$state.status = 1;
        scheduleProcessQueue(this.promise.$$state);
      }
    } catch (e) {
      fns[1](e);
      exceptionHandler(e);
    }
  },

  reject: function(reason) {
    if (this.promise.$$state.status) return;
    this.$$reject(reason);
  },

  $$reject: function(reason) {
    this.promise.$$state.value = reason;
    this.promise.$$state.status = 2;
    scheduleProcessQueue(this.promise.$$state);
  },

  notify: function(progress) {
    var callbacks = this.promise.$$state.pending;

    if ((this.promise.$$state.status &lt;= 0) &amp;&amp; callbacks &amp;&amp; callbacks.length) {
      nextTick(function() {
        var callback, result;
        for (var i = 0, ii = callbacks.length; i &lt; ii; i++) {
          result = callbacks[i][0];
          callback = callbacks[i][3];
          try {
            result.notify(isFunction(callback) ? callback(progress) : progress);
          } catch (e) {
            exceptionHandler(e);
          }
        }
      });
    }
  }
});
</code></pre><p>在调用then的时候，就将锅中回调写到$$state的pending数组中，让defferred.resolve的时候就会调用Deferred的内部方法，调用我们传递的回调函数。</p>
<p><strong>源码分解实在是说不明白，后期再发一篇如何实现一个简易的Promise，希望能更简洁易懂</strong></p>
<h2 id="5、-了解更多"><a href="#5、-了解更多" class="headerlink" title="5、 了解更多"></a>5、 了解更多</h2><p><a href="http://liubin.github.io/promises-book/" target="_blank" rel="external">JavaScript Promise迷你书（中文版）</a></p>
<p><a href="https://docs.angularjs.org/api/ng/service/$q" target="_blank" rel="external">Angular $q api</a></p>
<hr><section class="comment"><div class="ds-thread" data-thread-key="/blog/2017/02/21/Angular相关/详解angular之$q/" data-title="详解angular之$q" data-url="http://hstarorg.github.io/blog/blog/2017/02/21/Angular相关/详解angular之$q/"></div></section><script>var _shortName = "6389370154370729000";</script><script>var duoshuoQuery = {};
duoshuoQuery["short_name"] = _shortName;
(function() {
    var ds = document.createElement("script");
    ds.type = "text/javascript";
    ds.async = true;
    ds.src = (document.location.protocol === "https:" ? "https:" : "http:") + "//static.duoshuo.com/embed.js";
    ds.charset = "utf-8";
    (document.getElementsByTagName("head")[0] ||
        document.getElementsByTagName("body")[0]).appendChild(ds);
})();</script><footer><section class="copyright">&copy; 2016 - 2017<a href="/blog/">Jay.M.Hu</a></section><section class="intro">由<a href="https://hexo.io/">Hexo</a>驱动&middot;挂载<a href="https://github.com/xadillax/hexo-xnew">X'new</a>主题</section></footer></article></main><script src="//cdn.bootcss.com/Han/3.3.0/han.min.js"></script><script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script><script src="//cdn.bootcss.com/jquery-backstretch/2.0.4/jquery.backstretch.min.js"></script><script src="/blog/scripts/highlight.pack.js"></script><script>$(function() {
    $("header").backstretch("/images/header.jpeg");

    $("figure.highlight").each(function(i, block) {
        $(block).removeClass("highlight");
        $("<pre><code class='__tobehl " + ($(block).attr("class") === "plain" ? "" : ("lang-" + $(block).attr("class"))) + "'></code></pre>").insertAfter($(block));
        $(block).next().find("code").text((block.innerText || block.textContent));
        $(block).remove();
    });
    $(".__tobehl").each(function(i, block) {
        hljs.highlightBlock(block);
    });

    $("article.full img").each(function() {
        $(this).parent().css("text-align", "center");
    });

    if($(".article-toc").children().length < 2) {
        $(".article-toc").css("display", "none");
    }
});</script></body></html>