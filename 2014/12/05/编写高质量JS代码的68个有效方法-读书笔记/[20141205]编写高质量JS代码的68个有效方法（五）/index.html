<!DOCTYPE html><html class="han-init" lang="zh-Hant"><head><meta name="author" content="Jay.M.Hu"><meta name="description" itemprop="description" content="##No.21、使用apply方法通过不同数量的参数调用函数Tips：

使用apply方法自定一个可计算的参数数组来调用可变参数的函数
使用apply方法的第一个参数给可变参数的方法提供一个接收者
 //示例：计算给定数据的最大值 function getMaxNum(){
var max = a"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>编写高质量JS代码的68个有效方法（五） · Love life, love coding~</title><link rel="stylesheet" type="text/css" href="/blog/font/fantasque_sans_mono/stylesheet.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/webicons/2.0.0/webicons.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/Han/3.3.0/han.min.css"><link rel="stylesheet" type="text/css" href="/blog/styles/screen.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/highlight.js/9.9.0/styles/gruvbox-dark.min.css"></head><body><header><a href="/blog/"><img class="logo" src="https://avatars1.githubusercontent.com/u/4043284?v=3&amp;s=460" alt="幻☆精灵的Blog" title="幻☆精灵的Blog"></a><h1><a href="/blog/" alt="幻☆精灵的Blog" title="幻☆精灵的Blog">幻☆精灵的Blog</a></h1><p>Love life, love coding~</p><nav><ul><li><a href="/" alt="首页" title="首页">首页</a></li><li><a href="pigeonhole" alt="归档" title="归档">归档</a></li><li><a href="links" alt="链接" title="链接">链接</a></li><li><a href="about" alt="关于" title="关于">关于</a></li></ul><div class="xnews-icon"><a target="_blank" href="https://github.com/hstarorg" style="position: relative; top: -2px;">&#xe735;</a><a target="_blank" href="https://twitter.com/Hstar19">&#xe71f;</a><a target="_blank" href="https://www.facebook.com/100015363883648">&#xe60b;</a><a target="_blank" href="https://www.zhihu.com/people/hstar">&#xe63f;</a><a target="_blank" href="https://weibo.com/hstarorg" style="position: relative; top: -2px;">&#xe603;</a></div></nav><div class="space"></div></header><main><article class="full"><h1>编写高质量JS代码的68个有效方法（五）</h1><span class="post-meta">写于<time> 2014 年 12 月 05 日 00 时 00 分</time><br>更新于<time> 2017 年 02 月 21 日 13 时 59 分</time></span><div class="article-toc"><strong>大纲</strong></div><p>##No.21、使用apply方法通过不同数量的参数调用函数<br><strong>Tips：</strong></p>
<ol>
<li>使用apply方法自定一个可计算的参数数组来调用可变参数的函数</li>
<li><p>使用apply方法的第一个参数给可变参数的方法提供一个接收者</p>
<p> //示例：计算给定数据的最大值<br> function getMaxNum(){</p>
<pre><code>var max = arguments[0];
for(var i = 1, len = arguments.length;i &lt; len; i++){
    if(max &lt; arguments[i]){
        max = arguments[i];
    }
}
return max;
</code></pre><p> }<br> getMaxNum.apply(null,[1,3,4]);</p>
</li>
</ol>
<p><strong>该方法和call()方法功能基本类似，差别在于参数写法不一样。</strong></p>
<p>##No.22、使用arguments创建可变参数的函数<br><strong>Tips:</strong></p>
<ol>
<li>使用隐式的arguments对象实现可变参数的函数</li>
<li>考虑对可变参数的函数提供一个额外的固定元数的版本，从而使用者无需借助apply方法。</li>
</ol>
<p>每一个函数内部都有一个arguments对象包含所有传递的参数</p>
<pre><code>function fun1(){
    console.log(arguments);
}
fun1(&apos;1&apos;);
fun1(1,&apos;2&apos;,&apos;str&apos;);
</code></pre><p>##No.23、永远不要修改arguments的值<br><strong>Tips：</strong></p>
<ol>
<li>永远不要修改arguments的值</li>
<li>使用[].slice.call(arguments)将arguments对象赋值到一个真正的数组中再进行修改</li>
</ol>
<p>arguments看起来像是数组，但是它并不是标准的数组，所以不支持数组的原型方法</p>
<pre><code>function fun1(nums){
    var lastParam = arguments.pop(); //报错，undefined is not a function。
    console.log(arguments);
}

fun1([1, 2, 3]);
</code></pre><p>正确的做法是，将arguments转换为真正的数组，再进行操作，代码如下：</p>
<pre><code>function fun1(nums){
    var argArr = [].slice.call(arguments);
    var lastParam = argArr.pop();
    console.log(arguments);
}

fun1([1, 2, 3]);
</code></pre><p><strong>注意：永远不要修改arguments对象是更为安全的。</strong></p>
<p>##No.24、使用变量保存arguments的引用<br><strong>Tips：</strong></p>
<ol>
<li>当引用arguments时当心函数嵌套层级</li>
<li>绑定一个明确作用域的引用到arguments变量，从而可以再嵌套的函数中引用它</li>
</ol>
<p>首先，先来看一段代码的输出：</p>
<pre><code>function fun1(){
    var i = 0;
    console.log(arguments);
    return {
        next:function(){
            return arguments[i++]; 
        }
    }
}
var f = fun1(1,2,3,4);
console.log(f.next()); //猜猜是啥？
</code></pre><p>arguments是函数中的隐式变量，每个函数都会有这样的一个隐式对象。所以最后一个console的结果可想而知。所以遇到这种场景，是建议用变量保存arguments的引用，也能让嵌套函数正确的进行对象引用，正确代码如下：</p>
<pre><code>function fun1(){
    var i = 0;
    var args = arguments;
    return {
        next:function(){
            return args[i++]; 
        }
    }
}
var f = fun1(1,2,3,4);
console.log(f.next());
</code></pre><p>##No.25、使用bind方法提取具有确定接收者的方法<br><strong>Tips：</strong></p>
<ol>
<li>要注意，提取一个方法不会将方法的接收者绑定到该方法的对象上</li>
<li>当给高阶函数传递对象方法时，使用匿名函数在适当的接收者上调用该方法</li>
<li>使用bind方法创建绑定到适当接收者的函数</li>
</ol>
<p>老规矩，看代码：（代码1）</p>
<pre><code>var buffer = {
    entries: [],
    add: function(value){
        this.entries.push(value);
    },
    concat: function(){
        return this.entries.join(&apos;&apos;);
    }
};
</code></pre><p>该代码在直接使用时是没有问题的，思考下，由于高阶函数将函数/方法作为变量传递，那么可以有如下用法：（代码2）</p>
<pre><code>var arr = [&apos;Jay&apos;, &apos;.M&apos;, &apos;.Hu&apos;];
arr.forEach(buffer.add);
console.log(buffer.concat()); //思考下这个结果是什么？
</code></pre><p>以上代码在arr.forEach处已经报错，Cannot read property ‘push’ of undefined。因为这个时候的涉及到this的指向问题。我们可以改造下buffer代码，输出this让我们看看：（代码3）</p>
<pre><code>var buffer = {
    entries: [],
    add: function(value){
        console.log(this);
        this.entries.push(value);
    },
    concat: function(){
        return this.entries.join(&apos;&apos;);
    }
};
</code></pre><p>从输出结果我们可以看到这个this，在（代码2）的执行环境中，指向的是window对象，所以导致了报错，那么如何避免这样的问题呢？针对forEach，我们有三个方法：(代码4)</p>
<pre><code>//方式一，去掉this，直接用buffer对象引用
var buffer = {
    entries: [],
    add: function(value){
        buffer.entries.push(value);
    },
    concat: function(){
        return buffer.entries.join(&apos;&apos;);
    }
};

//方式二，指定接收者，forEach方法提供，其他方法不一定提供
var arr = [&apos;Jay&apos;, &apos;.M&apos;, &apos;.Hu&apos;];
arr.forEach(buffer.add, buffer);
console.log(buffer.concat());

//方式三，通过用函数包装调用，来实现指定接收者
var arr = [&apos;Jay&apos;, &apos;.M&apos;, &apos;.Hu&apos;];
arr.forEach(function(s){
    buffer.add(s);
});
console.log(buffer.concat());
</code></pre><p>针对这样的问题，ES5标准库中提供了一个bind()函数来实现这样的方法。只需要如下代码：</p>
<pre><code>var arr = [&apos;Jay&apos;, &apos;.M&apos;, &apos;.Hu&apos;];
arr.forEach(buffer.add.bind(buffer));
console.log(buffer.concat());
</code></pre><p>该bind()函数，利用buffer.add.bind(buffer)创建了一个新函数而不是修改了buffer.add函数。新函数行为就像原来函数的行为，但它的接收者被重新指定了。所以调用bind方法是安全的，即使是一个可能在程序的其他部分被共享的函数。</p>
<hr><section class="comment"><div class="ds-thread" data-thread-key="/blog/2014/12/05/编写高质量JS代码的68个有效方法-读书笔记/[20141205]编写高质量JS代码的68个有效方法（五）/" data-title="编写高质量JS代码的68个有效方法（五）" data-url="http://hstarorg.github.io/blog/blog/2014/12/05/编写高质量JS代码的68个有效方法-读书笔记/[20141205]编写高质量JS代码的68个有效方法（五）/"></div></section><script>var _shortName = "6389370154370729000";</script><script>var duoshuoQuery = {};
duoshuoQuery["short_name"] = _shortName;
(function() {
    var ds = document.createElement("script");
    ds.type = "text/javascript";
    ds.async = true;
    ds.src = (document.location.protocol === "https:" ? "https:" : "http:") + "//static.duoshuo.com/embed.js";
    ds.charset = "utf-8";
    (document.getElementsByTagName("head")[0] ||
        document.getElementsByTagName("body")[0]).appendChild(ds);
})();</script><footer><section class="copyright">&copy; 2016 - 2017<a href="/blog/">Jay.M.Hu</a></section><section class="intro">由<a href="https://hexo.io/">Hexo</a>驱动&middot;挂载<a href="https://github.com/xadillax/hexo-xnew">X'new</a>主题</section></footer></article></main><script src="//cdn.bootcss.com/Han/3.3.0/han.min.js"></script><script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script><script src="//cdn.bootcss.com/jquery-backstretch/2.0.4/jquery.backstretch.min.js"></script><script src="/blog/scripts/highlight.pack.js"></script><script>$(function() {
    $("header").backstretch("/images/header.jpeg");

    $("figure.highlight").each(function(i, block) {
        $(block).removeClass("highlight");
        $("<pre><code class='__tobehl " + ($(block).attr("class") === "plain" ? "" : ("lang-" + $(block).attr("class"))) + "'></code></pre>").insertAfter($(block));
        $(block).next().find("code").text((block.innerText || block.textContent));
        $(block).remove();
    });
    $(".__tobehl").each(function(i, block) {
        hljs.highlightBlock(block);
    });

    $("article.full img").each(function() {
        $(this).parent().css("text-align", "center");
    });

    if($(".article-toc").children().length < 2) {
        $(".article-toc").css("display", "none");
    }
});</script></body></html>