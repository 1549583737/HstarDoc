<!DOCTYPE html><html class="han-init" lang="zh-Hant"><head><meta name="author" content="Jay.M.Hu"><meta name="description" itemprop="description" content="##No.51、在类数组对象上附庸通用的数组方法Tips:

对于类数组对象，通过提取方法对象并使用其call方法来复用通用的Array方法
任意一个具有索引属性和恰当length属性的对象都可以使用通用的Array方法

Array.proteotype中的标准方法被设计成其他对象可复用的方法，即"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>编写高质量JS代码的68个有效方法（十一） · Love life, love coding~</title><link rel="stylesheet" type="text/css" href="/blog/font/fantasque_sans_mono/stylesheet.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/webicons/2.0.0/webicons.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/Han/3.3.0/han.min.css"><link rel="stylesheet" type="text/css" href="/blog/styles/screen.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/highlight.js/9.9.0/styles/gruvbox-dark.min.css"></head><body><header><a href="/blog/"><img class="logo" src="https://avatars1.githubusercontent.com/u/4043284?v=3&amp;s=460" alt="幻☆精灵的Blog" title="幻☆精灵的Blog"></a><h1><a href="/blog/" alt="幻☆精灵的Blog" title="幻☆精灵的Blog">幻☆精灵的Blog</a></h1><p>Love life, love coding~</p><nav><ul><li><a href="/" alt="首页" title="首页">首页</a></li><li><a href="pigeonhole" alt="归档" title="归档">归档</a></li><li><a href="links" alt="链接" title="链接">链接</a></li><li><a href="about" alt="关于" title="关于">关于</a></li></ul><div class="xnews-icon"><a target="_blank" href="https://github.com/hstarorg" style="position: relative; top: -2px;">&#xe735;</a><a target="_blank" href="https://twitter.com/Hstar19">&#xe71f;</a><a target="_blank" href="https://www.facebook.com/100015363883648">&#xe60b;</a><a target="_blank" href="https://www.zhihu.com/people/hstar">&#xe63f;</a><a target="_blank" href="https://weibo.com/hstarorg" style="position: relative; top: -2px;">&#xe603;</a></div></nav><div class="space"></div></header><main><article class="full"><h1>编写高质量JS代码的68个有效方法（十一）</h1><span class="post-meta">写于<time> 2015 年 02 月 14 日 00 时 00 分</time><br>更新于<time> 2017 年 02 月 21 日 13 时 59 分</time></span><div class="article-toc"><strong>大纲</strong></div><p>##No.51、在类数组对象上附庸通用的数组方法<br><strong>Tips:</strong></p>
<ol>
<li>对于类数组对象，通过提取方法对象并使用其call方法来复用通用的Array方法</li>
<li>任意一个具有索引属性和恰当length属性的对象都可以使用通用的Array方法</li>
</ol>
<p>Array.proteotype中的标准方法被设计成其他对象可复用的方法，即使这些对象没有继承Array。很实际的一个例子就是 <code>arguments</code> ,示例如下：</p>
<pre><code>//define
function fun(){
  console.log(arguments);  // [1, 2, 3]
  console.log(arguments instanceof Array) // false
  arguments.forEach(function(argv){  //TypeError
    console.log(argv)
  });
}

//call
fun(1, 2, 3);
</code></pre><p>从结果来看，输出arguments和数组非常相似，通过instanceof来看，确实不是数组，所以arguments是类数组对象，但是在执行forEach的时候却TypeError。why？</p>
<p>因为 <code>arguments</code> 没有继承Array.prototype,所以并不能直接调用forEach方法，但是可以提取forEach方法的引用并使用其call来调用，代码如下：</p>
<pre><code>//define
function fun(){
  [].forEach.call(arguments, function(argv){
    console.log(argv);
  });
}

//call
fun(1, 2, 3);
</code></pre><p>除了arguments之外，dom的NodeList也是类数组对象：</p>
<pre><code>var nodes = document.getElementsByTagName(&apos;a&apos;);
console.log(nodes);
console.log(nodes instanceof Array); // false
</code></pre><p>那么，到底怎样使得一个对象“看起来像数组”呢？有以下两个规则：</p>
<ol>
<li>具有一个范围在0到2^32 - 1 的整型length属性</li>
<li>length属性大于该对象的最大索引。索引是一个范围在0到2^32 -2 的整数，它的字符串表示的是该对象的一个key。</li>
</ol>
<p>鉴于以上规则，那么我们可以自己创建类数组对象：</p>
<pre><code>var arrayLike = {0: &apos;a&apos;, 1: &apos;b&apos;, 2: &apos;c&apos;, length: 3};
var result = [].map.call(arrayLike, function(el){
  return el.toUpperCase();
});
console.log(result); // [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]
</code></pre><p>特例，数组连接方法concat不是完全通用的。因为它会检查对象的[[Class]]属性，要想连接类数组对象，我们就需要先将类数组处理为数组：</p>
<pre><code>var arrLike = {0: &apos;a&apos;, length: 1};
var arr = [].slice.call(arrLike);
console.log([&apos;A&apos;].concat(arr)); // [&apos;A&apos;, &apos;a&apos;]
</code></pre><p>##No.52、数组字面量优于数组构造函数<br><strong>Tips:</strong></p>
<ol>
<li>如果数组构造函数的第一个参数是数字则数组的构造函数行为是不同的</li>
<li>使用数组字面量替代数组构造函数</li>
</ol>
<p>原因如下：</p>
<p><strong>[] 比 new Array简洁</strong></p>
<pre><code>var arr = [];
var arr = new Array();
</code></pre><p><strong>使用new Array()，必须要确保没有人重新包转过Array变量</strong></p>
<pre><code>funciton f(Array){
    return new Array(1, 2, 3, 4, 5);
}
f(String); //new String(1)
</code></pre><p><strong>使用new Array()，必须要确保没有人修改过全局的Array变量</strong></p>
<pre><code>Array = String
new Array(1, 2, 3); // new String(1)
</code></pre><p><strong>使用new Array时，由于第一个参数类型不同，会导致二义性</strong></p>
<pre><code>new Array(&apos;hello&apos;) 和 [&apos;hello&apos;] 等价
[1] 和 new Array(1) 不等价，前者创建包含元素的1的数组，后则创建长度为1的数组。
</code></pre><p><strong>所以，优先使用字面量，因为数组字面量具有更规范、更一致的语义。</strong></p>
<p>##No.53、保持一致的约定<br><strong>Tips：</strong></p>
<ol>
<li>在变量命名和函数签名中使用一致的约定</li>
<li>不要偏离用户在他们的开发平台中很可能遇到的约定</li>
</ol>
<p>有良好的编码习惯，使用业界常规的编码规范，同时注意参数的顺序等。一句话概述：<strong>保持代码的一致性</strong>。</p>
<p>##No.54、将undefined看做“没有值”<br><strong>Tips：</strong></p>
<ol>
<li>避免使用undefined表示任何非特定值</li>
<li>使用描述性的字符串值或命名布尔属性的对象，而不要使用undefined 或 null来代表特定应用标志</li>
<li>提供参数默认值应该采用测试undefined的方式，而不是检查arguments.length。</li>
<li>在允许0、NaN或空字符串为有效参数的地方，绝不要通过真值测试来实现参数默认值。</li>
</ol>
<p>undefined很特殊，当JavaScript无法提供具体的值时没救产生undefined。<br>如只定义变量，不赋值；或者是对象中不存在属性；再者，函数无return语句都会产生undefined。</p>
<pre><code>var x;
console.log(x); //undefined
var o = {};
console.log(o.p1); //undefined
function fun(){

}
console.log(fun()); //undefined
</code></pre><p>未给函数参数提供实参则该函数参数值为undefined</p>
<pre><code>function fun(x){
    return x;
}
console.log(fun()); //undefined
</code></pre><p>将undefined看做缺少某个特定的值是公约。将它用于其他目的具有很高的风险：</p>
<pre><code>//假设highlight为设置元素高亮
element.highlight(&apos;yellow&apos;); //设置为黄色

//如果要设置为随机颜色
//方式一、如果遇到undefined则设置为随机
element.highlight(undefined);

//这样的方式通常会产生歧义
element.highlight(config.highlightColor);
//使用如上语句时，我们的期望一般是没有提供配置则使用默认色，但是由于undefined代表随机，那么破坏了这种常规思维。让代码变得难以理解。

//更好的做法
element.highlight(&apos;random&apos;);
//或者是
element.highlight({random: true});
</code></pre><p>另一个提防undefined的地方是可选参数的实现。</p>
<pre><code>function fun(a, b){
  if(arguments.length &lt; 2){
    b = &apos;xx&apos;;
  }
}
</code></pre><p>如果使用 fun(a);调用，基本符合预期；但是如果使用fun(a, ‘undefind’);则不会执行if之内的语句，导致结果错误，如果测试是否为undefined有助于打造更为健壮的API。</p>
<p>针对可选参数这个问题，另外一个合理的替代方案是：</p>
<pre><code>function fun(a, b){
  b = b || &apos;xxx&apos;;
}
</code></pre><p>但是要注意，真值测试并不总是安全的。如果一个函数应该接受空字符串，0，NaN为合法值，那么真值测试就不该使用了。</p>
<pre><code>//Bad Use
function Point(x, y){
  this.x = x || 200;
  this.y = y || 200;
}
</code></pre><p>以上代码有什么问题呢，因为使用 new Point(0, 0);会导致使用默认值，这样就偏离了预期。所以需要更严格的测试：</p>
<pre><code>function Point(x, y){
  this.x = x === undefined ? 200 : x;
  this.y = y === undefined ? 200 : y;
}
</code></pre><p>##No.55、接收关键字参数的选项对象<br><strong>Tips：</strong></p>
<ol>
<li>使用选项对象似的API更具可读性、更容易记忆</li>
<li>所有通过选项对象提供的参数应当被视为可选的</li>
<li>使用extend函数抽象出从选项对象中提取值的逻辑</li>
</ol>
<p>首先来看一个复杂的函数调用：</p>
<pre><code>fun(200, 200, &apos;action&apos;, &apos;green&apos;, true);
</code></pre><p>一眼望去，完全不知所云。在体会到C#的可选参数的便利性的时候，肯定会想JavaScript要是有这样的用法就好了。</p>
<p>幸运的是，JavaScript提供了一个简单、轻量的惯用法：选项对象。基本达到了可选参数的效果。</p>
<pre><code>fun({
  width: 200,
  height: 200,
  action: &apos;action&apos;,
  color: &apos;green&apos;,
  ignoreError: true
});
</code></pre><p>相对来说，更繁琐一点，但是更易于阅读。另外一个好处就是，参数都是可选的。</p>
<p>如果有必选参数，那么在设计API的时候。建议将它们独立于选项之外，其他语言也可借鉴这种思路。</p>
<pre><code>// options 为可选参数
function fun(width, height, options){
}
</code></pre><p>通过extend组合可选参数和默认参数，可以让函数变得简洁和健壮。</p>
<pre><code>function fun(width, height, options){
  var defaults = {
    color: &apos;green&apos;,
    ignoreError: false,
    action: &apos;&apos;
  }
  //$.extend 可以理解为jQuery的方法
  options = $.extend({}, defaults, options);
  //do something...
}
</code></pre><hr><section class="comment"><div class="ds-thread" data-thread-key="/blog/2015/02/14/编写高质量JS代码的68个有效方法-读书笔记/[20150214]编写高质量JS代码的68个有效方法（十一）/" data-title="编写高质量JS代码的68个有效方法（十一）" data-url="http://hstarorg.github.io/blog/blog/2015/02/14/编写高质量JS代码的68个有效方法-读书笔记/[20150214]编写高质量JS代码的68个有效方法（十一）/"></div></section><script>var _shortName = "6389370154370729000";</script><script>var duoshuoQuery = {};
duoshuoQuery["short_name"] = _shortName;
(function() {
    var ds = document.createElement("script");
    ds.type = "text/javascript";
    ds.async = true;
    ds.src = (document.location.protocol === "https:" ? "https:" : "http:") + "//static.duoshuo.com/embed.js";
    ds.charset = "utf-8";
    (document.getElementsByTagName("head")[0] ||
        document.getElementsByTagName("body")[0]).appendChild(ds);
})();</script><footer><section class="copyright">&copy; 2016 - 2017<a href="/blog/">Jay.M.Hu</a></section><section class="intro">由<a href="https://hexo.io/">Hexo</a>驱动&middot;挂载<a href="https://github.com/xadillax/hexo-xnew">X'new</a>主题</section></footer></article></main><script src="//cdn.bootcss.com/Han/3.3.0/han.min.js"></script><script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script><script src="//cdn.bootcss.com/jquery-backstretch/2.0.4/jquery.backstretch.min.js"></script><script src="/blog/scripts/highlight.pack.js"></script><script>$(function() {
    $("header").backstretch("/images/header.jpeg");

    $("figure.highlight").each(function(i, block) {
        $(block).removeClass("highlight");
        $("<pre><code class='__tobehl " + ($(block).attr("class") === "plain" ? "" : ("lang-" + $(block).attr("class"))) + "'></code></pre>").insertAfter($(block));
        $(block).next().find("code").text((block.innerText || block.textContent));
        $(block).remove();
    });
    $(".__tobehl").each(function(i, block) {
        hljs.highlightBlock(block);
    });

    $("article.full img").each(function() {
        $(this).parent().css("text-align", "center");
    });

    if($(".article-toc").children().length < 2) {
        $(".article-toc").css("display", "none");
    }
});</script></body></html>