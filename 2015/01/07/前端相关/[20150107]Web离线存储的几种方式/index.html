<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  
  <title>Web离线存储的几种方式 | 幻☆精灵的Blog</title>
  <meta name="description" content="幻☆精灵的Blog站点" />
  <meta name="keywords" content="幻精灵" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <link rel="shortcut icon" href="/blog/images/favicon.ico">
  <link rel="alternate" href="/blog/atom.xml" title="幻☆精灵的Blog">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="随着HTML5的正式定稿，我们也可以大量使用HTML离线网络应用程序的特性。
#1、Application CacheApplication Cache 可以很简单让我们的WebApp具有离线的能力。
支持的浏览器：IE10+，FireFox，Chrome，Safari，Opera
优点：

离线浏览 – 用户可以再离线时使用Application
速度 – 由于缓存了资源，如果加载很快
减少服务">
<meta property="og:type" content="article">
<meta property="og:title" content="Web离线存储的几种方式">
<meta property="og:url" content="http://hstarorg.github.io/blog/2015/01/07/前端相关/[20150107]Web离线存储的几种方式/index.html">
<meta property="og:site_name" content="幻☆精灵的Blog">
<meta property="og:description" content="随着HTML5的正式定稿，我们也可以大量使用HTML离线网络应用程序的特性。
#1、Application CacheApplication Cache 可以很简单让我们的WebApp具有离线的能力。
支持的浏览器：IE10+，FireFox，Chrome，Safari，Opera
优点：

离线浏览 – 用户可以再离线时使用Application
速度 – 由于缓存了资源，如果加载很快
减少服务">
<meta property="og:updated_time" content="2017-02-21T07:07:32.734Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Web离线存储的几种方式">
<meta name="twitter:description" content="随着HTML5的正式定稿，我们也可以大量使用HTML离线网络应用程序的特性。
#1、Application CacheApplication Cache 可以很简单让我们的WebApp具有离线的能力。
支持的浏览器：IE10+，FireFox，Chrome，Safari，Opera
优点：

离线浏览 – 用户可以再离线时使用Application
速度 – 由于缓存了资源，如果加载很快
减少服务">
    
  <link href="https://fonts.googleapis.com/css?family=Inconsolata|Titillium+Web" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css?family=Roboto+Mono" rel="stylesheet">
  <link href='//cdn.bootcss.com/node-waves/0.7.5/waves.min.css' rel='stylesheet'>
  <link rel="stylesheet" href="/blog/style.css">
  
  

  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>
</head>

<body>
  <div id="loading-bar-wrapper">
  <div id="loading-bar"></div>
</div>


  <script>setLoadingBarProgress(20)</script> 
  <header class="l_header">
		<div class="wrapper container">
			<a class="logo flat-box" href='/blog/' >
				幻☆精灵的Blog
			</a>
			<div class='menu'>
				<ul class='h-list'>
					
						<li>
							<a class='flat-box nav-home' href='/blog/'>
								首页
							</a>
						</li>
					
						<li>
							<a class='flat-box nav-archives' href='/blog/archives'>
								归档
							</a>
						</li>
					
						<li>
							<a class='flat-box nav-about' href='/blog/about'>
								关于我
							</a>
						</li>
					
				</ul>
				<div class='underline'></div>
			</div>
			
				<div class="m_search">
					<form name="searchform" class="form u-search-form">
						<input type="text" class="input u-search-input" placeholder="Search" />
						<span class="icon icon-search"></span>
					</form>
				</div>
			
			<ul class='switcher h-list'>
				
					<li class='s-search'><a href='javascript:void(0)'><span class="icon icon-search"></span></a></li>
				
				<li class='s-menu'><a href='javascript:void(0)'><span class="icon icon-menu"></span></a></li>
			</ul>
		</div>
		<aside class="menu-phone">
			<nav>
				
					<a href="/blog/" class="nav-home nav">
						首页
					</a>
				
					<a href="/blog/archives" class="nav-archives nav">
						归档
					</a>
				
					<a href="/blog/about" class="nav-about nav">
						关于我
					</a>
				
			</nav>
		</aside>
</header>

    <script>setLoadingBarProgress(40);</script>
  <div class="l_body">
    <div class='container'>
      <div class='l_main'>
        <article id="post-前端相关/[20150107]Web离线存储的几种方式"
  class="post white-box article-type-post"
  itemscope itemprop="blogPost">
	<section class='meta'>
	<h2 class="title">
  	<a href="/blog/2015/01/07/前端相关/[20150107]Web离线存储的几种方式/">
    	Web离线存储的几种方式
    </a>
  </h2>
	<time>
	  Jan 7, 2015
	</time>
	
	</section>
	
		<section class="tog"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1、Application-Cache"><span class="toc-number">1.</span> <span class="toc-text">#1、Application Cache</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2、Local-Storage"><span class="toc-number">2.</span> <span class="toc-text">#2、Local Storage</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3、Web-SQL"><span class="toc-number">3.</span> <span class="toc-text">#3、Web SQL</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4、IndexedDB"><span class="toc-number">4.</span> <span class="toc-text">#4、IndexedDB</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#其他"><span class="toc-number">5.</span> <span class="toc-text">其他</span></a></li></ol></section>
	
	<section class="article typo">
  	<div class="article-entry" itemprop="articleBody">
    	<p>随着HTML5的正式定稿，我们也可以大量使用HTML离线网络应用程序的特性。</p>
<h1 id="1、Application-Cache"><a href="#1、Application-Cache" class="headerlink" title="#1、Application Cache"></a>#1、Application Cache</h1><p><a href="http://www.w3schools.com/html/html5_app_cache.asp" target="_blank" rel="external">Application Cache</a> 可以很简单让我们的WebApp具有离线的能力。</p>
<p><strong>支持的浏览器：</strong>IE10+，FireFox，Chrome，Safari，Opera</p>
<p><strong>优点：</strong></p>
<ol>
<li>离线浏览 – 用户可以再离线时使用Application</li>
<li>速度 – 由于缓存了资源，如果加载很快</li>
<li>减少服务端数据加载 – 浏览器只需要从服务器加载更新过的数据</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li>Manifest文件有变化时才更新</li>
<li>一次必须更新Manifest中的所有文件，下次才生效</li>
</ol>
<p><strong>如何使用？</strong></p>
<p>Step1:在html上指定manifest文件 (index.html)</p>
<pre><code>&lt;html manifest=&quot;appCacheList.manifest&quot;&gt;
&lt;/html&gt;
</code></pre><p>Step2:设定manifest文件内容 (appCache.manifest)</p>
<pre><code>CACHE MANIFEST

# 离线缓存的内容
./all.css
./1.jpg
./index.js

# NETWORK:*，表示其他内容从网络获取
NETWORK:
*

# 第一个uri是资源，第二个是fallback
FALLBACK:
/html/ /offline.html
</code></pre><p>手动更新缓存：</p>
<pre><code>if ( window.applicationCache.status == window.applicationCache.UPDATEREADY ){
    window.applicationCache.update();
}
</code></pre><p><strong>注意：</strong></p>
<ol>
<li>不同的浏览器对Application Cache的大小不一致，请注意。</li>
<li>更多细节可参考<a href="http://kayosite.com/web-app-by-jquery-mobile-and-html5-offline-web-applications.html" target="_blank" rel="external">http://kayosite.com/web-app-by-jquery-mobile-and-html5-offline-web-applications.html</a></li>
</ol>
<h1 id="2、Local-Storage"><a href="#2、Local-Storage" class="headerlink" title="#2、Local Storage"></a>#2、Local Storage</h1><p><a href="http://www.w3schools.com/html/html5_webstorage.asp" target="_blank" rel="external">Local Storage</a>使得我们可以在浏览器中保存数据。</p>
<p><strong>支持的浏览器：</strong>IE10+，FireFox，Chrome，Safari，Opera</p>
<p><strong>优点：</strong></p>
<ol>
<li>容量大</li>
<li>易用</li>
<li>强大</li>
<li>原生支持</li>
<li>仅存在本地，不会与服务器发生交互</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li>浏览器兼容性差</li>
<li>安全性差（不要存储敏感数据）</li>
</ol>
<p><strong>如何使用？</strong></p>
<p>首先通过 <code>window.localStorage</code> 来判断浏览器是否支持Local Storage。然后由于该方式具有浏览器兼容性，建议用一个通用的库，来屏蔽兼容性。</p>
<pre><code>// 对基本方法的封装，需要判断浏览器，屏蔽它们的细节差异。
(function(window){
  if(!window.localStorage){
    throw new Error(&apos;Your brower can\&apos;t support local storage!&apos;);
  }
  var ls = window.localStorage;
  var localStorageKit = {
    getLength: function(){
      return ls.length;
    },
    clear: function(){
      ls.clear();
      return true;
    },
    set: function(k, v){
      ls.setItem(k, v);
    },
    get: function(k){
      return ls.getItem(k);
    },
    remove: function(k){
      ls.removeItem(k);
    },
    getKeyByIndex: function(index){
      return ls.key(index);
    }
  };
  window.lsKit = localStorageKit;
})(window);
</code></pre><p>基本操作方式与cookie无太多差异。</p>
<p><strong>Session Storage：</strong><br>Session Storage和Local Storage非常类似，操作方式也一致。由于其中保存的存只是当前会话有效，那么此处就不细说。</p>
<h1 id="3、Web-SQL"><a href="#3、Web-SQL" class="headerlink" title="#3、Web SQL"></a>#3、Web SQL</h1><p><a href="http://en.wikipedia.org/wiki/Web_SQL_Database" target="_blank" rel="external">Web Sql Database</a>，是html5环境下可以用js执行CRUD的web数据库。数据库核心是SQLite。</p>
<p><strong>优点：</strong></p>
<ol>
<li>本地数据库</li>
<li>可以处理复杂的关系型数据</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li>暂时只有chrome才支持，对于Android大行其道的移动端，这应该是可以避免的缺点(貌似最新版本的Opera和Safari也支持了)</li>
</ol>
<p><strong>如何使用？</strong></p>
<p>首先，先介绍Web sql的三个核心方法：</p>
<ol>
<li>openDatabase：这个方法使用现有数据库或创建新数据库创建数据库对象。</li>
<li>transaction：这个方法允许我们根据情况控制事务提交或回滚。</li>
<li><p>executeSql：这个方法用于执行真实的SQL查询。</p>
<p> var db = openDatabase(‘mydb’, ‘1.0’, ‘Test DB’, 2 <em> 1024 </em> 1024);<br> var msg;<br> db.transaction(function (tx) {<br>   tx.executeSql(‘CREATE TABLE IF NOT EXISTS LOGS (id unique, log)’);<br>   tx.executeSql(‘INSERT INTO LOGS (id, log) VALUES (1, “foobar”)’);<br>   tx.executeSql(‘INSERT INTO LOGS (id, log) VALUES (2, “logmsg”)’);<br>   console.log(‘Log message created and row inserted.’);<br> });<br> db.transaction(function (tx) {<br>   tx.executeSql(‘SELECT * FROM LOGS’, [], function (tx, results) {</p>
<pre><code>var len = results.rows.length, i;
console.log(&apos;Found rows: &apos; + len);
for (i = 0; i &lt; len; i++){
  console.log(results.rows.item(i).log)
}
</code></pre><p>   }, null);<br> });</p>
</li>
</ol>
<p>当成数据库用，就行。</p>
<h1 id="4、IndexedDB"><a href="#4、IndexedDB" class="headerlink" title="#4、IndexedDB"></a>#4、IndexedDB</h1><p><a href="http://www.w3.org/TR/IndexedDB/" target="_blank" rel="external">IndexedDB</a>是结构化的本地数据存储。是基于平面文件的数据库，采用了分层的键值存储和基本的索引。</p>
<p><strong>优点：</strong></p>
<ol>
<li>标准化</li>
<li>存储复杂数据</li>
<li>支持索引</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li>不支持SQL</li>
<li>相对来说，操作较复杂</li>
</ol>
<p><strong>如何使用？</strong></p>
<pre><code>// 打开数据库，第一个参数为数据库名，第二个为数据库版本号
var dbRequest = window.indexedDB.open(&apos;testDb&apos;, 2);

dbRequest.onupgradeneeded=function(e){
    // 创建数据仓库
    var db=e.target.result;
    if(!db.objectStoreNames.contains(&apos;users&apos;)){
        var store=db.createObjectStore(&apos;users&apos;,{keyPath: &apos;id&apos;});
        store.createIndex(&apos;nameIndex&apos;,&apos;name&apos;,{unique:true}); 
        store.createIndex(&apos;ageIndex&apos;,&apos;age&apos;,{unique:false}); 
    }
    console.log(&apos;upgrade successfully!&apos;);
};

dbRequest.onsuccess = function(e){
  console.log(&apos;Open database successfully!&apos;);
  // 这里拿到了数据库
  var db = e.target.result;
  var storeName = &apos;users&apos;;
  // 写入数据
  var tran = db.transaction(storeName, &apos;readwrite&apos;);
  var users = tran.objectStore(storeName);
  for(var i = 0; i &lt; 5; i++){
    users.add({
      id: i,
      name: &apos;user&apos; + i,
      age: Math.floor(Math.random() * 10) + 18
    });
  }

  //查询数据
  var userStore = db.transaction(storeName).objectStore(storeName);
  var request = userStore.openCursor();
  request.onsuccess = function(e){
    var cursor = e.target.result;
    if(cursor){
      console.log(cursor.key);
      console.log(cursor.value);
      cursor.continue();
    }
  }
}
</code></pre><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p><a href="http://html5online.com.cn/articles/2012080901.html" target="_blank" rel="external">HTML 5中几种用于在客户端本地存储数据的API之间的比较</a></p>
<p><a href="http://www.cnblogs.com/dolphinX/p/3415761.html" target="_blank" rel="external">HTML5本地存储——IndexedDB（一：基本使用）</a></p>
<p><a href="http://www.cnblogs.com/dolphinX/p/3416889.html" target="_blank" rel="external">HTML5本地存储——IndexedDB（二：索引）</a></p>

  	</div>
	  
	</section>
	
</article>

      </div>
      <aside class='l_side'>
        
  <section class='m_widget about'>

<img class='avatar waves-image' src='https://avatars1.githubusercontent.com/u/4043284?v=3&amp;s=460' />

<div class='header'>Jay.M.Hu</div>
<div class='content'>
<div></div>
</div>
</section>

  <section class='m_widget friendly-links'>
<div class='header'>Links</div>
<div class='content'>
    <ul class="entry">
    
        <li><a class="flat-box" target="_blank" href="http://humin.cnblogs.com/">
            <div class='name'>幻天芒 - 博客园</div>
        </a></li>
    
    </ul>
</div>
</section>

  <section class='m_widget categories'>
<div class='header'>Categories</div>
<div class='content'>
    
</div>
</section>

  


      </aside>
      <script>setLoadingBarProgress(60);</script>
    </div>
  </div>
  <footer id="footer" class="clearfix">

	<div class="social-wrapper">
  	
      
        <a href="https://github.com/hstarorg" class="social github"
          target="_blank" rel="external">
          <span class="icon icon-github"></span>
        </a>
      
        <a href="/atom.xml" class="social rss"
          target="_blank" rel="external">
          <span class="icon icon-rss"></span>
        </a>
      
    
  </div>
  
  <div>Theme <a href='https://github.com/stkevintan/hexo-theme-material-flow' class="codename">MaterialFlow</a> designed by <a href="http://keyin.me/" target="_blank">Kevin Tan</a>.</div>
  
</footer>


  <script>setLoadingBarProgress(80);</script>
  

<script src="//apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
<script src='//cdn.bootcss.com/node-waves/0.7.5/waves.min.js'></script>
<script src="//cdn.bootcss.com/scrollReveal.js/3.3.2/scrollreveal.min.js"></script>
<script src="/blog/js/jquery.fitvids.js"></script>
<script>
	var GOOGLE_CUSTOM_SEARCH_API_KEY = "";
	var GOOGLE_CUSTOM_SEARCH_ENGINE_ID = "";
	var ALGOLIA_API_KEY = "";
	var ALGOLIA_APP_ID = "";
	var ALGOLIA_INDEX_NAME = "";
  var AZURE_SERVICE_NAME = "";
  var AZURE_INDEX_NAME = "";
  var AZURE_QUERY_KEY = "";
  var BAIDU_API_ID = "";
  var SEARCH_SERVICE = "hexo";
  var ROOT = "/blog/"||"/";
  if(!ROOT.endsWith('/'))ROOT += '/';
</script>
<script src="/blog/js/search.js"></script>
<script src="/blog/js/app.js"></script>


  <script>setLoadingBarProgress(100);</script>
</body>
</html>
