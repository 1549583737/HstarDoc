<!DOCTYPE html><html class="han-init" lang="zh-Hant"><head><meta name="author" content="Jay.M.Hu"><meta name="description" itemprop="description" content="##No.56、避免不必要的状态Tips：

尽可能地使用无状态的API
如果API是有状态的，标示出每个操作与哪些状态有关联

无状态的API简洁，更容易学习和使用，也不需要考虑其他的状态。如：
&amp;apos;test&amp;apos;.toUpperCase(); // &amp;apos;TEST&amp;apos;"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>编写高质量JS代码的68个有效方法（十二） · Love life, love coding~</title><link rel="stylesheet" type="text/css" href="/blog/font/fantasque_sans_mono/stylesheet.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/webicons/2.0.0/webicons.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/Han/3.3.0/han.min.css"><link rel="stylesheet" type="text/css" href="/blog/styles/screen.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/highlight.js/9.9.0/styles/gruvbox-dark.min.css"></head><body><header><a href="/blog/"><img class="logo" src="https://avatars1.githubusercontent.com/u/4043284?v=3&amp;s=460" alt="幻☆精灵的Blog" title="幻☆精灵的Blog"></a><h1><a href="/blog/" alt="幻☆精灵的Blog" title="幻☆精灵的Blog">幻☆精灵的Blog</a></h1><p>Love life, love coding~</p><nav><ul><li><a href="/" alt="首页" title="首页">首页</a></li><li><a href="pigeonhole" alt="归档" title="归档">归档</a></li><li><a href="links" alt="链接" title="链接">链接</a></li><li><a href="about" alt="关于" title="关于">关于</a></li></ul><div class="xnews-icon"><a target="_blank" href="https://github.com/hstarorg" style="position: relative; top: -2px;">&#xe735;</a><a target="_blank" href="https://twitter.com/Hstar19">&#xe71f;</a><a target="_blank" href="https://www.facebook.com/100015363883648">&#xe60b;</a><a target="_blank" href="https://www.zhihu.com/people/hstar">&#xe63f;</a><a target="_blank" href="https://weibo.com/hstarorg" style="position: relative; top: -2px;">&#xe603;</a></div></nav><div class="space"></div></header><main><article class="full"><h1>编写高质量JS代码的68个有效方法（十二）</h1><span class="post-meta">写于<time> 2015 年 03 月 04 日 00 时 00 分</time><br>更新于<time> 2017 年 02 月 21 日 13 时 59 分</time></span><div class="article-toc"><strong>大纲</strong></div><p>##No.56、避免不必要的状态<br><strong>Tips：</strong></p>
<ol>
<li>尽可能地使用无状态的API</li>
<li>如果API是有状态的，标示出每个操作与哪些状态有关联</li>
</ol>
<p>无状态的API简洁，更容易学习和使用，也不需要考虑其他的状态。如：</p>
<pre><code>&apos;test&apos;.toUpperCase(); // &apos;TEST&apos;
</code></pre><p>有状态的API往往会导致额外的声明，并增加复杂度。</p>
<p>##No.57、使用结构类型设计灵活的接口<br><strong>Tips：</strong></p>
<ol>
<li>使用结构类型（也称为鸭子类型）来设计灵活的对象接口</li>
<li>结构接口更灵活、更轻量，所以应该避免使用继承</li>
<li>针对单元测试，使用mock对象即接口的替代实现来提供可复验的行为</li>
</ol>
<p>直接上代码：</p>
<pre><code>function Wiki(format){
  this.format = format;
}

Wiki.prototype.show = function(source){
  var page = this.format(source);
  return {
    title: page.getTitle(),
    author: page.getAuthor(),
    content: page.getContent()
  }
}
</code></pre><p>将format设计为结构类型，可以极大的增加设计的灵活性。</p>
<p>##No.58、区分数组对象和类数组对象<br><strong>Tips：</strong></p>
<ol>
<li>绝不重载与其他类型有重叠的结构类型</li>
<li>当重载一个结构类型与其他类型时，先测试其他类型</li>
<li>当重载其他对象类型时，接收真数组而不是类数组对象</li>
</ol>
<p><strong>API绝不应该重载与其他类型有重叠的类型</strong></p>
<p>最简单的判断数组与类数组，代码如下：</p>
<pre><code>x instanceof Array
</code></pre><p>但是，在一些允许多个全局对象的环境中可能会有标准的Array构造函数和原型对象的多份副本。那么就有可能导致以上的测试结果不可信，所以在ES5引入了Array.isArray函数来判断是否是Array对象，通过检查对象内部[[Class]]属性值是否为Array来判定。在不支持ES5的环境中，可以使用标准的Object.prototype.toString方法测试一个对象是否为数组。</p>
<pre><code>function isArray(x){
  return toString.call(x) === &apos;[object Array]&apos;;
}
</code></pre><p>##No.59、避免过度的强制转换<br><strong>Tips：</strong></p>
<ol>
<li>避免强制转换和重载的混用</li>
<li>考虑防御性地监视非预期的输入</li>
</ol>
<p>看以下的函数：</p>
<pre><code>function square(x){
  return x*x;
}

console.log(square(&apos;3&apos;));  // 9 
</code></pre><p>强制转换无疑是很方便的。但很多时候却会导致含糊不清。</p>
<pre><code>function fun(x){
  x = Number(x);
  if(typeof x === &apos;number&apos;){
    return x-1;
  }else{
    return x;
  }
}
</code></pre><p>由于进行了Number(x)，那么后面的else是无法执行到的。如果不知道这个函数的细节，那么使用该函数则具有一定的模糊性。<br>事实上，如果我们要更小心的设计API，我们可以强制只接受数字和对象。</p>
<pre><code>function fun(x){
  if(typeof x === &apos;number&apos;){
    return x-1;
  }else if(typeof x === &apos;object&apos; &amp;&amp; x){
    return x;
  }else{
    throw new TypeError(&apos;expected number or array-like.&apos;);
  }
}
</code></pre><p>这种风格更加谨慎的示例，被称为防御性编程。</p>
<p>##No.60、支持方法链<br><strong>Tips：</strong></p>
<ol>
<li>使用方法链来连接无状态的操作</li>
<li>通过在无状态的方法中返回新对象来支持方法链</li>
<li>通过在有状态的方法中返回this来支持方法链</li>
</ol>
<p>无状态的API部分能力是讲复杂操作分解为更小的操作。如replace：</p>
<pre><code>function escapeHtml(str){
  return str.replace(/&amp;/g, &apos;&amp;amp;&apos;)
            .replace(/&lt;/g, &apos;&amp;lt;&apos;);
}
</code></pre><p>如果不采用方法链方式，代码应该是以下这样：</p>
<pre><code>function escapeHtml(str){
  var str1 = str.replace(/&amp;/g, &apos;&amp;amp;&apos;);
  var str2 = str1.replace(/&lt;/g, &apos;&amp;lt;&apos;);
  return str2;
}
</code></pre><p>同样的功能，将会产生多个临时变量。消除临时变量使得代码更加可读，中间结果只是得到最终结果中的一个重要步骤而已。</p>
<p>在有状态的API中设置方法链也是可行的。技巧是方法在更新对象时返回this，而不是undefined。如：</p>
<pre><code>element.setBackgroundColor(&apos;gray&apos;)
       .setColor(&apos;red&apos;)
       .setFontweight(&apos;bold&apos;);  
</code></pre><hr><section class="comment"><div class="ds-thread" data-thread-key="/blog/2015/03/04/编写高质量JS代码的68个有效方法-读书笔记/[20150304]编写高质量JS代码的68个有效方法（十二）/" data-title="编写高质量JS代码的68个有效方法（十二）" data-url="http://hstarorg.github.io/blog/blog/2015/03/04/编写高质量JS代码的68个有效方法-读书笔记/[20150304]编写高质量JS代码的68个有效方法（十二）/"></div></section><script>var _shortName = "6389370154370729000";</script><script>var duoshuoQuery = {};
duoshuoQuery["short_name"] = _shortName;
(function() {
    var ds = document.createElement("script");
    ds.type = "text/javascript";
    ds.async = true;
    ds.src = (document.location.protocol === "https:" ? "https:" : "http:") + "//static.duoshuo.com/embed.js";
    ds.charset = "utf-8";
    (document.getElementsByTagName("head")[0] ||
        document.getElementsByTagName("body")[0]).appendChild(ds);
})();</script><footer><section class="copyright">&copy; 2016 - 2017<a href="/blog/">Jay.M.Hu</a></section><section class="intro">由<a href="https://hexo.io/">Hexo</a>驱动&middot;挂载<a href="https://github.com/xadillax/hexo-xnew">X'new</a>主题</section></footer></article></main><script src="//cdn.bootcss.com/Han/3.3.0/han.min.js"></script><script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script><script src="//cdn.bootcss.com/jquery-backstretch/2.0.4/jquery.backstretch.min.js"></script><script src="/blog/scripts/highlight.pack.js"></script><script>$(function() {
    $("header").backstretch("/images/header.jpeg");

    $("figure.highlight").each(function(i, block) {
        $(block).removeClass("highlight");
        $("<pre><code class='__tobehl " + ($(block).attr("class") === "plain" ? "" : ("lang-" + $(block).attr("class"))) + "'></code></pre>").insertAfter($(block));
        $(block).next().find("code").text((block.innerText || block.textContent));
        $(block).remove();
    });
    $(".__tobehl").each(function(i, block) {
        hljs.highlightBlock(block);
    });

    $("article.full img").each(function() {
        $(this).parent().css("text-align", "center");
    });

    if($(".article-toc").children().length < 2) {
        $(".article-toc").css("display", "none");
    }
});</script></body></html>